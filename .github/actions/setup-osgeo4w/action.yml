---
name: Setup OSGeo4W environment
description: Install OSGeo4W and OSGeo4W packages on Windows
author: "Edouard ChoiniÃ¨re"

inputs:
  packages:
    description: List of OSGeo4W packages to install
    required: false
  root:
    description: Root installation directory, by default C:\OSGeo4W.
    required: false
    default: C:\OSGeo4W
  package-dir:
    description: Location where to download packages. Using a folder in a faster drive, like D:\OSGeo4W_pkg, reduces installation time.
    required: false
  site:
    description: Download site URL to use
    required: false
    default: "https://download.osgeo.org/osgeo4w/v2/"
  upgrade-also:
    description: Also upgrade installed packages
    required: false
    default: true
runs:
  using: "composite"
  steps:
    - name: Setup OSGeo4W environment
      run: |-
        "Setup OSGeo4W environment action"
        "::group::Download OSGeo4W installer"
        $exe = 'osgeo4w-setup.exe'
        $url = '${{ inputs.site }}' + $exe
        $setup = '.\' + $exe
        echo "Starting download of $url..."
        Invoke-WebRequest $url -OutFile $setup
        echo "Download completed"
        "::endgroup::"
        echo "::group::Ensure package dir exists"
        mkdir -Force '${{ inputs.package-dir }}'
        echo "::endgroup::"
        "::group::Run setup"
      shell: pwsh
    - run: npm install @actions/tool-cache
      shell: sh
    - uses: actions/github-script@v7
      with:
        script: |
          class Input {
            constructor() {
              /** @type {string} */
              this.site;
              /** @type {string} */
              this.root;
            }
          }
          function parseInput() {
            let p_root = core.getInput('root');
            let p_site = core.getInput('site');
            let input = new Input();
              input.root = p_root;
              input.site = p_site;
             return input;
          }
          const input2 = parseInput();
          //import tc from '@actions/tool-cache';
          const tc = require('@actions/tool-cache');
          console.log(input2);
    # - name: "Download OSGeo4W installer"
    #   id: download
    #   shell: pwsh
    #   run: |-
    #     "::group::Download OSGeo4W installer"
    #     $exe = 'osgeo4w-setup.exe'
    #     $url = '${{ inputs.site }}' + $exe
    #     $setup = '.\' + $exe
    #     echo "Starting download of $url..."
    #     echo "setup_path=$setup" >> "$env:GITHUB_OUTPUT"
    #     Invoke-WebRequest $url -OutFile $setup
    #     echo "Download completed"
    #     "::endgroup::"
    # - name: Ensure package dir exists
    #   if: ${{ inputs.package-dir }}
    #   shell: pwsh
    #   run: |-
    #     echo "::group::Ensure package dir exists"
    #     mkdir -Force '${{ inputs.package-dir }}'
    #     echo "::endgroup::"
    # - name: Run setup
    #   run: |-
    #     "::group::Run setup"
    #     $setup = '${{ steps.download.outputs.setup_path }}'
    #     echo "Setup executable is $setup"
    #     $args = @(
    #         '--advanced',                   # Advanced install (default)
    #         '--autoaccept',                 # Accept all licenses
    #         '--quiet-mode',                 # Unattended setup mode
    #         '--site', '${{ inputs.site }}', # Download site
    #         '--root', '${{ inputs.root }}'  # Root installation directory
    #       )
    #       # '-P', '${{ env.Deps }}',
    #       # '--local-package-dir', $pkg_dir,
    #     if ('${{ inputs.upgrade-also }}' -eq $true) {
    #       $args += '--upgrade-also'
    #     }
    #     # $deps = '${ { inputs.packages } }'
    #     # # $depsList = $deps -split '\s+' -match '\S' | where {$_.Trim(',') -ne ''}
    #     # $depsList = $deps -split '\s+' -match '\S' | where {$_.Trim() -ne ''}
    #     # $depsList = $depsList | % { $_.Trim() }
    #     # $depsList = $depsList | % { $_.Trim(',') }
    #     # if ($depsList.Count -gt 0) {
    #     #   $args += '--packages'  # Specify packages to install
    #     #   $args += $depsList -Join(',')
    #     # }
    #     # $packages = '${ { inputs.packages } }'
    #     $packages = $env:pkgs
    #     $pkg_list = $packages.Split('', [System.StringSplitOptions]::RemoveEmptyEntries)
    #     echo "pkg_list is:"
    #     echo $pkg_list
    #     $pkg_list = $pkg_list | % { $_.Trim() }
    #     echo "pkg_list trim1 is:"
    #     echo $pkg_list
    #     $pkg_list = $pkg_list | % { $_.Trim('\') }
    #     echo "pkg_list trim2 is:"
    #     echo $pkg_list
    #     $pkg_list = $pkg_list | % { $_.Trim(',') }
    #     echo "pkg_list trim3 is:"
    #     echo $pkg_list
    #     if ($pkg_list.Count -gt 0) {
    #       $args += '-P'
    #       $args += $pkg_list -Join(',')
    #     }
    #     "Command to execute: & $setup $args | Out-Default"
    #     & $setup $args | Out-Default
    #     echo "::endgroup::"
    #   shell: pwsh
    #   env:
    #     pkgs: "${{ inputs.packages }}"
