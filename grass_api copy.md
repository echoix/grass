## grass

Top-level GRASS GIS Python package

Importing the package (or any subpackage) initializes translation functions
so that the function `_` appears in the global namespace (as an additional built-in).

**Modules:**

- [**app**](#grass.app) –
- [**benchmark**](#grass.benchmark) – Benchmarking for GRASS GIS modules
- [**exceptions**](#grass.exceptions) – GRASS GIS interface to Python exceptions
- [**experimental**](#grass.experimental) – Experimental code, all can change
- [**grassdb**](#grass.grassdb) –
- [**gunittest**](#grass.gunittest) – GRASS Python testing framework module for running from command line
- [**imaging**](#grass.imaging) –
- [**jupyter**](#grass.jupyter) – A convenient GRASS GIS interface for Jupyter notebooks.
- [**pydispatch**](#grass.pydispatch) – Multi-consumer multi-producer dispatching mechanism
- [**pygrass**](#grass.pygrass) –
- [**script**](#grass.script) – Python interface to launch GRASS GIS modules in scripts
- [**semantic_label**](#grass.semantic_label) –
- [**temporal**](#grass.temporal) –
- [**utils**](#grass.utils) –

### grass.app

**Modules:**

- [**cli**](#grass.app.cli) – Experimental low-level CLI interface for the main GRASS executable functionality
- [**data**](#grass.app.data) – Provides functions for the main GRASS GIS executable
- [**runtime**](#grass.app.runtime) – Provides functions for the main GRASS GIS executable

**Classes:**

- [**MapsetLockingException**](#grass.app.MapsetLockingException) –

**Functions:**

- [**create_database_directory**](#grass.app.create_database_directory) – Creates the standard GRASS GIS directory.
- [**create_startup_location_in_grassdb**](#grass.app.create_startup_location_in_grassdb) – Create a new startup location in the given GRASS database.
- [**ensure_default_data_hierarchy**](#grass.app.ensure_default_data_hierarchy) – Ensure that default gisdbase, location and mapset exist.
- [**get_possible_database_path**](#grass.app.get_possible_database_path) – Looks for directory 'grassdata' (case-insensitive) in standard
- [**lock_mapset**](#grass.app.lock_mapset) – Acquire a lock for a mapset and return name of new lock file

#### grass.app.MapsetLockingException

Bases: <code>[Exception](#Exception)</code>

#### grass.app.cli

Experimental low-level CLI interface for the main GRASS executable functionality

This is not a stable part of the API. Contact developers before using it.

**Functions:**

- [**call_g_manual**](#grass.app.cli.call_g_manual) –
- [**main**](#grass.app.cli.main) –
- [**subcommand_lock_mapset**](#grass.app.cli.subcommand_lock_mapset) –
- [**subcommand_show_help**](#grass.app.cli.subcommand_show_help) –
- [**subcommand_show_man**](#grass.app.cli.subcommand_show_man) –
- [**subcommand_unlock_mapset**](#grass.app.cli.subcommand_unlock_mapset) –

##### grass.app.cli.call_g_manual

```python
call_g_manual(**kwargs)
```

##### grass.app.cli.main

```python
main(args=None, program=None)
```

##### grass.app.cli.subcommand_lock_mapset

```python
subcommand_lock_mapset(args)
```

##### grass.app.cli.subcommand_show_help

```python
subcommand_show_help(args)
```

##### grass.app.cli.subcommand_show_man

```python
subcommand_show_man(args)
```

##### grass.app.cli.subcommand_unlock_mapset

```python
subcommand_unlock_mapset(args)
```

#### grass.app.create_database_directory

```python
create_database_directory()
```

Creates the standard GRASS GIS directory.
Creates database directory named grassdata in the standard location
according to the platform.

Returns the new path as a string or None if nothing was found or created.

#### grass.app.create_startup_location_in_grassdb

```python
create_startup_location_in_grassdb(grassdatabase, startup_location_name)
```

Create a new startup location in the given GRASS database.

Returns True if a new startup location successfully created
in the given GRASS database.
Returns False if there is no location to copy in the installation
or copying failed.

#### grass.app.data

Provides functions for the main GRASS GIS executable

(C) 2020-2025 by Vaclav Petras and the GRASS Development Team

This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>
.. sectionauthor:: Linda Kladivova \<l.kladivova seznam cz>

This is not a stable part of the API. Use at your own risk.

**Classes:**

- [**MapsetLockingException**](#grass.app.data.MapsetLockingException) –

**Functions:**

- [**acquire_mapset_lock**](#grass.app.data.acquire_mapset_lock) – Lock a mapset and return lock process return code and name of new lock file
- [**create_database_directory**](#grass.app.data.create_database_directory) – Creates the standard GRASS GIS directory.
- [**create_startup_location_in_grassdb**](#grass.app.data.create_startup_location_in_grassdb) – Create a new startup location in the given GRASS database.
- [**ensure_default_data_hierarchy**](#grass.app.data.ensure_default_data_hierarchy) – Ensure that default gisdbase, location and mapset exist.
- [**get_possible_database_path**](#grass.app.data.get_possible_database_path) – Looks for directory 'grassdata' (case-insensitive) in standard
- [**lock_mapset**](#grass.app.data.lock_mapset) – Acquire a lock for a mapset and return name of new lock file
- [**unlock_mapset**](#grass.app.data.unlock_mapset) – Unlock a mapset

##### grass.app.data.MapsetLockingException

Bases: <code>[Exception](#Exception)</code>

##### grass.app.data.acquire_mapset_lock

```python
acquire_mapset_lock(mapset_path, *, process_id=None, timeout=30, initial_sleep=1, message_callback=None, env=None)
```

Lock a mapset and return lock process return code and name of new lock file

Acquires a lock for a mapset by calling the lock program. Returns lock process
return code and name of new lock file.

When locking fails, it will re-attempt locking again until it succeeds
or it times out. The initial sleep time is used the first time and then
it is doubled after each failed attempt. However, the sleep time is limited
to thousand times the initial sleep time, so for longer timeouts, the attempts
will start happening in equal intervals.

A *timeout* is the maximum time to wait for the lock to be released in seconds.

A *process_id* is the process ID of the process locking the mapset. If not
given, the current process ID is used.

:param mapset_path: full path to the mapset
:param process_id: process id to use for locking
:param timeout: give up in *timeout* in seconds
:param initial_sleep: initial sleep time in seconds
:param message_callback: callback to show messages when locked
:param env: system environment variables

The function assumes the `GISBASE` variable is in the environment. The variable is
used to find the lock program. If *env* is not provided, `os.environ` is used.

##### grass.app.data.create_database_directory

```python
create_database_directory()
```

Creates the standard GRASS GIS directory.
Creates database directory named grassdata in the standard location
according to the platform.

Returns the new path as a string or None if nothing was found or created.

##### grass.app.data.create_startup_location_in_grassdb

```python
create_startup_location_in_grassdb(grassdatabase, startup_location_name)
```

Create a new startup location in the given GRASS database.

Returns True if a new startup location successfully created
in the given GRASS database.
Returns False if there is no location to copy in the installation
or copying failed.

##### grass.app.data.ensure_default_data_hierarchy

```python
ensure_default_data_hierarchy()
```

Ensure that default gisdbase, location and mapset exist.
Creates database directory based on the default path determined
according to OS if needed. Creates location if needed.

Returns the db, loc, mapset, mapset_path

##### grass.app.data.get_possible_database_path

```python
get_possible_database_path()
```

Looks for directory 'grassdata' (case-insensitive) in standard
locations to detect existing GRASS Database.

Returns the path as a string or None if nothing was found.

##### grass.app.data.lock_mapset

```python
lock_mapset(mapset_path, *, force_lock_removal, timeout, message_callback, process_id=None, env=None)
```

Acquire a lock for a mapset and return name of new lock file

Raises MapsetLockingException when it is not possible to acquire a lock for the
given mapset either because of existing lock or due to insufficient permissions.
A corresponding localized message is given in the exception.

The *timeout*, *process_id*, and *env* parameters are the same as for the
:func:`acquire_mapset_lock` function. *force_lock_removal* implies zero *timeout*.

A *message_callback* is a function which will be called to report messages about
certain states. Specifically, the function is called when forcibly unlocking the
mapset.

Assumes that the runtime is set up (specifically that GISBASE is in
the environment). Environment can be provided as *env*.

##### grass.app.data.unlock_mapset

```python
unlock_mapset(mapset_path)
```

Unlock a mapset

#### grass.app.ensure_default_data_hierarchy

```python
ensure_default_data_hierarchy()
```

Ensure that default gisdbase, location and mapset exist.
Creates database directory based on the default path determined
according to OS if needed. Creates location if needed.

Returns the db, loc, mapset, mapset_path

#### grass.app.get_possible_database_path

```python
get_possible_database_path()
```

Looks for directory 'grassdata' (case-insensitive) in standard
locations to detect existing GRASS Database.

Returns the path as a string or None if nothing was found.

#### grass.app.lock_mapset

```python
lock_mapset(mapset_path, *, force_lock_removal, timeout, message_callback, process_id=None, env=None)
```

Acquire a lock for a mapset and return name of new lock file

Raises MapsetLockingException when it is not possible to acquire a lock for the
given mapset either because of existing lock or due to insufficient permissions.
A corresponding localized message is given in the exception.

The *timeout*, *process_id*, and *env* parameters are the same as for the
:func:`acquire_mapset_lock` function. *force_lock_removal* implies zero *timeout*.

A *message_callback* is a function which will be called to report messages about
certain states. Specifically, the function is called when forcibly unlocking the
mapset.

Assumes that the runtime is set up (specifically that GISBASE is in
the environment). Environment can be provided as *env*.

#### grass.app.runtime

Provides functions for the main GRASS GIS executable

(C) 2024 by Vaclav Petras and the GRASS Development Team

This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>

This is not a stable part of the API. Use at your own risk.

**Functions:**

- [**append_left_addon_paths**](#grass.app.runtime.append_left_addon_paths) – Add addons to path
- [**append_left_main_executable_paths**](#grass.app.runtime.append_left_main_executable_paths) – Add executables to PATH
- [**ensure_home**](#grass.app.runtime.ensure_home) – Set HOME if not set on MS Windows
- [**get_grass_config_dir**](#grass.app.runtime.get_grass_config_dir) – Get configuration directory
- [**set_browser**](#grass.app.runtime.set_browser) – Set path to HTML browser
- [**set_defaults**](#grass.app.runtime.set_defaults) – Set paths or commands for dependencies and auxiliary utilities
- [**set_display_defaults**](#grass.app.runtime.set_display_defaults) – Predefine monitor size for certain architectures
- [**set_dynamic_library_path**](#grass.app.runtime.set_dynamic_library_path) – Define path to dynamic libraries (LD_LIBRARY_PATH on Linux)
- [**set_executable_paths**](#grass.app.runtime.set_executable_paths) – Add paths with executables to PATH in _env_
- [**set_isis**](#grass.app.runtime.set_isis) – Enable a mixed ISIS-GRASS environment
- [**set_man_path**](#grass.app.runtime.set_man_path) – Set path for the GRASS man pages
- [**set_path_to_python_executable**](#grass.app.runtime.set_path_to_python_executable) – Set GRASS_PYTHON environment variable
- [**set_paths**](#grass.app.runtime.set_paths) – Set variables with executable paths, library paths, and other paths
- [**set_python_path_variable**](#grass.app.runtime.set_python_path_variable) – Set PYTHONPATH to find GRASS Python package in subprocesses

**Attributes:**

- [**CYGWIN**](#grass.app.runtime.CYGWIN) –
- [**MACOS**](#grass.app.runtime.MACOS) –
- [**WINDOWS**](#grass.app.runtime.WINDOWS) –

##### grass.app.runtime.CYGWIN

```python
CYGWIN = sys.platform.startswith('cygwin')
```

##### grass.app.runtime.MACOS

```python
MACOS = sys.platform.startswith('darwin')
```

##### grass.app.runtime.WINDOWS

```python
WINDOWS = sys.platform.startswith('win')
```

##### grass.app.runtime.append_left_addon_paths

```python
append_left_addon_paths(paths, config_dir, env)
```

Add addons to path

##### grass.app.runtime.append_left_main_executable_paths

```python
append_left_main_executable_paths(paths, install_path)
```

Add executables to PATH

##### grass.app.runtime.ensure_home

```python
ensure_home()
```

Set HOME if not set on MS Windows

##### grass.app.runtime.get_grass_config_dir

```python
get_grass_config_dir(major_version, minor_version, env)
```

Get configuration directory

Determines path of GRASS GIS user configuration directory.

##### grass.app.runtime.set_browser

```python
set_browser(install_path)
```

Set path to HTML browser

##### grass.app.runtime.set_defaults

```python
set_defaults(config_projshare_path)
```

Set paths or commands for dependencies and auxiliary utilities

##### grass.app.runtime.set_display_defaults

```python
set_display_defaults()
```

Predefine monitor size for certain architectures

##### grass.app.runtime.set_dynamic_library_path

```python
set_dynamic_library_path(variable_name, install_path, env)
```

Define path to dynamic libraries (LD_LIBRARY_PATH on Linux)

##### grass.app.runtime.set_executable_paths

```python
set_executable_paths(install_path, grass_config_dir, env)
```

Add paths with executables to PATH in _env_

##### grass.app.runtime.set_isis

```python
set_isis()
```

Enable a mixed ISIS-GRASS environment

ISIS is Integrated Software for Imagers and Spectrometers by USGS.

##### grass.app.runtime.set_man_path

```python
set_man_path(install_path, addon_base, env)
```

Set path for the GRASS man pages

##### grass.app.runtime.set_path_to_python_executable

```python
set_path_to_python_executable(env)
```

Set GRASS_PYTHON environment variable

##### grass.app.runtime.set_paths

```python
set_paths(install_path, grass_config_dir, ld_library_path_variable_name)
```

Set variables with executable paths, library paths, and other paths

##### grass.app.runtime.set_python_path_variable

```python
set_python_path_variable(install_path, env)
```

Set PYTHONPATH to find GRASS Python package in subprocesses

### grass.benchmark

Benchmarking for GRASS GIS modules

This subpackage of the grass package is experimental and the API can change anytime.
The API of the package is defined by what is imported in the top-level `__init__.py`
file of the subpackage.

The functions in the Python API raise exceptions, although calls of other functions from
the grass package may call grass.script.fatal and exit
(see :func:`grass.script.core.set_raise_on_error` for changing the behavior).
This applies to the CLI interface of this subpackage too except that raised usage
exceptions originating in the CLI code result in *sys.exit* with an error message, not
traceback. Messages and other user-visible texts in this package are not translatable.

**Modules:**

- [**app**](#grass.benchmark.app) – CLI for the benchmark package
- [**plots**](#grass.benchmark.plots) – Plotting functionality for benchmark results
- [**results**](#grass.benchmark.results) – Handling of raw results from benchmarking
- [**runners**](#grass.benchmark.runners) – Basic functions for benchmarking modules

**Functions:**

- [**benchmark_nprocs**](#grass.benchmark.benchmark_nprocs) – Benchmark module using values of nprocs up to *max_nprocs*.
- [**benchmark_resolutions**](#grass.benchmark.benchmark_resolutions) – Benchmark module using different resolutions.
- [**benchmark_single**](#grass.benchmark.benchmark_single) – Benchmark module as is without changing anything.
- [**join_results**](#grass.benchmark.join_results) – Join multiple lists of results together
- [**join_results_from_files**](#grass.benchmark.join_results_from_files) – Join multiple files into one results object.
- [**load_results**](#grass.benchmark.load_results) – Load results structure from JSON.
- [**load_results_from_file**](#grass.benchmark.load_results_from_file) – Loads results from a JSON file.
- [**nprocs_plot**](#grass.benchmark.nprocs_plot) – Plot results from a multiple nprocs (thread) benchmarks.
- [**num_cells_plot**](#grass.benchmark.num_cells_plot) – Plot results from a multiple raster grid size benchmarks.
- [**save_results**](#grass.benchmark.save_results) – Save results structure to JSON.
- [**save_results_to_file**](#grass.benchmark.save_results_to_file) – Saves results to as file as JSON.

#### grass.benchmark.app

CLI for the benchmark package

**Classes:**

- [**CliUsageError**](#grass.benchmark.app.CliUsageError) – Raised when error is in the command line arguments.
- [**ExtendAction**](#grass.benchmark.app.ExtendAction) – Support for agrparse action="extend" before Python 3.8

**Functions:**

- [**add_plot_io_arguments**](#grass.benchmark.app.add_plot_io_arguments) – Add input and output arguments to *parser*.
- [**add_plot_metric_argument**](#grass.benchmark.app.add_plot_metric_argument) – Add metric argument to *parser*.
- [**add_plot_subcommand**](#grass.benchmark.app.add_plot_subcommand) – Add plot subcommand.
- [**add_plot_title_argument**](#grass.benchmark.app.add_plot_title_argument) – Add title argument to *parser*.
- [**add_results_subcommand**](#grass.benchmark.app.add_results_subcommand) – Add results subcommand.
- [**add_subcommand_parser**](#grass.benchmark.app.add_subcommand_parser) – Add parser for a subcommand into subparsers.
- [**add_subparsers**](#grass.benchmark.app.add_subparsers) – Add subparsers in a unified way.
- [**define_arguments**](#grass.benchmark.app.define_arguments) – Define top level parser and create subparsers.
- [**get_executable_name**](#grass.benchmark.app.get_executable_name) – Get name of the executable and module.
- [**join_results_cli**](#grass.benchmark.app.join_results_cli) – Translate CLI parser result to API calls.
- [**main**](#grass.benchmark.app.main) – Define and parse command line parameters then run the appropriate handler.
- [**plot_cells_cli**](#grass.benchmark.app.plot_cells_cli) – Translate CLI parser result to API calls.
- [**plot_nprocs_cli**](#grass.benchmark.app.plot_nprocs_cli) – Translate CLI parser result to API calls.

##### grass.benchmark.app.CliUsageError

Bases: <code>[ValueError](#ValueError)</code>

Raised when error is in the command line arguments.

Used when the error is discovered only after argparse parsed the arguments.

##### grass.benchmark.app.ExtendAction

Bases: <code>[Action](#argparse.Action)</code>

Support for agrparse action="extend" before Python 3.8

Each parser instance needs the action to be registered.

##### grass.benchmark.app.add_plot_io_arguments

```python
add_plot_io_arguments(parser)
```

Add input and output arguments to *parser*.

##### grass.benchmark.app.add_plot_metric_argument

```python
add_plot_metric_argument(parser)
```

Add metric argument to *parser*.

##### grass.benchmark.app.add_plot_subcommand

```python
add_plot_subcommand(parent_subparsers)
```

Add plot subcommand.

##### grass.benchmark.app.add_plot_title_argument

```python
add_plot_title_argument(parser)
```

Add title argument to *parser*.

##### grass.benchmark.app.add_results_subcommand

```python
add_results_subcommand(parent_subparsers)
```

Add results subcommand.

##### grass.benchmark.app.add_subcommand_parser

```python
add_subcommand_parser(subparsers, name, description)
```

Add parser for a subcommand into subparsers.

##### grass.benchmark.app.add_subparsers

```python
add_subparsers(parser, dest)
```

Add subparsers in a unified way.

Uses title 'subcommands' for the list of commands
(instead of the 'positional' which is the default).

The *dest* should be 'command', 'subcommand', etc. with appropriate nesting.

##### grass.benchmark.app.define_arguments

```python
define_arguments()
```

Define top level parser and create subparsers.

##### grass.benchmark.app.get_executable_name

```python
get_executable_name()
```

Get name of the executable and module.

This is a workaround for Python issue:
argparse support for "python -m module" in help
https://bugs.python.org/issue22240

##### grass.benchmark.app.join_results_cli

```python
join_results_cli(args)
```

Translate CLI parser result to API calls.

##### grass.benchmark.app.main

```python
main(args=None)
```

Define and parse command line parameters then run the appropriate handler.

##### grass.benchmark.app.plot_cells_cli

```python
plot_cells_cli(args)
```

Translate CLI parser result to API calls.

##### grass.benchmark.app.plot_nprocs_cli

```python
plot_nprocs_cli(args)
```

Translate CLI parser result to API calls.

#### grass.benchmark.benchmark_nprocs

```python
benchmark_nprocs(module, label, max_nprocs, repeat=5, shuffle=True)
```

Benchmark module using values of nprocs up to *max_nprocs*.

*module* is an instance of PyGRASS Module class or any object which
has a *update* method taking *nprocs* as a keyword argument,
a *run* which takes no arguments and executes the benchmarked code,
and attribute *time* which is set to execution time after the *run*
function returned. Additionally, the object should be convertible to *str*
for printing.

The module is executed for each generated value of nprocs. *max_nprocs* is used
to generate a continuous range of integer values from 1 up to *max_nprocs*.
*repeat* sets how many times the each run is repeated.
So, the module will run `max_nprocs * repeat` times.
Runs are executed in random order, set *shuffle* to false if they
need to be executed in order based on number of threads.

*label* is a text to add to the result (for user-facing display).
Optional *nprocs* is passed to the module if present.

Returns an object with attributes *times* (list of average execution times),
*all_times* (list of lists of measured execution times),
*efficiency* (parallel efficiency), *nprocs* (list of *nprocs* values used),
and *label* (the provided parameter as is).

#### grass.benchmark.benchmark_resolutions

```python
benchmark_resolutions(module, resolutions, label, repeat=5, nprocs=None)
```

Benchmark module using different resolutions.

*module* is an instance of PyGRASS Module class or any object
with attributes as specified in :func:`benchmark_nprocs`
except that the *update* method is required only when *nprocs* is set.

*resolutions* is a list of resolutions to set (current region is currently
used and changed but that may change in the future).
*repeat* sets how many times the each run is repeated.
So, the module will run `len(resolutions) * repeat` times.

*label* is a text to add to the result (for user-facing display).
Optional *nprocs* is passed to the module if present
(the called module does not have to support nprocs parameter).

Returns an object with attributes *times* (list of average execution times),
*all_times* (list of lists of measured execution times), *resolutions*
(the provided parameter as is), *cells* (number of cells in the region),
and *label* (the provided parameter as is).

#### grass.benchmark.benchmark_single

```python
benchmark_single(module, label, repeat=5)
```

Benchmark module as is without changing anything.

*module* is an instance of PyGRASS Module class or any object which
has a *run* method which takes no arguments and executes the benchmarked code,
and attribute *time* which is set to execution time after the *run*
function returned. Additionally, the object should be convertible to *str*
for printing.

*repeat* sets how many times the each run is repeated.
*label* is a text to add to the result (for user-facing display).

Returns an object with attributes *time* (an average execution time),
*all_times* (list of measured execution times),
and *label* (the provided parameter as is).

#### grass.benchmark.join_results

```python
join_results(results, prefixes=None, select=None, prefixes_as_labels=False)
```

Join multiple lists of results together

The *results* argument either needs to be a list of result objects
or an object with attribute *results* which is the list of result objects.
This allows for results loaded from a file to be combined with a simple list.

The function always returns just a simple list of result objects.

#### grass.benchmark.join_results_from_files

```python
join_results_from_files(source_filenames, prefixes=None, select=None, prefixes_as_labels=False)
```

Join multiple files into one results object.

#### grass.benchmark.load_results

```python
load_results(data)
```

Load results structure from JSON.

Takes str, returns nested structure with SimpleNamespace instead of the
default dictionary object. Use attribute access to access by key
(not dict-like syntax).

#### grass.benchmark.load_results_from_file

```python
load_results_from_file(filename)
```

Loads results from a JSON file.

See :func:`load_results` for details.

#### grass.benchmark.nprocs_plot

```python
nprocs_plot(results, filename=None, title=None, metric='time')
```

Plot results from a multiple nprocs (thread) benchmarks.

*results* is a list of individual results from separate benchmarks.
One result is required to have attributes: *nprocs*, *times*, *label*.
The *nprocs* attribute is a list of all processing elements
(cores, threads, processes) used in the benchmark.
The *times* attribute is a list of corresponding times for each value
from the *nprocs* list.
The *label* attribute identifies the benchmark in the legend.

*metric* can be "time", "speedup", or "efficiency".
This function plots a corresponding figure based on the chosen metric.

Optionally, result can have an *all_times* attribute which is a list
of lists. One sublist is all times recorded for each value of nprocs.

Each result can come with a different list of nprocs, i.e., benchmarks
which used different values for nprocs can be combined in one plot.

#### grass.benchmark.num_cells_plot

```python
num_cells_plot(results, filename=None, title=None, show_resolution=False)
```

Plot results from a multiple raster grid size benchmarks.

*results* is a list of individual results from separate benchmarks
with one result being similar to the :func:`nprocs_plot` function.
The result is required to have *times* and *label* attributes
and may have an *all_times* attribute.
Further, it is required to have *cells* attribute, or,
when `show_resolution=True`, it needs to have a *resolutions* attribute.

Each result can come with a different list of nprocs, i.e., benchmarks
which used different values for nprocs can be combined in one plot.

#### grass.benchmark.plots

Plotting functionality for benchmark results

**Functions:**

- [**get_pyplot**](#grass.benchmark.plots.get_pyplot) – Get pyplot from matplotlib
- [**nprocs_plot**](#grass.benchmark.plots.nprocs_plot) – Plot results from a multiple nprocs (thread) benchmarks.
- [**num_cells_plot**](#grass.benchmark.plots.num_cells_plot) – Plot results from a multiple raster grid size benchmarks.

##### grass.benchmark.plots.get_pyplot

```python
get_pyplot(to_file)
```

Get pyplot from matplotlib

Lazy import to easily run code importing this function on limited installations.
Only actual call to this function requires matplotlib.

The *to_file* parameter can be set to True to avoid tkinter dependency
if the interactive show method is not needed.

##### grass.benchmark.plots.nprocs_plot

```python
nprocs_plot(results, filename=None, title=None, metric='time')
```

Plot results from a multiple nprocs (thread) benchmarks.

*results* is a list of individual results from separate benchmarks.
One result is required to have attributes: *nprocs*, *times*, *label*.
The *nprocs* attribute is a list of all processing elements
(cores, threads, processes) used in the benchmark.
The *times* attribute is a list of corresponding times for each value
from the *nprocs* list.
The *label* attribute identifies the benchmark in the legend.

*metric* can be "time", "speedup", or "efficiency".
This function plots a corresponding figure based on the chosen metric.

Optionally, result can have an *all_times* attribute which is a list
of lists. One sublist is all times recorded for each value of nprocs.

Each result can come with a different list of nprocs, i.e., benchmarks
which used different values for nprocs can be combined in one plot.

##### grass.benchmark.plots.num_cells_plot

```python
num_cells_plot(results, filename=None, title=None, show_resolution=False)
```

Plot results from a multiple raster grid size benchmarks.

*results* is a list of individual results from separate benchmarks
with one result being similar to the :func:`nprocs_plot` function.
The result is required to have *times* and *label* attributes
and may have an *all_times* attribute.
Further, it is required to have *cells* attribute, or,
when `show_resolution=True`, it needs to have a *resolutions* attribute.

Each result can come with a different list of nprocs, i.e., benchmarks
which used different values for nprocs can be combined in one plot.

#### grass.benchmark.results

Handling of raw results from benchmarking

**Classes:**

- [**ResultsEncoder**](#grass.benchmark.results.ResultsEncoder) – Results encoder for JSON which handles SimpleNamespace objects

**Functions:**

- [**join_results**](#grass.benchmark.results.join_results) – Join multiple lists of results together
- [**join_results_from_files**](#grass.benchmark.results.join_results_from_files) – Join multiple files into one results object.
- [**load_results**](#grass.benchmark.results.load_results) – Load results structure from JSON.
- [**load_results_from_file**](#grass.benchmark.results.load_results_from_file) – Loads results from a JSON file.
- [**save_results**](#grass.benchmark.results.save_results) – Save results structure to JSON.
- [**save_results_to_file**](#grass.benchmark.results.save_results_to_file) – Saves results to as file as JSON.

##### grass.benchmark.results.ResultsEncoder

Bases: <code>[JSONEncoder](#json.JSONEncoder)</code>

Results encoder for JSON which handles SimpleNamespace objects

**Functions:**

- [**default**](#grass.benchmark.results.ResultsEncoder.default) – Handle additional types

###### grass.benchmark.results.ResultsEncoder.default

```python
default(o)
```

Handle additional types

##### grass.benchmark.results.join_results

```python
join_results(results, prefixes=None, select=None, prefixes_as_labels=False)
```

Join multiple lists of results together

The *results* argument either needs to be a list of result objects
or an object with attribute *results* which is the list of result objects.
This allows for results loaded from a file to be combined with a simple list.

The function always returns just a simple list of result objects.

##### grass.benchmark.results.join_results_from_files

```python
join_results_from_files(source_filenames, prefixes=None, select=None, prefixes_as_labels=False)
```

Join multiple files into one results object.

##### grass.benchmark.results.load_results

```python
load_results(data)
```

Load results structure from JSON.

Takes str, returns nested structure with SimpleNamespace instead of the
default dictionary object. Use attribute access to access by key
(not dict-like syntax).

##### grass.benchmark.results.load_results_from_file

```python
load_results_from_file(filename)
```

Loads results from a JSON file.

See :func:`load_results` for details.

##### grass.benchmark.results.save_results

```python
save_results(data)
```

Save results structure to JSON.

If the provided object does not have results attribute,
it is assumed that the list which should be results attribute was provided,
so the provided object object is saved under new `results` key.

Returns JSON as str.

##### grass.benchmark.results.save_results_to_file

```python
save_results_to_file(results, filename)
```

Saves results to as file as JSON.

See :func:`save_results` for details.

#### grass.benchmark.runners

Basic functions for benchmarking modules

**Functions:**

- [**benchmark_nprocs**](#grass.benchmark.runners.benchmark_nprocs) – Benchmark module using values of nprocs up to *max_nprocs*.
- [**benchmark_resolutions**](#grass.benchmark.runners.benchmark_resolutions) – Benchmark module using different resolutions.
- [**benchmark_single**](#grass.benchmark.runners.benchmark_single) – Benchmark module as is without changing anything.

##### grass.benchmark.runners.benchmark_nprocs

```python
benchmark_nprocs(module, label, max_nprocs, repeat=5, shuffle=True)
```

Benchmark module using values of nprocs up to *max_nprocs*.

*module* is an instance of PyGRASS Module class or any object which
has a *update* method taking *nprocs* as a keyword argument,
a *run* which takes no arguments and executes the benchmarked code,
and attribute *time* which is set to execution time after the *run*
function returned. Additionally, the object should be convertible to *str*
for printing.

The module is executed for each generated value of nprocs. *max_nprocs* is used
to generate a continuous range of integer values from 1 up to *max_nprocs*.
*repeat* sets how many times the each run is repeated.
So, the module will run `max_nprocs * repeat` times.
Runs are executed in random order, set *shuffle* to false if they
need to be executed in order based on number of threads.

*label* is a text to add to the result (for user-facing display).
Optional *nprocs* is passed to the module if present.

Returns an object with attributes *times* (list of average execution times),
*all_times* (list of lists of measured execution times),
*efficiency* (parallel efficiency), *nprocs* (list of *nprocs* values used),
and *label* (the provided parameter as is).

##### grass.benchmark.runners.benchmark_resolutions

```python
benchmark_resolutions(module, resolutions, label, repeat=5, nprocs=None)
```

Benchmark module using different resolutions.

*module* is an instance of PyGRASS Module class or any object
with attributes as specified in :func:`benchmark_nprocs`
except that the *update* method is required only when *nprocs* is set.

*resolutions* is a list of resolutions to set (current region is currently
used and changed but that may change in the future).
*repeat* sets how many times the each run is repeated.
So, the module will run `len(resolutions) * repeat` times.

*label* is a text to add to the result (for user-facing display).
Optional *nprocs* is passed to the module if present
(the called module does not have to support nprocs parameter).

Returns an object with attributes *times* (list of average execution times),
*all_times* (list of lists of measured execution times), *resolutions*
(the provided parameter as is), *cells* (number of cells in the region),
and *label* (the provided parameter as is).

##### grass.benchmark.runners.benchmark_single

```python
benchmark_single(module, label, repeat=5)
```

Benchmark module as is without changing anything.

*module* is an instance of PyGRASS Module class or any object which
has a *run* method which takes no arguments and executes the benchmarked code,
and attribute *time* which is set to execution time after the *run*
function returned. Additionally, the object should be convertible to *str*
for printing.

*repeat* sets how many times the each run is repeated.
*label* is a text to add to the result (for user-facing display).

Returns an object with attributes *time* (an average execution time),
*all_times* (list of measured execution times),
and *label* (the provided parameter as is).

#### grass.benchmark.save_results

```python
save_results(data)
```

Save results structure to JSON.

If the provided object does not have results attribute,
it is assumed that the list which should be results attribute was provided,
so the provided object object is saved under new `results` key.

Returns JSON as str.

#### grass.benchmark.save_results_to_file

```python
save_results_to_file(results, filename)
```

Saves results to as file as JSON.

See :func:`save_results` for details.

### grass.exceptions

GRASS GIS interface to Python exceptions

**Classes:**

- [**CalledModuleError**](#grass.exceptions.CalledModuleError) – Raised when a called module ends with error (non-zero return code)
- [**DBError**](#grass.exceptions.DBError) –
- [**FatalError**](#grass.exceptions.FatalError) –
- [**FlagError**](#grass.exceptions.FlagError) –
- [**GrassError**](#grass.exceptions.GrassError) –
- [**ImplementationError**](#grass.exceptions.ImplementationError) –
- [**OpenError**](#grass.exceptions.OpenError) –
- [**ParameterError**](#grass.exceptions.ParameterError) –
- [**ScriptError**](#grass.exceptions.ScriptError) – Raised during script execution. ::
- [**Usage**](#grass.exceptions.Usage) –

#### grass.exceptions.CalledModuleError

```python
CalledModuleError(module, code, returncode, errors=None)
```

Bases: <code>[CalledProcessError](#subprocess.CalledProcessError)</code>

Raised when a called module ends with error (non-zero return code)

Used for failures of modules called as subprocesses from Python code.

**Attributes:**

- [**msg**](#grass.exceptions.CalledModuleError.msg) –

Create an exception with a full error message based on the parameters.

:param module: module name
:param code: some code snipped which contains parameters
:param returncode: process returncode (assuming non-zero)
:param errors: errors provided by the module (e.g., stderr)

##### grass.exceptions.CalledModuleError.msg

```python
msg = _('Module run `{executed}` ended with an error.\nThe subprocess ended with a non-zero return code: {returncode}. {see_errors}').format(executed=executed, returncode=returncode, see_errors=err)
```

#### grass.exceptions.DBError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.FatalError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.FlagError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.GrassError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.ImplementationError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.OpenError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.ParameterError

Bases: <code>[Exception](#Exception)</code>

#### grass.exceptions.ScriptError

```python
ScriptError(value)
```

Bases: <code>[Exception](#Exception)</code>

Raised during script execution. ::

> > > error = ScriptError("My error message!")
> > > error.value
> > > 'My error message!'
> > > print(error)
> > > My error message!

**Attributes:**

- [**value**](#grass.exceptions.ScriptError.value) –

##### grass.exceptions.ScriptError.value

```python
value = value
```

#### grass.exceptions.Usage

Bases: <code>[Exception](#Exception)</code>

### grass.experimental

Experimental code, all can change

**Modules:**

- [**create**](#grass.experimental.create) – Likely going into grass.grassdb.create
- [**mapset**](#grass.experimental.mapset) – Session or subsession for mapsets (subprojects)

**Classes:**

- [**MapsetSession**](#grass.experimental.MapsetSession) – Session in another mapset in the same location
- [**TemporaryMapsetSession**](#grass.experimental.TemporaryMapsetSession) – Session in another mapset in the same location

**Functions:**

- [**create_temporary_mapset**](#grass.experimental.create_temporary_mapset) – Create temporary mapset
- [**require_create_ensure_mapset**](#grass.experimental.require_create_ensure_mapset) – Checks that mapsets exists or creates it in a specified location

#### grass.experimental.MapsetSession

```python
MapsetSession(name, *, create=False, overwrite=False, ensure=False, env=None)
```

Session in another mapset in the same location

By default, it assumes that the mapset exists and raises ValueError otherwise.
Use *create* to create a new mapset and add *overwrite* to delete an existing
one of the same name (with all the data in it) before the new one is created.
To use an existing mapset if it exist and create it if it doesn't exist,
use *ensure*.

Note that *ensure* will not create a new mapset if the current is invalid.
Invalid mapset may mean corrupt data, so it is not clear what to do.
Using create with overwrite will work on an invalid mapset because
the existing mapset is always deleted with overwrite enabled.

Standard use of the object is to use it as a context manager, i.e., create it
using the `with` statement. Then use its *env* property to pass the environment
variables for the session to subprocesses:

> > > with MapsetSession(name, ensure=True) as session:
> > > ... run_command("r.surf.fractal", output="surface", env=session.env)

This session expects an existing GRASS runtime environment.

The name argument is positional-only.

.. versionadded:: 8.4

**Functions:**

- [**finish**](#grass.experimental.MapsetSession.finish) – Finish the session.

**Attributes:**

- [**active**](#grass.experimental.MapsetSession.active) – True if session is active (i.e., not finished)
- [**env**](#grass.experimental.MapsetSession.env) – Mapping object with environment variables
- [**name**](#grass.experimental.MapsetSession.name) – Mapset name

Starts the session and creates the mapset if requested

##### grass.experimental.MapsetSession.active

```python
active
```

True if session is active (i.e., not finished)

##### grass.experimental.MapsetSession.env

```python
env
```

Mapping object with environment variables

This is suitable for subprocess which should run this mapset.

##### grass.experimental.MapsetSession.finish

```python
finish()
```

Finish the session.

If not used as a context manager, call explicitly to clean and close the mapset
and finish the session. No GRASS modules can be called afterwards with
the environment obtained from this object.

##### grass.experimental.MapsetSession.name

```python
name
```

Mapset name

#### grass.experimental.TemporaryMapsetSession

```python
TemporaryMapsetSession(*, location=None, env=None)
```

Session in another mapset in the same location

By default, it assumes that the mapset exists and raises ValueError otherwise.
Use *create* to create a new mapset and add *overwrite* to delete an existing
one of the same name (with all the data in it) before the new one is created.
To use an existing mapset if it exist and create it if it doesn't exist,
use *ensure*.

Note that *ensure* will not create a new mapset if the current is invalid.
Invalid mapset may mean corrupt data, so it is not clear what to do.
Using create with overwrite will work on an invalid mapset because
the existing mapset is always deleted with overwrite enabled.

Standard use of the object is to use it as a context manager, i.e., create it
using the `with` statement. Then use its *env* property to pass the environment
variables for the session to subprocesses:

> > > with MapsetSession(name, ensure=True) as session:
> > > ... run_command("r.surf.fractal", output="surface", env=session.env)

The name argument is positional-only.

.. versionadded:: 8.4

**Functions:**

- [**finish**](#grass.experimental.TemporaryMapsetSession.finish) – Finish the session.

**Attributes:**

- [**active**](#grass.experimental.TemporaryMapsetSession.active) – True if session is active (i.e., not finished)
- [**env**](#grass.experimental.TemporaryMapsetSession.env) – Mapping object with environment variables
- [**mapset_path**](#grass.experimental.TemporaryMapsetSession.mapset_path) – MapsetPath
- [**name**](#grass.experimental.TemporaryMapsetSession.name) – Mapset name

Starts the session and creates the mapset if requested

##### grass.experimental.TemporaryMapsetSession.active

```python
active
```

True if session is active (i.e., not finished)

##### grass.experimental.TemporaryMapsetSession.env

```python
env
```

Mapping object with environment variables

This is suitable for subprocess which should run this mapset.

##### grass.experimental.TemporaryMapsetSession.finish

```python
finish()
```

Finish the session.

If not used as a context manager, call explicitly to clean and close the mapset
and finish the session. No GRASS modules can be called afterwards with
the environment obtained from this object.

##### grass.experimental.TemporaryMapsetSession.mapset_path

```python
mapset_path
```

MapsetPath

##### grass.experimental.TemporaryMapsetSession.name

```python
name
```

Mapset name

#### grass.experimental.create

Likely going into grass.grassdb.create

**Functions:**

- [**create_temporary_mapset**](#grass.experimental.create.create_temporary_mapset) – Create temporary mapset
- [**require_create_ensure_mapset**](#grass.experimental.create.require_create_ensure_mapset) – Checks that mapsets exists or creates it in a specified location

##### grass.experimental.create.create_temporary_mapset

```python
create_temporary_mapset(path, location=None)
```

Create temporary mapset

The user of this function is responsible for deleting the contents of the
temporary directory and the directory itself when done with it.

##### grass.experimental.create.require_create_ensure_mapset

```python
require_create_ensure_mapset(path, location=None, mapset=None, *, create=False, overwrite=False, ensure=False)
```

Checks that mapsets exists or creates it in a specified location

By default, it checks that the mapset exists and raises a ValueError otherwise.
If *create* is True and the mapset does not exists, it creates it.
If it exists and *overwrite* is True, it deletes the existing mapset
(with all the data in it). If *ensure* is True, existing mapset is used
as is and when there is none, a new mapset is created.

Where the mapset is specified by a full path or by location name and path
to the directory where the location is.

The path argument is positional-only. Location and mapset are recommend to be used
as positional.

#### grass.experimental.create_temporary_mapset

```python
create_temporary_mapset(path, location=None)
```

Create temporary mapset

The user of this function is responsible for deleting the contents of the
temporary directory and the directory itself when done with it.

#### grass.experimental.mapset

Session or subsession for mapsets (subprojects)

**Classes:**

- [**MapsetSession**](#grass.experimental.mapset.MapsetSession) – Session in another mapset in the same location
- [**TemporaryMapsetSession**](#grass.experimental.mapset.TemporaryMapsetSession) – Session in another mapset in the same location

##### grass.experimental.mapset.MapsetSession

```python
MapsetSession(name, *, create=False, overwrite=False, ensure=False, env=None)
```

Session in another mapset in the same location

By default, it assumes that the mapset exists and raises ValueError otherwise.
Use *create* to create a new mapset and add *overwrite* to delete an existing
one of the same name (with all the data in it) before the new one is created.
To use an existing mapset if it exist and create it if it doesn't exist,
use *ensure*.

Note that *ensure* will not create a new mapset if the current is invalid.
Invalid mapset may mean corrupt data, so it is not clear what to do.
Using create with overwrite will work on an invalid mapset because
the existing mapset is always deleted with overwrite enabled.

Standard use of the object is to use it as a context manager, i.e., create it
using the `with` statement. Then use its *env* property to pass the environment
variables for the session to subprocesses:

> > > with MapsetSession(name, ensure=True) as session:
> > > ... run_command("r.surf.fractal", output="surface", env=session.env)

This session expects an existing GRASS runtime environment.

The name argument is positional-only.

.. versionadded:: 8.4

**Functions:**

- [**finish**](#grass.experimental.mapset.MapsetSession.finish) – Finish the session.

**Attributes:**

- [**active**](#grass.experimental.mapset.MapsetSession.active) – True if session is active (i.e., not finished)
- [**env**](#grass.experimental.mapset.MapsetSession.env) – Mapping object with environment variables
- [**name**](#grass.experimental.mapset.MapsetSession.name) – Mapset name

Starts the session and creates the mapset if requested

###### grass.experimental.mapset.MapsetSession.active

```python
active
```

True if session is active (i.e., not finished)

###### grass.experimental.mapset.MapsetSession.env

```python
env
```

Mapping object with environment variables

This is suitable for subprocess which should run this mapset.

###### grass.experimental.mapset.MapsetSession.finish

```python
finish()
```

Finish the session.

If not used as a context manager, call explicitly to clean and close the mapset
and finish the session. No GRASS modules can be called afterwards with
the environment obtained from this object.

###### grass.experimental.mapset.MapsetSession.name

```python
name
```

Mapset name

##### grass.experimental.mapset.TemporaryMapsetSession

```python
TemporaryMapsetSession(*, location=None, env=None)
```

Session in another mapset in the same location

By default, it assumes that the mapset exists and raises ValueError otherwise.
Use *create* to create a new mapset and add *overwrite* to delete an existing
one of the same name (with all the data in it) before the new one is created.
To use an existing mapset if it exist and create it if it doesn't exist,
use *ensure*.

Note that *ensure* will not create a new mapset if the current is invalid.
Invalid mapset may mean corrupt data, so it is not clear what to do.
Using create with overwrite will work on an invalid mapset because
the existing mapset is always deleted with overwrite enabled.

Standard use of the object is to use it as a context manager, i.e., create it
using the `with` statement. Then use its *env* property to pass the environment
variables for the session to subprocesses:

> > > with MapsetSession(name, ensure=True) as session:
> > > ... run_command("r.surf.fractal", output="surface", env=session.env)

The name argument is positional-only.

.. versionadded:: 8.4

**Functions:**

- [**finish**](#grass.experimental.mapset.TemporaryMapsetSession.finish) – Finish the session.

**Attributes:**

- [**active**](#grass.experimental.mapset.TemporaryMapsetSession.active) – True if session is active (i.e., not finished)
- [**env**](#grass.experimental.mapset.TemporaryMapsetSession.env) – Mapping object with environment variables
- [**mapset_path**](#grass.experimental.mapset.TemporaryMapsetSession.mapset_path) – MapsetPath
- [**name**](#grass.experimental.mapset.TemporaryMapsetSession.name) – Mapset name

Starts the session and creates the mapset if requested

###### grass.experimental.mapset.TemporaryMapsetSession.active

```python
active
```

True if session is active (i.e., not finished)

###### grass.experimental.mapset.TemporaryMapsetSession.env

```python
env
```

Mapping object with environment variables

This is suitable for subprocess which should run this mapset.

###### grass.experimental.mapset.TemporaryMapsetSession.finish

```python
finish()
```

Finish the session.

If not used as a context manager, call explicitly to clean and close the mapset
and finish the session. No GRASS modules can be called afterwards with
the environment obtained from this object.

###### grass.experimental.mapset.TemporaryMapsetSession.mapset_path

```python
mapset_path
```

MapsetPath

###### grass.experimental.mapset.TemporaryMapsetSession.name

```python
name
```

Mapset name

#### grass.experimental.require_create_ensure_mapset

```python
require_create_ensure_mapset(path, location=None, mapset=None, *, create=False, overwrite=False, ensure=False)
```

Checks that mapsets exists or creates it in a specified location

By default, it checks that the mapset exists and raises a ValueError otherwise.
If *create* is True and the mapset does not exists, it creates it.
If it exists and *overwrite* is True, it deletes the existing mapset
(with all the data in it). If *ensure* is True, existing mapset is used
as is and when there is none, a new mapset is created.

Where the mapset is specified by a full path or by location name and path
to the directory where the location is.

The path argument is positional-only. Location and mapset are recommend to be used
as positional.

### grass.grassdb

**Modules:**

- [**checks**](#grass.grassdb.checks) – Checking objects in a GRASS GIS Spatial Database
- [**config**](#grass.grassdb.config) – Set global variables for objects in a GRASS GIS Spatial Database
- [**create**](#grass.grassdb.create) – Create objects in GRASS GIS Spatial Database
- [**data**](#grass.grassdb.data) – Manipulate data in mapsets in GRASS GIS Spatial Database
- [**history**](#grass.grassdb.history) – Managing existing history files included within mapset
- [**manage**](#grass.grassdb.manage) – Managing existing objects in a GRASS GIS Spatial Database

#### grass.grassdb.checks

Checking objects in a GRASS GIS Spatial Database

(C) 2020 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>

**Functions:**

- [**can_start_in_mapset**](#grass.grassdb.checks.can_start_in_mapset) – Check if a mapset from a gisrc file is usable for new session
- [**dir_contains_location**](#grass.grassdb.checks.dir_contains_location) – Return True if directory *path* contains a valid location
- [**get_list_of_locations**](#grass.grassdb.checks.get_list_of_locations) – Get list of GRASS locations in given dbase
- [**get_location_invalid_reason**](#grass.grassdb.checks.get_location_invalid_reason) – Returns a message describing what is wrong with the Location
- [**get_location_invalid_suggestion**](#grass.grassdb.checks.get_location_invalid_suggestion) – Return suggestion what to do when specified location is not valid
- [**get_location_name_invalid_reason**](#grass.grassdb.checks.get_location_name_invalid_reason) – Get reasons why location name is not valid.
- [**get_lockfile_if_present**](#grass.grassdb.checks.get_lockfile_if_present) – Return path to lock if present, None otherwise
- [**get_mapset_invalid_reason**](#grass.grassdb.checks.get_mapset_invalid_reason) – Returns a message describing what is wrong with the Mapset
- [**get_mapset_lock_info**](#grass.grassdb.checks.get_mapset_lock_info) – Get information about .gislock file.
- [**get_mapset_name_invalid_reason**](#grass.grassdb.checks.get_mapset_name_invalid_reason) – Get reasons why mapset name is not valid.
- [**get_mapset_owner**](#grass.grassdb.checks.get_mapset_owner) – Returns mapset owner name or None if owner name unknown.
- [**get_reason_id_mapset_not_usable**](#grass.grassdb.checks.get_reason_id_mapset_not_usable) – It finds a reason why mapset is not usable.
- [**get_reason_mapset_not_removable**](#grass.grassdb.checks.get_reason_mapset_not_removable) – Get reason why one mapset cannot be removed.
- [**get_reasons_grassdb_not_removable**](#grass.grassdb.checks.get_reasons_grassdb_not_removable) – Get reasons why one grassdb cannot be removed.
- [**get_reasons_location_not_removable**](#grass.grassdb.checks.get_reasons_location_not_removable) – Get reasons why one location cannot be removed.
- [**get_reasons_locations_not_removable**](#grass.grassdb.checks.get_reasons_locations_not_removable) – Get reasons why locations cannot be removed.
- [**get_reasons_mapsets_not_removable**](#grass.grassdb.checks.get_reasons_mapsets_not_removable) – Get reasons why mapsets cannot be removed.
- [**is_current_user_mapset_owner**](#grass.grassdb.checks.is_current_user_mapset_owner) – Returns True if mapset owner is the current user.
- [**is_different_mapset_owner**](#grass.grassdb.checks.is_different_mapset_owner) – Returns True if mapset owner is different from the current user
- [**is_fallback_session**](#grass.grassdb.checks.is_fallback_session) – Checks if a user encounters a fallback GRASS session.
- [**is_first_time_user**](#grass.grassdb.checks.is_first_time_user) – Check if a user is a first-time user.
- [**is_location_current**](#grass.grassdb.checks.is_location_current) – Return True if the given GRASS Location is the current location
- [**is_location_name_valid**](#grass.grassdb.checks.is_location_name_valid) – Check if location name is valid.
- [**is_location_valid**](#grass.grassdb.checks.is_location_valid) – Return True if GRASS Location is valid
- [**is_mapset_current**](#grass.grassdb.checks.is_mapset_current) – Return True if the given GRASS Mapset is the current mapset
- [**is_mapset_locked**](#grass.grassdb.checks.is_mapset_locked) – Check if the mapset is locked
- [**is_mapset_name_valid**](#grass.grassdb.checks.is_mapset_name_valid) – Check if mapset name is valid.
- [**is_mapset_valid**](#grass.grassdb.checks.is_mapset_valid) – Return True if GRASS Mapset is valid
- [**location_exists**](#grass.grassdb.checks.location_exists) – Returns True whether location path exists.
- [**mapset_exists**](#grass.grassdb.checks.mapset_exists) – Returns True whether mapset path exists.

##### grass.grassdb.checks.can_start_in_mapset

```python
can_start_in_mapset(mapset_path, ignore_lock=False)
```

Check if a mapset from a gisrc file is usable for new session

##### grass.grassdb.checks.dir_contains_location

```python
dir_contains_location(path)
```

Return True if directory *path* contains a valid location

##### grass.grassdb.checks.get_list_of_locations

```python
get_list_of_locations(dbase)
```

Get list of GRASS locations in given dbase

:param dbase: GRASS database path

:return: list of locations (sorted)

##### grass.grassdb.checks.get_location_invalid_reason

```python
get_location_invalid_reason(database, location, none_for_no_reason=False)
```

Returns a message describing what is wrong with the Location

The goal is to provide the most suitable error message
(rather than to do a quick check).

By default, when no reason is found, a message about unknown reason is
returned. This applies also to the case when this function is called on
a valid location (e.g. as a part of larger investigation).
`none_for_no_reason=True` allows the function to be used as part of other
diagnostic. When this function fails to find reason for invalidity, other
the caller can continue the investigation in their context.

:param database: Path to GRASS GIS database directory
:param location: name of a Location
:param none_for_no_reason: When True, return None when reason is unknown
:returns: translated message or None

##### grass.grassdb.checks.get_location_invalid_suggestion

```python
get_location_invalid_suggestion(database, location)
```

Return suggestion what to do when specified location is not valid

<details class="it-gives-suggestion-when" open>
<summary>It gives suggestion when</summary>
* A mapset was specified instead of a location.
* A GRASS database was specified instead of a location.
</details>

##### grass.grassdb.checks.get_location_name_invalid_reason

```python
get_location_name_invalid_reason(grassdb, location_name)
```

Get reasons why location name is not valid.

<details class="it-gets-reasons-when" open>
<summary>It gets reasons when</summary>
* Name is not valid.
* Location in the same path already exists.
</details>

Returns message as string if there was a reason, otherwise None.

##### grass.grassdb.checks.get_lockfile_if_present

```python
get_lockfile_if_present(database, location, mapset)
```

Return path to lock if present, None otherwise

Returns the path as a string or None if nothing was found, so the
return value can be used to test if the lock is present.

##### grass.grassdb.checks.get_mapset_invalid_reason

```python
get_mapset_invalid_reason(database, location, mapset, none_for_no_reason=False)
```

Returns a message describing what is wrong with the Mapset

The goal is to provide the most suitable error message
(rather than to do a quick check).

:param database: Path to GRASS GIS database directory
:param location: name of a Location
:param mapset: name of a Mapset
:returns: translated message

##### grass.grassdb.checks.get_mapset_lock_info

```python
get_mapset_lock_info(mapset_path)
```

Get information about .gislock file.
Assumes lock file exists, use is_mapset_locked to find out.
Returns information as a dictionary with keys
'owner' (None if unknown), 'lockpath', and 'timestamp'.

##### grass.grassdb.checks.get_mapset_name_invalid_reason

```python
get_mapset_name_invalid_reason(database, location, mapset_name)
```

Get reasons why mapset name is not valid.

<details class="it-gets-reasons-when" open>
<summary>It gets reasons when</summary>
* Name is not valid.
* Name is reserved for OGR layers.
* Mapset in the same path already exists.
</details>

Returns message as string if there was a reason, otherwise None.

##### grass.grassdb.checks.get_mapset_owner

```python
get_mapset_owner(mapset_path)
```

Returns mapset owner name or None if owner name unknown.
On Windows it always returns None.

##### grass.grassdb.checks.get_reason_id_mapset_not_usable

```python
get_reason_id_mapset_not_usable(mapset_path)
```

It finds a reason why mapset is not usable.

Returns a reason id as a string.
If mapset path is None or no reason found, returns None.

##### grass.grassdb.checks.get_reason_mapset_not_removable

```python
get_reason_mapset_not_removable(grassdb, location, mapset, check_permanent)
```

Get reason why one mapset cannot be removed.

Parameter *check_permanent* is True of False. It depends on whether
we want to check for permanent mapset or not.

Returns message as string if there was failed check, otherwise None.

##### grass.grassdb.checks.get_reasons_grassdb_not_removable

```python
get_reasons_grassdb_not_removable(grassdb)
```

Get reasons why one grassdb cannot be removed.

Returns messages as list if there were any failed checks, otherwise empty list.

##### grass.grassdb.checks.get_reasons_location_not_removable

```python
get_reasons_location_not_removable(grassdb, location)
```

Get reasons why one location cannot be removed.

Returns messages as list if there were any failed checks, otherwise empty list.

##### grass.grassdb.checks.get_reasons_locations_not_removable

```python
get_reasons_locations_not_removable(locations)
```

Get reasons why locations cannot be removed.

Parameter *locations* is a list of tuples (database, location).

Returns messages as list if there were any failed checks, otherwise empty list.

##### grass.grassdb.checks.get_reasons_mapsets_not_removable

```python
get_reasons_mapsets_not_removable(mapsets, check_permanent)
```

Get reasons why mapsets cannot be removed.

Parameter *mapsets* is a list of tuples (database, location, mapset).
Parameter *check_permanent* is True of False. It depends on whether
we want to check for permanent mapset or not.

Returns messages as list if there were any failed checks, otherwise empty list.

##### grass.grassdb.checks.is_current_user_mapset_owner

```python
is_current_user_mapset_owner(mapset_path)
```

Returns True if mapset owner is the current user.
On Windows it always returns True.

##### grass.grassdb.checks.is_different_mapset_owner

```python
is_different_mapset_owner(mapset_path)
```

Returns True if mapset owner is different from the current user

##### grass.grassdb.checks.is_fallback_session

```python
is_fallback_session()
```

Checks if a user encounters a fallback GRASS session.

Returns True if a user encounters a fallback session.
It occurs when a last mapset is not usable and at the same time
a user is in a temporary location.

##### grass.grassdb.checks.is_first_time_user

```python
is_first_time_user()
```

Check if a user is a first-time user.

Returns True if a user is a first-time user.
It occurs when a gisrc file has initial settings either in last used mapset
or in current mapset settings.

##### grass.grassdb.checks.is_location_current

```python
is_location_current(database, location)
```

Return True if the given GRASS Location is the current location

##### grass.grassdb.checks.is_location_name_valid

```python
is_location_name_valid(database, location_name)
```

Check if location name is valid.

Returns True if location name is valid, otherwise False.

##### grass.grassdb.checks.is_location_valid

```python
is_location_valid(path, location=None)
```

Return True if GRASS Location is valid

:param path: Path to a Location or to a GRASS GIS database directory
:param location: name of a Location if not part of *path*

##### grass.grassdb.checks.is_mapset_current

```python
is_mapset_current(database, location, mapset)
```

Return True if the given GRASS Mapset is the current mapset

##### grass.grassdb.checks.is_mapset_locked

```python
is_mapset_locked(mapset_path)
```

Check if the mapset is locked

##### grass.grassdb.checks.is_mapset_name_valid

```python
is_mapset_name_valid(database, location, mapset_name)
```

Check if mapset name is valid.

Returns True if mapset name is valid, otherwise False.

##### grass.grassdb.checks.is_mapset_valid

```python
is_mapset_valid(path, location=None, mapset=None)
```

Return True if GRASS Mapset is valid

Either only *path* is provided or all three parameters need to be provided.

:param path: Path to a Mapset or to a GRASS GIS database directory
:param location: name of a Location if not part of *path*
:param mapset: name of a Mapset if not part of *path*

##### grass.grassdb.checks.location_exists

```python
location_exists(path, location=None)
```

Returns True whether location path exists.

:param path: Path to a Location or to a GRASS GIS database directory
:param location: name of a Location if not part of *path*

##### grass.grassdb.checks.mapset_exists

```python
mapset_exists(path, location=None, mapset=None)
```

Returns True whether mapset path exists.

Either only *path* is provided or all three parameters need to be provided.

:param path: Path to a Mapset or to a GRASS GIS database directory
:param location: name of a Location if not part of *path*
:param mapset: name of a Mapset if not part of *path*

#### grass.grassdb.config

Set global variables for objects in a GRASS GIS Spatial Database

(C) 2020 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Linda Kladivova \<linda.kladivova seznam cz>

**Attributes:**

- [**default_location**](#grass.grassdb.config.default_location) –
- [**permanent_mapset**](#grass.grassdb.config.permanent_mapset) –
- [**temporary_location**](#grass.grassdb.config.temporary_location) –
- [**unknown_location**](#grass.grassdb.config.unknown_location) –
- [**unknown_mapset**](#grass.grassdb.config.unknown_mapset) –

##### grass.grassdb.config.default_location

```python
default_location = 'world_latlong_wgs84'
```

##### grass.grassdb.config.permanent_mapset

```python
permanent_mapset = 'PERMANENT'
```

##### grass.grassdb.config.temporary_location

```python
temporary_location = 'tmploc'
```

##### grass.grassdb.config.unknown_location

```python
unknown_location = '<UNKNOWN>'
```

##### grass.grassdb.config.unknown_mapset

```python
unknown_mapset = '<UNKNOWN>'
```

#### grass.grassdb.create

Create objects in GRASS GIS Spatial Database

(C) 2020 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>

**Functions:**

- [**create_mapset**](#grass.grassdb.create.create_mapset) – Creates a mapset in a specified location
- [**get_default_mapset_name**](#grass.grassdb.create.get_default_mapset_name) – Returns default name for mapset.

##### grass.grassdb.create.create_mapset

```python
create_mapset(database, location, mapset)
```

Creates a mapset in a specified location

##### grass.grassdb.create.get_default_mapset_name

```python
get_default_mapset_name()
```

Returns default name for mapset.

#### grass.grassdb.data

Manipulate data in mapsets in GRASS GIS Spatial Database

(C) 2020 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>

**Functions:**

- [**map_exists**](#grass.grassdb.data.map_exists) – Check is map is present in the mapset given in the environment

##### grass.grassdb.data.map_exists

```python
map_exists(name, element, mapset=None, env=None)
```

Check is map is present in the mapset given in the environment

:param name: Name of the map
:param element: Data type ('raster', 'raster_3d', and 'vector')
:param env: Environment created by function grass.script.create_environment
:param mapset: Mapset name, "." for current mapset only,
None for all mapsets in the search path

#### grass.grassdb.history

Managing existing history files included within mapset

(C) 2023 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Linda Karlovska (Kladivova) linda.karlovska@seznam.cz

**Classes:**

- [**Status**](#grass.grassdb.history.Status) – Enum representing a set of status constants

**Functions:**

- [**add_entry**](#grass.grassdb.history.add_entry) – Add entry to history file.
- [**convert_plain_text_to_JSON**](#grass.grassdb.history.convert_plain_text_to_JSON) – Convert plain text history log to JSON format.
- [**copy**](#grass.grassdb.history.copy) – Copy history file to the target location.
- [**ensure_history_file**](#grass.grassdb.history.ensure_history_file) – Set up a new GUI history file if it doesn't exist.
- [**filter**](#grass.grassdb.history.filter) – Filter JSON history file based on provided command and the time of command launch.
- [**get_current_mapset_gui_history_path**](#grass.grassdb.history.get_current_mapset_gui_history_path) – Return path to the current mapset history file.
- [**get_history_file_extension**](#grass.grassdb.history.get_history_file_extension) – Get extension of the history file.
- [**get_initial_command_info**](#grass.grassdb.history.get_initial_command_info) – Get information about the launched command.
- [**read**](#grass.grassdb.history.read) – Read the content of the history file.
- [**remove_entry**](#grass.grassdb.history.remove_entry) – Remove entry from history file.
- [**update_entry**](#grass.grassdb.history.update_entry) – Update entry in history file. If index is None it updates a last entry.

##### grass.grassdb.history.Status

Bases: <code>[Enum](#enum.Enum)</code>

Enum representing a set of status constants
that are used to represent various states or command outcomes.

**Attributes:**

- [**ABORTED**](#grass.grassdb.history.Status.ABORTED) –
- [**FAILED**](#grass.grassdb.history.Status.FAILED) –
- [**RUNNING**](#grass.grassdb.history.Status.RUNNING) –
- [**SUCCESS**](#grass.grassdb.history.Status.SUCCESS) –
- [**UNKNOWN**](#grass.grassdb.history.Status.UNKNOWN) –

###### grass.grassdb.history.Status.ABORTED

```python
ABORTED = 'aborted'
```

###### grass.grassdb.history.Status.FAILED

```python
FAILED = 'failed'
```

###### grass.grassdb.history.Status.RUNNING

```python
RUNNING = 'running'
```

###### grass.grassdb.history.Status.SUCCESS

```python
SUCCESS = 'success'
```

###### grass.grassdb.history.Status.UNKNOWN

```python
UNKNOWN = 'unknown'
```

##### grass.grassdb.history.add_entry

```python
add_entry(history_path, entry)
```

Add entry to history file.

:param str history_path: path to the history log file
:param dict entry: entry consisting of 'command' and 'command_info' keys

##### grass.grassdb.history.convert_plain_text_to_JSON

```python
convert_plain_text_to_JSON(history_path)
```

Convert plain text history log to JSON format.

:param str history_path: path to the history log file

##### grass.grassdb.history.copy

```python
copy(history_path, target_path)
```

Copy history file to the target location.

:param str history_path: path to the history log file
:param str target_path: target location for history log file
:return boolean: True if file is successfully copied

##### grass.grassdb.history.ensure_history_file

```python
ensure_history_file(history_path)
```

Set up a new GUI history file if it doesn't exist.

:param str history_path: path to the history file

##### grass.grassdb.history.filter

```python
filter(json_data, command, timestamp)
```

Filter JSON history file based on provided command and the time of command launch.

:param json_data: List of dictionaries representing JSON entries
:param command: First filtering argument representing command as string
:param timestamp: Second filtering argument representing the time of command launch
:return: Index of entry matching the filter criteria.

##### grass.grassdb.history.get_current_mapset_gui_history_path

```python
get_current_mapset_gui_history_path()
```

Return path to the current mapset history file.
This function does not ensure that the file exists.

##### grass.grassdb.history.get_history_file_extension

```python
get_history_file_extension(history_path)
```

Get extension of the history file.
The standard long-term format is plain text.
Newly it is stored as JSON-formatted.

:param str history_path: path to the history log file
:return str extension: None (plain text) or .json

##### grass.grassdb.history.get_initial_command_info

```python
get_initial_command_info(env_run)
```

Get information about the launched command.

:param env_run: environment needed for processing grass command
:return cmd_info dict: initial information about the launched command

##### grass.grassdb.history.read

```python
read(history_path)
```

Read the content of the history file.

:param str history_path: path to the history log file
:return content_list: list of dictionaries
with 'command' and 'command_info' keys

##### grass.grassdb.history.remove_entry

```python
remove_entry(history_path, index)
```

Remove entry from history file.

:param str history_path: path to the history log file
:param int index: index of the command to be removed

##### grass.grassdb.history.update_entry

```python
update_entry(history_path, command_info, index=None)
```

Update entry in history file. If index is None it updates a last entry.

:param str history_path: path to the history log file
:param dict command_info: command info entry for update
:param int|None index: index of the command to be updated

#### grass.grassdb.manage

Managing existing objects in a GRASS GIS Spatial Database

(C) 2020 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>

**Classes:**

- [**MapsetPath**](#grass.grassdb.manage.MapsetPath) – This is a representation of a path to mapset.

**Functions:**

- [**delete_grassdb**](#grass.grassdb.manage.delete_grassdb) – Deletes a specified GRASS database
- [**delete_location**](#grass.grassdb.manage.delete_location) – Deletes a specified location
- [**delete_mapset**](#grass.grassdb.manage.delete_mapset) – Deletes a specified mapset
- [**rename_location**](#grass.grassdb.manage.rename_location) – Rename location from *old_name* to *new_name*
- [**rename_mapset**](#grass.grassdb.manage.rename_mapset) – Rename mapset from *old_name* to *new_name*
- [**resolve_mapset_path**](#grass.grassdb.manage.resolve_mapset_path) – Resolve full path to mapset from given combination of parameters.
- [**split_mapset_path**](#grass.grassdb.manage.split_mapset_path) – Split mapset path to three parts - grassdb, location, mapset

##### grass.grassdb.manage.MapsetPath

```python
MapsetPath(path, directory, location, mapset)
```

This is a representation of a path to mapset.

Individual components are accessible through read-only properties
and objects have an os.PathLike interface.

Paths are currently stored as is (not resolved, not expanded),
but that may change in the future.

**Attributes:**

- [**directory**](#grass.grassdb.manage.MapsetPath.directory) – Location name
- [**location**](#grass.grassdb.manage.MapsetPath.location) – Location name
- [**mapset**](#grass.grassdb.manage.MapsetPath.mapset) – Mapset name
- [**path**](#grass.grassdb.manage.MapsetPath.path) – Full path to the mapset as a pathlib.Path object

###### grass.grassdb.manage.MapsetPath.directory

```python
directory
```

Location name

###### grass.grassdb.manage.MapsetPath.location

```python
location
```

Location name

###### grass.grassdb.manage.MapsetPath.mapset

```python
mapset
```

Mapset name

###### grass.grassdb.manage.MapsetPath.path

```python
path
```

Full path to the mapset as a pathlib.Path object

##### grass.grassdb.manage.delete_grassdb

```python
delete_grassdb(database)
```

Deletes a specified GRASS database

##### grass.grassdb.manage.delete_location

```python
delete_location(database, location)
```

Deletes a specified location

##### grass.grassdb.manage.delete_mapset

```python
delete_mapset(database, location, mapset)
```

Deletes a specified mapset

##### grass.grassdb.manage.rename_location

```python
rename_location(database, old_name, new_name)
```

Rename location from *old_name* to *new_name*

##### grass.grassdb.manage.rename_mapset

```python
rename_mapset(database, location, old_name, new_name)
```

Rename mapset from *old_name* to *new_name*

##### grass.grassdb.manage.resolve_mapset_path

```python
resolve_mapset_path(path, location=None, mapset=None)
```

Resolve full path to mapset from given combination of parameters.

Full or relative path to mapset can be provided as *path*. If the *path*
points to a valid location instead of a valid mapset, the mapset defaults
to PERMANENT.

Alternatively, location and mapset can be provided separately. In that case,
location and mapset are added to the path. If location is provided and mapset
is not, mapset defaults to PERMANENT.

Home represented by `~` (tilde) and relative paths are resolved
and the result contains absolute paths.

The function does not enforce the existence of the directory or that it
is a mapset. It only manipulates the paths except for internal checks
which help to determine the result in some cases. On Windows, if the path
does not exist and `..` is present in the path, it will be not be resolved
due to path resolution limitation in the Python pathlib package.

Returns a MapsetPath object.

##### grass.grassdb.manage.split_mapset_path

```python
split_mapset_path(mapset_path)
```

Split mapset path to three parts - grassdb, location, mapset

### grass.gunittest

GRASS Python testing framework module for running from command line

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras, Soeren Gebbert

Initial version of `gunittest` was created during Google Summer of Code 2014
by Vaclav Petras as a student and Soeren Gebbert as a mentor.

**Modules:**

- [**case**](#grass.gunittest.case) – GRASS Python testing framework test case
- [**checkers**](#grass.gunittest.checkers) – GRASS Python testing framework checkers
- [**gmodules**](#grass.gunittest.gmodules) – Specialized interfaces for invoking modules for testing framework
- [**gutils**](#grass.gunittest.gutils) – Utilities related to GRASS GIS for GRASS Python testing framework
- [**invoker**](#grass.gunittest.invoker) – GRASS Python testing framework test files invoker (runner)
- [**loader**](#grass.gunittest.loader) – GRASS Python testing framework test loading functionality
- [**main**](#grass.gunittest.main) – GRASS Python testing framework module for running from command line
- [**multireport**](#grass.gunittest.multireport) – Testing framework module for multi report
- [**multirunner**](#grass.gunittest.multirunner) – Testing framework module for running tests in Python unittest fashion
- [**reporters**](#grass.gunittest.reporters) – GRASS Python testing framework module for report generation
- [**runner**](#grass.gunittest.runner) – Testing framework module for running tests in Python unittest fashion
- [**utils**](#grass.gunittest.utils) – GRASS Python testing framework utilities (general and test-specific)

#### grass.gunittest.case

GRASS Python testing framework test case

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Classes:**

- [**TestCase**](#grass.gunittest.case.TestCase) – Always use keyword arguments for all parameters other than first two. For

##### grass.gunittest.case.TestCase

```python
TestCase(methodName)
```

Bases: <code>[TestCase](#unittest.TestCase)</code>

Always use keyword arguments for all parameters other than first two. For
the first two, it is recommended to use keyword arguments but not required.
Be especially careful and always use keyword argument syntax for *msg*
parameter.

**Functions:**

- [**assertFileExists**](#grass.gunittest.case.TestCase.assertFileExists) – Test the existence of a file.
- [**assertFileMd5**](#grass.gunittest.case.TestCase.assertFileMd5) – Test that file MD5 sum is equal to the provided sum.
- [**assertFilesEqualMd5**](#grass.gunittest.case.TestCase.assertFilesEqualMd5) – Test that files are the same using MD5 sum.
- [**assertLooksLike**](#grass.gunittest.case.TestCase.assertLooksLike) – Test that `actual` text is the same as `reference` with ellipses.
- [**assertModule**](#grass.gunittest.case.TestCase.assertModule) – Run PyGRASS module in controlled way and assert non-zero return code.
- [**assertModuleFail**](#grass.gunittest.case.TestCase.assertModuleFail) – Test that module fails with a non-zero return code.
- [**assertModuleKeyValue**](#grass.gunittest.case.TestCase.assertModuleKeyValue) – Test that output of a module is the same as provided subset.
- [**assertMultiLineEqual**](#grass.gunittest.case.TestCase.assertMultiLineEqual) – Test that the multiline string first is equal to the string second.
- [**assertRaster3dDoesNotExist**](#grass.gunittest.case.TestCase.assertRaster3dDoesNotExist) – Checks if the 3D raster map does not exist in current mapset
- [**assertRaster3dExists**](#grass.gunittest.case.TestCase.assertRaster3dExists) – Checks if the 3D raster map exists in current mapset
- [**assertRaster3dFitsInfo**](#grass.gunittest.case.TestCase.assertRaster3dFitsInfo) – Test that raster map has the values obtained by r3.info module.
- [**assertRaster3dFitsUnivar**](#grass.gunittest.case.TestCase.assertRaster3dFitsUnivar) – Test that 3D raster map has the values obtained by r3.univar module.
- [**assertRaster3dMinMax**](#grass.gunittest.case.TestCase.assertRaster3dMinMax) – Test that 3D raster map minimum and maximum are within limits.
- [**assertRasterDoesNotExist**](#grass.gunittest.case.TestCase.assertRasterDoesNotExist) – Checks if the raster map does not exist in current mapset
- [**assertRasterExists**](#grass.gunittest.case.TestCase.assertRasterExists) – Checks if the raster map exists in current mapset
- [**assertRasterFitsInfo**](#grass.gunittest.case.TestCase.assertRasterFitsInfo) – Test that raster map has the values obtained by r.info module.
- [**assertRasterFitsUnivar**](#grass.gunittest.case.TestCase.assertRasterFitsUnivar) – Test that raster map has the values obtained by r.univar module.
- [**assertRasterMinMax**](#grass.gunittest.case.TestCase.assertRasterMinMax) – Test that raster map minimum and maximum are within limits.
- [**assertRasters3dDifference**](#grass.gunittest.case.TestCase.assertRasters3dDifference) – Test statistical values of difference of reference and actual rasters
- [**assertRasters3dNoDifference**](#grass.gunittest.case.TestCase.assertRasters3dNoDifference) – Test that `actual` raster is not different from `reference` raster
- [**assertRastersDifference**](#grass.gunittest.case.TestCase.assertRastersDifference) – Test statistical values of difference of reference and actual rasters
- [**assertRastersEqual**](#grass.gunittest.case.TestCase.assertRastersEqual) – Test that `actual` raster is equal to `reference` raster
- [**assertRastersNoDifference**](#grass.gunittest.case.TestCase.assertRastersNoDifference) – Test that `actual` raster is not different from `reference` raster
- [**assertVectorAsciiEqualsVectorAscii**](#grass.gunittest.case.TestCase.assertVectorAsciiEqualsVectorAscii) – Test that two GRASS ASCII vector files are equal.
- [**assertVectorDoesNotExist**](#grass.gunittest.case.TestCase.assertVectorDoesNotExist) – Checks if the vector map does not exist in current mapset
- [**assertVectorEqualsAscii**](#grass.gunittest.case.TestCase.assertVectorEqualsAscii) – Test that vector is equal to the vector stored in GRASS ASCII file.
- [**assertVectorEqualsVector**](#grass.gunittest.case.TestCase.assertVectorEqualsVector) – Test that two vectors are equal.
- [**assertVectorExists**](#grass.gunittest.case.TestCase.assertVectorExists) – Checks if the vector map exists in current mapset
- [**assertVectorFitsExtendedInfo**](#grass.gunittest.case.TestCase.assertVectorFitsExtendedInfo) – Test that raster map has the values obtained by `v.info` module.
- [**assertVectorFitsRegionInfo**](#grass.gunittest.case.TestCase.assertVectorFitsRegionInfo) – Test that raster map has the values obtained by `v.info` module.
- [**assertVectorFitsTopoInfo**](#grass.gunittest.case.TestCase.assertVectorFitsTopoInfo) – Test that raster map has the values obtained by `v.info` module.
- [**assertVectorFitsUnivar**](#grass.gunittest.case.TestCase.assertVectorFitsUnivar) – Test that vector map has the values obtained by v.univar module.
- [**assertVectorInfoEqualsVectorInfo**](#grass.gunittest.case.TestCase.assertVectorInfoEqualsVectorInfo) – Test that two vectors are equal according to `v.info -tg`.
- [**assertVectorIsVectorBuffered**](#grass.gunittest.case.TestCase.assertVectorIsVectorBuffered) – This method should not be used to test v.buffer, v.overlay or v.select.
- [**assertVectorsNoAreaDifference**](#grass.gunittest.case.TestCase.assertVectorsNoAreaDifference) – Test statistical values of difference of reference and actual rasters
- [**del_temp_region**](#grass.gunittest.case.TestCase.del_temp_region) – Remove the temporary region.
- [**runModule**](#grass.gunittest.case.TestCase.runModule) – Run PyGRASS module.
- [**use_temp_region**](#grass.gunittest.case.TestCase.use_temp_region) – Use temporary region instead of the standard one for this process.

**Attributes:**

- [**grass_modules**](#grass.gunittest.case.TestCase.grass_modules) –
- [**html_reports**](#grass.gunittest.case.TestCase.html_reports) –
- [**longMessage**](#grass.gunittest.case.TestCase.longMessage) –
- [**maxDiff**](#grass.gunittest.case.TestCase.maxDiff) –
- [**readable_names**](#grass.gunittest.case.TestCase.readable_names) –
- [**supplementary_files**](#grass.gunittest.case.TestCase.supplementary_files) –

###### grass.gunittest.case.TestCase.assertFileExists

```python
assertFileExists(filename, msg=None, skip_size_check=False, skip_access_check=False)
```

Test the existence of a file.

.. note:
By default this also checks if the file size is greater than 0
since we rarely want a file to be empty. It also checks
if the file is accessible for reading since we expect that user
wants to look at created files.

###### grass.gunittest.case.TestCase.assertFileMd5

```python
assertFileMd5(filename, md5, text=False, msg=None)
```

Test that file MD5 sum is equal to the provided sum.

Usually, this function is used to test binary files or large text files
which cannot be tested in some other way. Text files can be usually
tested by some finer method.

To test text files with this function, you should always use parameter
*text* set to `True`. Note that function `checkers.text_file_md5()`
offers additional parameters which might be advantageous when testing
text files.

The typical workflow is that you create a file in a way you
trust (that you obtain the right file). Then you compute MD5
sum of the file. And provide the sum in a test as a string::

```
self.assertFileMd5("result.png", md5="807bba4ffa...")
```

Use `file_md5()` function from this package::

```
file_md5("original_result.png")
```

Or in command line, use `md5sum` command if available:

.. code-block:: sh

```
md5sum some_file.png
```

Finally, you can use Python `hashlib` to obtain MD5::

```
import hashlib

hasher = hashlib.md5()
# expecting the file to fit into memory
hasher.update(open("original_result.png", "rb").read())
hasher.hexdigest()
```

.. note:
For text files, always create MD5 sum using `\n` (LF)
as newline characters for consistency. Also use newline
at the end of file (as for example, Git or PEP8 requires).

###### grass.gunittest.case.TestCase.assertFilesEqualMd5

```python
assertFilesEqualMd5(filename, reference, msg=None)
```

Test that files are the same using MD5 sum.

This functions requires you to provide a file to test and
a reference file. For both, MD5 sum will be computed and compared with
each other.

###### grass.gunittest.case.TestCase.assertLooksLike

```python
assertLooksLike(actual, reference, msg=None)
```

Test that `actual` text is the same as `reference` with ellipses.

If `actual` contains platform dependent newline characters,
these will replaced by `\n` which is expected to be in the test data.

See :func:`check_text_ellipsis` for details of behavior.

###### grass.gunittest.case.TestCase.assertModule

```python
assertModule(module, msg=None, **kwargs)
```

Run PyGRASS module in controlled way and assert non-zero return code.

You should use this method to invoke module you are testing.
By using this method, you give testing framework more control over
the execution, error handling and storing of output.

It will not print module stdout and stderr, instead it will always
store them for further examination. Streams are stored separately.

This method is not suitable for testing error states of the module.
If you want to test behavior which involves non-zero return codes
and examine stderr in test, use `assertModuleFail()` method.

Runs the module and causes test failure if module ends with
non-zero return code.

###### grass.gunittest.case.TestCase.assertModuleFail

```python
assertModuleFail(module, msg=None, **kwargs)
```

Test that module fails with a non-zero return code.

Works like `assertModule()` but expects module to fail.

###### grass.gunittest.case.TestCase.assertModuleKeyValue

```python
assertModuleKeyValue(module, reference, sep, precision, msg=None, **parameters)
```

Test that output of a module is the same as provided subset.

::

```
self.assertModuleKeyValue(
    "r.info",
    map="elevation",
    flags="gr",
    reference=dict(min=55.58, max=156.33),
    precision=0.01,
    sep="=",
)
```

::

```
module = SimpleModule("r.info", map="elevation", flags="gr")
self.assertModuleKeyValue(
    module, reference=dict(min=55.58, max=156.33), precision=0.01, sep="="
)
```

The output of the module should be key-value pairs (shell script style)
which is typically obtained using `-g` flag.

###### grass.gunittest.case.TestCase.assertMultiLineEqual

```python
assertMultiLineEqual(first, second, msg=None)
```

Test that the multiline string first is equal to the string second.

When not equal a diff of the two strings highlighting the differences
will be included in the error message. This method is used by default
when comparing strings with assertEqual().

This method replaces platform dependent newline characters
by `\n` (LF) in both parameters. This is
different from the same method implemented in Python `unittest`
package which preserves the original newline characters.

This function removes the burden of getting the newline characters
right on each platform. You can just use `\n` everywhere and this
function will ensure that it does not matter if for example,
a module generates (as expected) `\r\n` (CRLF) newline characters
on MS Windows.

.. warning::
If you need to test the actual newline characters, use the standard
string comparison and functions such as `find()`.

###### grass.gunittest.case.TestCase.assertRaster3dDoesNotExist

```python
assertRaster3dDoesNotExist(name, msg=None)
```

Checks if the 3D raster map does not exist in current mapset

###### grass.gunittest.case.TestCase.assertRaster3dExists

```python
assertRaster3dExists(name, msg=None)
```

Checks if the 3D raster map exists in current mapset

###### grass.gunittest.case.TestCase.assertRaster3dFitsInfo

```python
assertRaster3dFitsInfo(raster, reference, precision=None, msg=None)
```

Test that raster map has the values obtained by r3.info module.

The function does not require all values from r3.info.
Only the provided values are tested.

Use keyword arguments syntax for all function parameters.

This function supports values obtained by -g (info) and -r (range).

###### grass.gunittest.case.TestCase.assertRaster3dFitsUnivar

```python
assertRaster3dFitsUnivar(raster, reference, precision=None, msg=None)
```

Test that 3D raster map has the values obtained by r3.univar module.

The function does not require all values from r3.univar.
Only the provided values are tested.

Use keyword arguments syntax for all function parameters.

Function does not use -e (extended statistics) flag,
use `assertModuleKeyValue()` for the full interface of arbitrary
module.

###### grass.gunittest.case.TestCase.assertRaster3dMinMax

```python
assertRaster3dMinMax(map, refmin, refmax, msg=None)
```

Test that 3D raster map minimum and maximum are within limits.

Minimum and maximum values are obtained from r3.info.
Map minimum and maximum is tested against expression::

```
refmin <= actualmin and refmax >= actualmax
```

Use keyword arguments syntax for all function parameters.

To check that more statistics have certain values use
`assertRaster3DFitsUnivar()` or `assertRaster3DFitsInfo()`

###### grass.gunittest.case.TestCase.assertRasterDoesNotExist

```python
assertRasterDoesNotExist(name, msg=None)
```

Checks if the raster map does not exist in current mapset

###### grass.gunittest.case.TestCase.assertRasterExists

```python
assertRasterExists(name, msg=None)
```

Checks if the raster map exists in current mapset

###### grass.gunittest.case.TestCase.assertRasterFitsInfo

```python
assertRasterFitsInfo(raster, reference, precision=None, msg=None)
```

Test that raster map has the values obtained by r.info module.

The function does not require all values from r.info.
Only the provided values are tested.
Typical example is checking minimum, maximum and type of the map::

```
minmax = "min=0\nmax=1451\ndatatype=FCELL"
self.assertRasterFitsInfo(raster="elevation", reference=minmax)
```

Use keyword arguments syntax for all function parameters.

This function supports values obtained -r (range) and
-e (extended metadata) flags.

###### grass.gunittest.case.TestCase.assertRasterFitsUnivar

```python
assertRasterFitsUnivar(raster, reference, precision=None, msg=None)
```

Test that raster map has the values obtained by r.univar module.

The function does not require all values from r.univar.
Only the provided values are tested.
Typical example is checking minimum, maximum and number of NULL cells
in the map::

```
values = "null_cells=0\nmin=55.5787925720215\nmax=156.329864501953"
self.assertRasterFitsUnivar(raster="elevation", reference=values)
```

Use keyword arguments syntax for all function parameters.

Does not -e (extended statistics) flag, use `assertModuleKeyValue()`
for the full interface of arbitrary module.

###### grass.gunittest.case.TestCase.assertRasterMinMax

```python
assertRasterMinMax(map, refmin, refmax, msg=None)
```

Test that raster map minimum and maximum are within limits.

Minimum and maximum values are obtained from r.info.
Map minimum and maximum is tested against expression::

```
refmin <= actualmin and refmax >= actualmax
```

Use keyword arguments syntax for all function parameters.

To check that more statistics have certain values use
`assertRasterFitsUnivar()` or `assertRasterFitsInfo()`

###### grass.gunittest.case.TestCase.assertRasters3dDifference

```python
assertRasters3dDifference(actual, reference, statistics, precision, msg=None)
```

Test statistical values of difference of reference and actual rasters

For cases when you are interested in no or minimal difference,
use `assertRastersNoDifference()` instead.

This method should not be used to test r3.mapcalc or r3.univar.

###### grass.gunittest.case.TestCase.assertRasters3dNoDifference

```python
assertRasters3dNoDifference(actual, reference, precision, statistics=None, msg=None)
```

Test that `actual` raster is not different from `reference` raster

Method behaves in the same way as `assertRasterFitsUnivar()`
but works on difference `reference - actual`.
If statistics is not given `dict(min=-precision, max=precision)`
is used.

###### grass.gunittest.case.TestCase.assertRastersDifference

```python
assertRastersDifference(actual, reference, statistics, precision, msg=None)
```

Test statistical values of difference of reference and actual rasters

For cases when you are interested in no or minimal difference,
use `assertRastersNoDifference()` instead.

This method should not be used to test r.mapcalc or r.univar.

Beware - comparison is performed on overall statistics and thus
differences in individual cell values not changing overall
statistics might go unnoticed. Use `assertRastersEqual()`
for cell to cell equivalence testing.

###### grass.gunittest.case.TestCase.assertRastersEqual

```python
assertRastersEqual(actual, reference, precision=0, msg=None)
```

Test that `actual` raster is equal to `reference` raster

Test compares if each cell value in `actual` raster is within
`precision` value to `reference` raster.
NULL values in both rasters are considered to be a match.

For CELL maps `precision` should be set to 0,
for FCELL and DCELL maps it should be set to match precision of
`reference` map (a positive number larger than 0).

Comparison is performed with r.mapcalc and r.info and thus is
affected by current computational region.

###### grass.gunittest.case.TestCase.assertRastersNoDifference

```python
assertRastersNoDifference(actual, reference, precision, statistics=None, msg=None)
```

Test that `actual` raster is not different from `reference` raster

Method behaves in the same way as `assertRasterFitsUnivar()`
but works on difference `reference - actual`.
If statistics is not given `dict(min=-precision, max=precision)`
is used.

Beware - comparison is performed on overall statistics and thus
differences in individual cell values not changing overall
statistics might go unnoticed. Use `assertRastersEqual()`
for cell to cell equivalence testing.

###### grass.gunittest.case.TestCase.assertVectorAsciiEqualsVectorAscii

```python
assertVectorAsciiEqualsVectorAscii(actual, reference, remove_files=False, msg=None)
```

Test that two GRASS ASCII vector files are equal.

.. note:
This test should not be used to test `v.in.ascii` and
`v.out.ascii` modules.

.. warning:
ASCII files for vectors are loaded into memory, so this
function works well only for "not too big" vector maps.

###### grass.gunittest.case.TestCase.assertVectorDoesNotExist

```python
assertVectorDoesNotExist(name, msg=None)
```

Checks if the vector map does not exist in current mapset

###### grass.gunittest.case.TestCase.assertVectorEqualsAscii

```python
assertVectorEqualsAscii(actual, reference, digits, precision, msg=None)
```

Test that vector is equal to the vector stored in GRASS ASCII file.

.. note:
This test should not be used to test `v.in.ascii` and
`v.out.ascii` modules.

.. warning:
ASCII files for vectors are loaded into memory, so this
function works well only for "not too big" vector maps.

###### grass.gunittest.case.TestCase.assertVectorEqualsVector

```python
assertVectorEqualsVector(actual, reference, digits, precision, msg=None)
```

Test that two vectors are equal.

.. note:
This test should not be used to test `v.in.ascii` and
`v.out.ascii` modules.

.. warning:
ASCII files for vectors are loaded into memory, so this
function works well only for "not too big" vector maps.

###### grass.gunittest.case.TestCase.assertVectorExists

```python
assertVectorExists(name, msg=None)
```

Checks if the vector map exists in current mapset

###### grass.gunittest.case.TestCase.assertVectorFitsExtendedInfo

```python
assertVectorFitsExtendedInfo(vector, reference, msg=None)
```

Test that raster map has the values obtained by `v.info` module.

This function uses `-e` flag of `v.info` module to get topology
info, so the reference dictionary should contain appropriate set or
subset of values (only the provided values are tested).

The most useful items for testing (considering circumstances of test
invocation) are name, title, level and num_dblinks. (When testing
storing of `v.info -e` metadata, the selection might be different.)

No precision is applied (no difference is required). So, this function
is not suitable for testing items which are floating point number.

Use keyword arguments syntax for all function parameters.

###### grass.gunittest.case.TestCase.assertVectorFitsRegionInfo

```python
assertVectorFitsRegionInfo(vector, reference, precision, msg=None)
```

Test that raster map has the values obtained by `v.info` module.

This function uses `-g` flag of `v.info` module to get topology
info, so the reference dictionary should contain appropriate set or
subset of values (only the provided values are tested).

Use keyword arguments syntax for all function parameters.

###### grass.gunittest.case.TestCase.assertVectorFitsTopoInfo

```python
assertVectorFitsTopoInfo(vector, reference, msg=None)
```

Test that raster map has the values obtained by `v.info` module.

This function uses `-t` flag of `v.info` module to get topology
info, so the reference dictionary should contain appropriate set or
subset of values (only the provided values are tested).

A example of checking number of points::

```
topology = dict(points=10938, primitives=10938)
self.assertVectorFitsTopoInfo(vector="bridges", reference=topology)
```

Note that here we are checking also the number of primitives to prove
that there are no other features besides points.

No precision is applied (no difference is required). So, this function
is not suitable for testing items which are floating point number
(no such items are currently in topological information).

Use keyword arguments syntax for all function parameters.

###### grass.gunittest.case.TestCase.assertVectorFitsUnivar

```python
assertVectorFitsUnivar(map, column, reference, msg=None, layer=None, type=None, where=None, precision=None)
```

Test that vector map has the values obtained by v.univar module.

The function does not require all values from v.univar.
Only the provided values are tested.
Typical example is checking minimum and maximum of a column::

```
minmax = "min=0\nmax=1451"
self.assertVectorFitsUnivar(map="bridges", column="WIDTH", reference=minmax)
```

Use keyword arguments syntax for all function parameters.

Does not support -d (geometry distances) flag, -e (extended statistics)
flag and few other, use `assertModuleKeyValue` for the full interface
of arbitrary module.

###### grass.gunittest.case.TestCase.assertVectorInfoEqualsVectorInfo

```python
assertVectorInfoEqualsVectorInfo(actual, reference, precision, msg=None)
```

Test that two vectors are equal according to `v.info -tg`.

This function does not test geometry itself just the region of the
vector map and number of features.

###### grass.gunittest.case.TestCase.assertVectorIsVectorBuffered

```python
assertVectorIsVectorBuffered(actual, reference, precision, msg=None)
```

This method should not be used to test v.buffer, v.overlay or v.select.

###### grass.gunittest.case.TestCase.assertVectorsNoAreaDifference

```python
assertVectorsNoAreaDifference(actual, reference, precision, layer=1, msg=None)
```

Test statistical values of difference of reference and actual rasters

Works only for areas.

Use keyword arguments syntax for all function parameters.

This method should not be used to test v.overlay or v.select.

###### grass.gunittest.case.TestCase.del_temp_region

```python
del_temp_region()
```

Remove the temporary region.

Unsets `WIND_OVERRIDE` and removes any region named by it.

###### grass.gunittest.case.TestCase.grass_modules

```python
grass_modules = []
```

###### grass.gunittest.case.TestCase.html_reports

```python
html_reports = False
```

###### grass.gunittest.case.TestCase.longMessage

```python
longMessage = True
```

###### grass.gunittest.case.TestCase.maxDiff

```python
maxDiff = None
```

###### grass.gunittest.case.TestCase.readable_names

```python
readable_names = False
```

###### grass.gunittest.case.TestCase.runModule

```python
runModule(module, expecting_stdout=False, **kwargs)
```

Run PyGRASS module.

Runs the module and raises an exception if the module ends with
non-zero return code. Usually, this is the same as testing the
return code and raising exception but by using this method,
you give testing framework more control over the execution,
error handling and storing of output.

In terms of testing framework, this function causes a common error,
not a test failure.

:raises CalledModuleError: if the module failed

###### grass.gunittest.case.TestCase.supplementary_files

```python
supplementary_files = []
```

###### grass.gunittest.case.TestCase.use_temp_region

```python
use_temp_region()
```

Use temporary region instead of the standard one for this process.

If you use this method, you have to call it in `setUpClass()`
and call `del_temp_region()` in `tearDownClass()`. By this you
ensure that each test method will have its own region and will
not influence other classes.

::

```
@classmethod
def setUpClass(self):
    self.use_temp_region()


@classmethod
def tearDownClass(self):
    self.del_temp_region()
```

You can also call the methods in `setUp()` and `tearDown()` if
you are using them.

Copies the current region to a temporary region with
`g.region save=`, then sets `WIND_OVERRIDE` to refer
to that region.

#### grass.gunittest.checkers

GRASS Python testing framework checkers

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras, Soeren Gebbert

**Functions:**

- [**check_text_ellipsis**](#grass.gunittest.checkers.check_text_ellipsis) – Check if actual text matches reference text with ellipsis as wildcards.
- [**check_text_ellipsis_doctest**](#grass.gunittest.checkers.check_text_ellipsis_doctest) – Check if actual text matches reference with ellipsis using doctest's matching.
- [**diff_keyvalue**](#grass.gunittest.checkers.diff_keyvalue) – Determine the difference of two dictionaries.
- [**file_md5**](#grass.gunittest.checkers.file_md5) – Get MD5 (check) sum of a file.
- [**files_equal_md5**](#grass.gunittest.checkers.files_equal_md5) – Check equality of two files according to their MD5 sums
- [**keyvalue_equals**](#grass.gunittest.checkers.keyvalue_equals) – Compare two dictionaries.
- [**main**](#grass.gunittest.checkers.main) – Run the doctest
- [**proj_info_equals**](#grass.gunittest.checkers.proj_info_equals) – Test if two PROJ_INFO texts are equal.
- [**proj_units_equals**](#grass.gunittest.checkers.proj_units_equals) – Test if two PROJ_UNITS texts are equal.
- [**text_file_md5**](#grass.gunittest.checkers.text_file_md5) – Get a MD5 (check) sum of a text file.
- [**text_to_keyvalue**](#grass.gunittest.checkers.text_to_keyvalue) – Convert test to key-value pairs (dictionary-like KeyValue object).
- [**unify_projection**](#grass.gunittest.checkers.unify_projection) – Unifies names of projections.
- [**unify_units**](#grass.gunittest.checkers.unify_units) – Unifies names of units.
- [**value_from_string**](#grass.gunittest.checkers.value_from_string) – Create value of a most fitting type from a string.
- [**values_equal**](#grass.gunittest.checkers.values_equal) – Compare two values for equality within a given precision.

##### grass.gunittest.checkers.check_text_ellipsis

```python
check_text_ellipsis(reference, actual)
```

Check if actual text matches reference text with ellipsis as wildcards.

> > > check_text_ellipsis(
> > > ... "Vector map \<...> contains ... points.",
> > > ... "Vector map <bridges> contains 5268 points.",
> > > ... )
> > > True
> > > check_text_ellipsis(
> > > ... "user: ...\\nname: elevation", "user: some_user\\nname: elevation"
> > > ... )
> > > True
> > > check_text_ellipsis("user: ...\\nname: elevation", "user: \\nname: elevation")
> > > False

The ellipsis is always considered even if it is followed by another
dots. Consequently, a dot at the end of the sentence with preceding
ellipsis will work as well as a line filled with undefined number of dots.

> > > check_text_ellipsis("The result is ....", "The result is 25.")
> > > True
> > > check_text_ellipsis("max ..... ...", "max ....... 6")
> > > True

However, there is no way how to express that the dot should be in the
beginning and the ellipsis is at the end of the group of dots.

> > > check_text_ellipsis("The result is ....", "The result is .25")
> > > False

The matching goes over lines (TODO: should this be changed?):

> > > check_text_ellipsis("a=11\\nb=...", "a=11\\nb=22\\n")
> > > True

This function is based on regular expression containing .+ but no other
regular expression matching will be done.

> > > check_text_ellipsis("Result: [569] (...)", "Result: 9 (too high)")
> > > False

##### grass.gunittest.checkers.check_text_ellipsis_doctest

```python
check_text_ellipsis_doctest(reference, actual)
```

Check if actual text matches reference with ellipsis using doctest's matching.

> > > check_text_ellipsis_doctest(
> > > ... "user: ...\\nname: elevation", "user: some_user\\nname: elevation"
> > > ... )
> > > True
> > > check_text_ellipsis_doctest(
> > > ... "user: ...\\nname: elevation", "user: \\nname: elevation"
> > > ... )
> > > True

This function is using doctest's function to check the result, so we
will discuss here how the underlying function behaves.

> > > checker = doctest.OutputChecker()
> > > checker.check_output(
> > > ... "user: some_user\\nname: elevation",
> > > ... "user: some_user\\nname: elevation",
> > > ... optionflags=None,
> > > ... )
> > > True
> > > checker.check_output(
> > > ... "user: user1\\nname: elevation",
> > > ... "user: some_user\\nname: elevation",
> > > ... optionflags=doctest.ELLIPSIS,
> > > ... )
> > > False
> > > checker.check_output(
> > > ... "user: ...\\nname: elevation",
> > > ... "user: some_user\\nname: elevation",
> > > ... optionflags=doctest.ELLIPSIS,
> > > ... )
> > > True

The ellipsis matches also an empty string, so the following matches:

> > > checker.check_output(
> > > ... "user: ...\\nname: elevation",
> > > ... "user: \\nname: elevation",
> > > ... optionflags=doctest.ELLIPSIS,
> > > ... )
> > > True

It is robust concerning misspelled matching string but does not allow
ellipsis followed by a dot, e.g. at the end of the sentence:

> > > checker.check_output(
> > > ... "user: ....\\nname: elevation",
> > > ... "user: some_user\\nname: elevation",
> > > ... optionflags=doctest.ELLIPSIS,
> > > ... )
> > > False

##### grass.gunittest.checkers.diff_keyvalue

```python
diff_keyvalue(dict_a, dict_b, precision, def_equal=values_equal, key_equal=None, a_is_subset=False)
```

Determine the difference of two dictionaries.

The function returns missing keys and different values for common keys::

```
>>> a = {"c": 2, "b": 3, "a": 4}
>>> b = {"c": 1, "b": 3, "d": 5}
>>> diff_keyvalue(a, b, precision=0)
(['d'], ['a'], [('c', 2, 1)])
```

You can provide only a subset of values in dict_a, in this case
first item in tuple is an empty list::

```
>>> diff_keyvalue(a, b, a_is_subset=True, precision=0)
([], ['a'], [('c', 2, 1)])
```

This function behaves the same as `keyvalue_equals()`.

:returns: A tuple of lists, fist is list of missing keys in dict_a,
second missing keys in dict_b and third is a list of mismatched
values as tuples (key, value_from_a, value_from_b)
:rtype: (list, list, list)

Comparing to the Python `difflib` package this function does not create
any difference output. It just returns the dictionaries.
Comparing to the Python `unittest` `assertDictEqual()`,
this function does not issues error or exception, it just determines
what it the difference.

##### grass.gunittest.checkers.file_md5

```python
file_md5(filename)
```

Get MD5 (check) sum of a file.

##### grass.gunittest.checkers.files_equal_md5

```python
files_equal_md5(filename_a, filename_b)
```

Check equality of two files according to their MD5 sums

##### grass.gunittest.checkers.keyvalue_equals

```python
keyvalue_equals(dict_a, dict_b, precision, def_equal=values_equal, key_equal=None, a_is_subset=False)
```

Compare two dictionaries.

.. note::
Always use keyword arguments for all parameters with defaults.
It is a good idea to use keyword arguments also for the first
two parameters.

An example of key-value texts comparison::

```
>>> keyvalue_equals(
...     text_to_keyvalue(
...         '''a: Hello
... b: 1.0
... c: 1,2,3,4,5
... d: hello,8,0.1'''
...     ),
...     text_to_keyvalue(
...         '''a: Hello
... b: 1.1
... c: 1,22,3,4,5
... d: hello,8,0.1'''
...     ),
...     precision=0.1,
... )
False
```

:param dict_a: first dictionary
:param dict_b: second dictionary
:param precision: precision with which the floating point values
are compared (passed to equality functions)
:param def_equal: function used for comparison by default
:param key_equal: dictionary of functions used for comparison
of specific keys, `def_equal` is used for the rest,
keys in dictionary are keys in `dict_a` and `dict_b` dictionaries,
values are the functions used to compare the given key
:param a_is_subset: `True` if `dict_a` is a subset of `dict_b`,
`False` otherwise

:return: `True` if identical, `False` if different

Use `diff_keyvalue()` to get information about differences.
You can use this function to find out if there is a difference and then
use `diff_keyvalue()` to determine all the differences between
dictionaries.

##### grass.gunittest.checkers.main

```python
main()
```

Run the doctest

##### grass.gunittest.checkers.proj_info_equals

```python
proj_info_equals(text_a, text_b)
```

Test if two PROJ_INFO texts are equal.

##### grass.gunittest.checkers.proj_units_equals

```python
proj_units_equals(text_a, text_b)
```

Test if two PROJ_UNITS texts are equal.

##### grass.gunittest.checkers.text_file_md5

```python
text_file_md5(filename, exclude_lines=None, exclude_re=None, prepend_lines=None, append_lines=None)
```

Get a MD5 (check) sum of a text file.

Works in the same way as `file_md5()` function but ignores newlines
characters and excludes lines from the file as well as prepend or
append them if requested.

:param exclude_lines: list of strings to be excluded
(newline characters should not be part of the strings)
:param exclude_re: regular expression string;
lines matching this regular expression will not be considered
:param prepend_lines: list of lines to be prepended to the file
before computing the sum
:param append_lines: list of lines to be appended to the file
before computing the sum

##### grass.gunittest.checkers.text_to_keyvalue

```python
text_to_keyvalue(text, sep=':', val_sep=',', functions=None, skip_invalid=False, skip_empty=False, from_string=value_from_string)
```

Convert test to key-value pairs (dictionary-like KeyValue object).

Converts a key-value text file, where entries are separated
by newlines and the key and value are separated by `sep`,
into a key-value dictionary and discovers/uses the correct
data types (float, int or string) for values.

Besides key-value pairs it also parses values itself. Value is created
with the best fitting type using `value_from_string()` function by default.
When val_sep is present in value part, the resulting value is
a list of values.

:param text: string to convert
:param sep: character that separates the keys and values
:param val_sep: character that separates the values of a single key
:param functions: list of functions to apply on the resulting dictionary
:param skip_invalid: skip all lines which does not contain separator
:param skip_empty: skip empty lines
:param from_string: a function used to convert strings to values,
use `lambda x: x` for no conversion

:return: a dictionary representation of text
:return type: grass.script.core.KeyValue or dict

And example of converting text with text, floats, integers and list
to a dictionary::

```
>>> sorted(
...     text_to_keyvalue(
...         '''a: Hello
... b: 1.0
... c: 1,2,3,4,5
... d : hello,8,0.1'''
...     ).items()
... )  # sorted items from the dictionary
[('a', 'Hello'), ('b', 1.0), ('c', [1, 2, 3, 4, 5]), ('d', ['hello', 8, 0.1])]
```

.. warning::
And empty string is a valid input because empty dictionary is a valid
dictionary. You need to test this separately according
to the circumstances.

##### grass.gunittest.checkers.unify_projection

```python
unify_projection(dic)
```

Unifies names of projections.

Some projections are referred using different names like
'Universal Transverse Mercator' and 'Universe Transverse Mercator'.
This function replaces synonyms by a unified name.

Example of common typo in UTM replaced by correct spelling::

```
>>> unify_projection({"name": ["Universe Transverse Mercator"]})
{'name': ['Universal Transverse Mercator']}
```

:param dic: The dictionary containing information about projection

:return: The dictionary with the new values if needed or a copy of old one

##### grass.gunittest.checkers.unify_units

```python
unify_units(dic)
```

Unifies names of units.

Some units have different spelling although they are the same units.
This functions replaces different spelling options by unified one.

Example of British English spelling replaced by US English spelling::

```
>>> unify_units({"units": ["metres"], "unit": ["metre"]})  # doctest: +SKIP
{'units': ['meters'], 'unit': ['meter']}
```

:param dic: The dictionary containing information about units

:return: The dictionary with the new values if needed or a copy of old one

##### grass.gunittest.checkers.value_from_string

```python
value_from_string(value)
```

Create value of a most fitting type from a string.

Type conversions are applied in order `int`, `float`, `string`
where string is no conversion.

> > > value_from_string("1")
> > > 1
> > > value_from_string("5.6")
> > > 5.6
> > > value_from_string(" 5.6 ")
> > > 5.6
> > > value_from_string("hello")
> > > 'hello'

##### grass.gunittest.checkers.values_equal

```python
values_equal(value_a, value_b, precision=1e-06)
```

Compare two values for equality within a given precision.

> > > values_equal(1.022, 1.02, precision=0.01)
> > > True
> > > values_equal([1.2, 5.3, 6.8], [1.1, 5.2, 6.9], precision=0.2)
> > > True
> > > values_equal(7, 5, precision=2)
> > > True
> > > values_equal(1, 5.9, precision=10)
> > > True
> > > values_equal("Hello", "hello")
> > > False

#### grass.gunittest.gmodules

Specialized interfaces for invoking modules for testing framework

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras, Soeren Gebbert

**Classes:**

- [**SimpleModule**](#grass.gunittest.gmodules.SimpleModule) – Simple wrapper around pygrass.modules.Module to make sure that

**Functions:**

- [**call_module**](#grass.gunittest.gmodules.call_module) – Run module with parameters given in `kwargs` and return its output.

##### grass.gunittest.gmodules.SimpleModule

```python
SimpleModule(cmd, *args, **kargs)
```

Bases: <code>[Module](#grass.pygrass.modules.Module)</code>

Simple wrapper around pygrass.modules.Module to make sure that
run\_, finish\_, stdout and stderr are set correctly.

> > > mapcalc = SimpleModule("r.mapcalc", expression="test_a = 1", overwrite=True)
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > mapcalc.returncode
> > > 0

> > > colors = SimpleModule("r.colors", map="test_a", rules="-", stdin\_="1 red")
> > > colors.run()
> > > Module('r.colors')
> > > colors.returncode
> > > 0
> > > str(colors.inputs.stdin)
> > > '1 red'
> > > str(colors.outputs.stdout)
> > > ''
> > > colors.outputs.stderr.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

**Functions:**

- [**check**](#grass.gunittest.gmodules.SimpleModule.check) – Check the correctness of the provide parameters
- [**get_bash**](#grass.gunittest.gmodules.SimpleModule.get_bash) – Return a BASH representation of the Module.
- [**get_dict**](#grass.gunittest.gmodules.SimpleModule.get_dict) – Return a dictionary that includes the name, all valid
- [**get_python**](#grass.gunittest.gmodules.SimpleModule.get_python) – Return a Python representation of the Module.
- [**make_cmd**](#grass.gunittest.gmodules.SimpleModule.make_cmd) – Create the command string that can be executed in a shell
- [**run**](#grass.gunittest.gmodules.SimpleModule.run) – Run the module
- [**update**](#grass.gunittest.gmodules.SimpleModule.update) – Update module parameters and selected object attributes.
- [**wait**](#grass.gunittest.gmodules.SimpleModule.wait) – Wait for the module to finish. Call this method if

**Attributes:**

- [**check\_**](#grass.gunittest.gmodules.SimpleModule.check_) –
- [**env\_**](#grass.gunittest.gmodules.SimpleModule.env_) –
- [**finish\_**](#grass.gunittest.gmodules.SimpleModule.finish_) –
- [**flags**](#grass.gunittest.gmodules.SimpleModule.flags) –
- [**inputs**](#grass.gunittest.gmodules.SimpleModule.inputs) –
- [**name**](#grass.gunittest.gmodules.SimpleModule.name) –
- [**outputs**](#grass.gunittest.gmodules.SimpleModule.outputs) –
- [**params_list**](#grass.gunittest.gmodules.SimpleModule.params_list) –
- [**required**](#grass.gunittest.gmodules.SimpleModule.required) –
- [**returncode**](#grass.gunittest.gmodules.SimpleModule.returncode) –
- [**run\_**](#grass.gunittest.gmodules.SimpleModule.run_) –
- [**start_time**](#grass.gunittest.gmodules.SimpleModule.start_time) –
- [**stderr\_**](#grass.gunittest.gmodules.SimpleModule.stderr_) –
- [**stdin**](#grass.gunittest.gmodules.SimpleModule.stdin) –
- [**stdin\_**](#grass.gunittest.gmodules.SimpleModule.stdin_) –
- [**stdout\_**](#grass.gunittest.gmodules.SimpleModule.stdout_) –
- [**time**](#grass.gunittest.gmodules.SimpleModule.time) –
- [**xml**](#grass.gunittest.gmodules.SimpleModule.xml) –

###### grass.gunittest.gmodules.SimpleModule.check

```python
check()
```

Check the correctness of the provide parameters

###### grass.gunittest.gmodules.SimpleModule.check\_

```python
check_ = True
```

###### grass.gunittest.gmodules.SimpleModule.env\_

```python
env_ = None
```

###### grass.gunittest.gmodules.SimpleModule.finish\_

```python
finish_ = True
```

###### grass.gunittest.gmodules.SimpleModule.flags

```python
flags = TypeDict(Flag)
```

###### grass.gunittest.gmodules.SimpleModule.get_bash

```python
get_bash()
```

Return a BASH representation of the Module.

###### grass.gunittest.gmodules.SimpleModule.get_dict

```python
get_dict()
```

Return a dictionary that includes the name, all valid
inputs, outputs and flags

###### grass.gunittest.gmodules.SimpleModule.get_python

```python
get_python()
```

Return a Python representation of the Module.

###### grass.gunittest.gmodules.SimpleModule.inputs

```python
inputs = TypeDict(Parameter)
```

###### grass.gunittest.gmodules.SimpleModule.make_cmd

```python
make_cmd()
```

Create the command string that can be executed in a shell

:returns: the command string

###### grass.gunittest.gmodules.SimpleModule.name

```python
name = cmd
```

###### grass.gunittest.gmodules.SimpleModule.outputs

```python
outputs = TypeDict(Parameter)
```

###### grass.gunittest.gmodules.SimpleModule.params_list

```python
params_list = [Parameter(p) for p in tree.findall('parameter')]
```

###### grass.gunittest.gmodules.SimpleModule.required

```python
required = []
```

###### grass.gunittest.gmodules.SimpleModule.returncode

```python
returncode = None
```

###### grass.gunittest.gmodules.SimpleModule.run

```python
run()
```

Run the module
This function will wait for the process to terminate in case
finish\_==True and sets up stdout and stderr. If finish\_==False this
function will return after starting the process. Use wait() to wait for
the started process

:return: A reference to this object

###### grass.gunittest.gmodules.SimpleModule.run\_

```python
run_ = True
```

###### grass.gunittest.gmodules.SimpleModule.start_time

```python
start_time = None
```

###### grass.gunittest.gmodules.SimpleModule.stderr\_

```python
stderr_ = None
```

###### grass.gunittest.gmodules.SimpleModule.stdin

```python
stdin = None
```

###### grass.gunittest.gmodules.SimpleModule.stdin\_

```python
stdin_ = None
```

###### grass.gunittest.gmodules.SimpleModule.stdout\_

```python
stdout_ = None
```

###### grass.gunittest.gmodules.SimpleModule.time

```python
time = None
```

###### grass.gunittest.gmodules.SimpleModule.update

```python
update(*args, **kargs)
```

Update module parameters and selected object attributes.

Valid parameters are all the module parameters
and additional parameters, namely: run\_, stdin\_, stdout\_, stderr\_,
env\_, and finish\_.

###### grass.gunittest.gmodules.SimpleModule.wait

```python
wait()
```

Wait for the module to finish. Call this method if
the run() call was performed with self.false\_ = False.

:return: A reference to this object

###### grass.gunittest.gmodules.SimpleModule.xml

```python
xml = get_cmd_xml.communicate()[0]
```

##### grass.gunittest.gmodules.call_module

```python
call_module(module, stdin=None, merge_stderr=False, capture_stdout=True, capture_stderr=True, **kwargs)
```

Run module with parameters given in `kwargs` and return its output.

> > > print(call_module("g.region", flags="pg")) # doctest: +ELLIPSIS
> > > projection=...
> > > zone=...
> > > n=...
> > > s=...
> > > w=...
> > > call_module("m.proj", flags="i", input="-", stdin="50.0 41.5")
> > > '8642890.65|6965155.61|0.00\\n'
> > > call_module(
> > > ... "g.region", aabbbccc="notexist"
> > > ... ) # doctest: +IGNORE_EXCEPTION_DETAIL
> > > Traceback (most recent call last):
> > > ...
> > > CalledModuleError: Module run g.region ... ended with error

If `stdin` is not set and `kwargs` contains `input` with value set
to `-` (dash), the function raises an error.

Note that `input` nor `output` parameters are used by this
function itself, these are usually module parameters which this
function just passes to it. However, when `input` is in parameters
the function checks if its values is correct considering value of
`stdin` parameter.

:param str module: module name
:param stdin: string to be used as module standard input (stdin) or `None`
:param merge_stderr: if the standard error output should be merged with stdout
:param kwargs: module parameters

:returns: module standard output (stdout) as string or None
if capture_stdout is False

:raises CalledModuleError: if module return code is non-zero
:raises ValueError: if the parameters are not correct

.. note::
The data read is buffered in memory, so do not use this method
if the data size is large or unlimited.

#### grass.gunittest.gutils

Utilities related to GRASS GIS for GRASS Python testing framework

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Functions:**

- [**get_current_mapset**](#grass.gunittest.gutils.get_current_mapset) – Get current mapset name as a string
- [**is_map_in_mapset**](#grass.gunittest.gutils.is_map_in_mapset) – Check is map is present in the mapset (current mapset by default)

##### grass.gunittest.gutils.get_current_mapset

```python
get_current_mapset()
```

Get current mapset name as a string

##### grass.gunittest.gutils.is_map_in_mapset

```python
is_map_in_mapset(name, type, mapset=None)
```

Check is map is present in the mapset (current mapset by default)

This function is different from what we would expect in GRASS
because it cares only about specific mapset, the current one by default,
and it does not care that the map is accessible in other mapset.

:param name: name of the map
:param type: data type ('raster', 'raster3d', and 'vector')

#### grass.gunittest.invoker

GRASS Python testing framework test files invoker (runner)

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Classes:**

- [**GrassTestFilesInvoker**](#grass.gunittest.invoker.GrassTestFilesInvoker) – A class used to invoke test files and create the main report

**Functions:**

- [**update_keyval_file**](#grass.gunittest.invoker.update_keyval_file) –

**Attributes:**

- [**maketrans**](#grass.gunittest.invoker.maketrans) –

##### grass.gunittest.invoker.GrassTestFilesInvoker

```python
GrassTestFilesInvoker(start_dir, clean_mapsets=True, clean_outputs=True, clean_before=True, testsuite_dir='testsuite', file_anonymizer=None, timeout=None)
```

A class used to invoke test files and create the main report

**Functions:**

- [**run_in_location**](#grass.gunittest.invoker.GrassTestFilesInvoker.run_in_location) – Run tests in a given location

**Attributes:**

- [**clean_before**](#grass.gunittest.invoker.GrassTestFilesInvoker.clean_before) –
- [**clean_mapsets**](#grass.gunittest.invoker.GrassTestFilesInvoker.clean_mapsets) –
- [**clean_outputs**](#grass.gunittest.invoker.GrassTestFilesInvoker.clean_outputs) –
- [**reporter**](#grass.gunittest.invoker.GrassTestFilesInvoker.reporter) –
- [**start_dir**](#grass.gunittest.invoker.GrassTestFilesInvoker.start_dir) –
- [**testsuite_dir**](#grass.gunittest.invoker.GrassTestFilesInvoker.testsuite_dir) –
- [**testsuite_dirs**](#grass.gunittest.invoker.GrassTestFilesInvoker.testsuite_dirs) –
- [**timeout**](#grass.gunittest.invoker.GrassTestFilesInvoker.timeout) –

:param bool clean_mapsets: if the mapsets should be removed
:param bool clean_outputs: meaning is unclear: random tests outputs,
saved images from maps, profiling?
:param bool clean_before: if mapsets, outputs, and results
should be removed before the tests start
(advantageous when the previous run left everything behind)
:param float timeout: maximum duration of one test in seconds

###### grass.gunittest.invoker.GrassTestFilesInvoker.clean_before

```python
clean_before = clean_before
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.clean_mapsets

```python
clean_mapsets = clean_mapsets
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.clean_outputs

```python
clean_outputs = clean_outputs
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.reporter

```python
reporter = None
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.run_in_location

```python
run_in_location(gisdbase, location, location_type, results_dir, exclude)
```

Run tests in a given location

Returns an object with counting attributes of GrassTestFilesCountingReporter,
i.e., a file-oriented reporter as opposed to testsuite-oriented one.
Use only the attributes related to the summary, such as file_pass_per,
not to one file as these will simply contain the last executed file.

###### grass.gunittest.invoker.GrassTestFilesInvoker.start_dir

```python
start_dir = start_dir
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.testsuite_dir

```python
testsuite_dir = testsuite_dir
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.testsuite_dirs

```python
testsuite_dirs = None
```

###### grass.gunittest.invoker.GrassTestFilesInvoker.timeout

```python
timeout = timeout
```

##### grass.gunittest.invoker.maketrans

```python
maketrans = str.maketrans
```

##### grass.gunittest.invoker.update_keyval_file

```python
update_keyval_file(filename, module, returncode)
```

#### grass.gunittest.loader

GRASS Python testing framework test loading functionality

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras, Edouard Choinière

**Classes:**

- [**GrassTestLoader**](#grass.gunittest.loader.GrassTestLoader) – Class handles GRASS-specific loading of test modules.

**Functions:**

- [**discover_modules**](#grass.gunittest.loader.discover_modules) – Find all test files (modules) in a directory tree.
- [**fnmatch_exclude_with_base**](#grass.gunittest.loader.fnmatch_exclude_with_base) – Return list of files not matching any exclusion pattern

**Attributes:**

- [**GrassTestPythonModule**](#grass.gunittest.loader.GrassTestPythonModule) –
- [**modules**](#grass.gunittest.loader.modules) –

##### grass.gunittest.loader.GrassTestLoader

```python
GrassTestLoader(grass_location)
```

Bases: <code>[TestLoader](#unittest.TestLoader)</code>

Class handles GRASS-specific loading of test modules.

**Functions:**

- [**discover**](#grass.gunittest.loader.GrassTestLoader.discover) – Load test modules from in GRASS testing framework way.

**Attributes:**

- [**all_tests_value**](#grass.gunittest.loader.GrassTestLoader.all_tests_value) –
- [**files_in_testsuite**](#grass.gunittest.loader.GrassTestLoader.files_in_testsuite) –
- [**grass_location**](#grass.gunittest.loader.GrassTestLoader.grass_location) –
- [**skip_dirs**](#grass.gunittest.loader.GrassTestLoader.skip_dirs) –
- [**testsuite_dir**](#grass.gunittest.loader.GrassTestLoader.testsuite_dir) –
- [**universal_tests_value**](#grass.gunittest.loader.GrassTestLoader.universal_tests_value) –

###### grass.gunittest.loader.GrassTestLoader.all_tests_value

```python
all_tests_value = 'all'
```

###### grass.gunittest.loader.GrassTestLoader.discover

```python
discover(start_dir, pattern='test*.py', top_level_dir=None)
```

Load test modules from in GRASS testing framework way.

###### grass.gunittest.loader.GrassTestLoader.files_in_testsuite

```python
files_in_testsuite = '*.py'
```

###### grass.gunittest.loader.GrassTestLoader.grass_location

```python
grass_location = grass_location
```

###### grass.gunittest.loader.GrassTestLoader.skip_dirs

```python
skip_dirs = ['.git', '.svn', 'dist.*', 'bin.*', 'OBJ.*']
```

###### grass.gunittest.loader.GrassTestLoader.testsuite_dir

```python
testsuite_dir = 'testsuite'
```

###### grass.gunittest.loader.GrassTestLoader.universal_tests_value

```python
universal_tests_value = 'universal'
```

##### grass.gunittest.loader.GrassTestPythonModule

```python
GrassTestPythonModule = collections.namedtuple('GrassTestPythonModule', ['name', 'module', 'file_type', 'tested_dir', 'file_dir', 'file_path', 'abs_file_path'])
```

##### grass.gunittest.loader.discover_modules

```python
discover_modules(start_dir, skip_dirs, testsuite_dir, grass_location, all_locations_value, universal_location_value, import_modules, add_failed_imports=True, file_pattern=None, file_regexp=None, exclude=None)
```

Find all test files (modules) in a directory tree.

The function is designed specifically for GRASS testing framework
test layout. It expects some directories to have a "testsuite"
directory where test files (test modules) are present.
Additionally, it also handles loading of test files which specify
in which location they can run.

:param start_dir: directory to start the search
:param file_pattern: pattern of files in a test suite directory
(using Unix shell-style wildcards)
:param skip_dirs: directories not to recurse to (e.g. `.svn`)
:param testsuite_dir: name of directory where the test files are found,
the function will not recurse to this directory
:param grass_location: string with an accepted location type (category, shortcut)
:param all_locations_value: string used to say that all locations
should be loaded (grass_location can be set to this value)
:param universal_location_value: string marking a test as
location-independent (same as not providing any)
:param import_modules: True if files should be imported as modules,
False if the files should be just searched for the needed values

:returns: a list of GrassTestPythonModule objects

.. todo::
Implement import_modules.

##### grass.gunittest.loader.fnmatch_exclude_with_base

```python
fnmatch_exclude_with_base(files, base, exclude)
```

Return list of files not matching any exclusion pattern

:param files: list of file names
:param base: directory (path) where the files are
:param exclude: list of fnmatch glob patterns for exclusion

##### grass.gunittest.loader.modules

```python
modules = discover_modules(start_dir='.', grass_location='all', file_regexp=expression, skip_dirs=GrassTestLoader.skip_dirs, testsuite_dir=GrassTestLoader.testsuite_dir, all_locations_value=GrassTestLoader.all_tests_value, universal_location_value=GrassTestLoader.universal_tests_value, import_modules=False, exclude=None)
```

#### grass.gunittest.main

GRASS Python testing framework module for running from command line

Copyright (C) 2014-2021 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Classes:**

- [**GrassTestProgram**](#grass.gunittest.main.GrassTestProgram) – A class to be used by individual test files (wrapped in the function)

**Functions:**

- [**discovery**](#grass.gunittest.main.discovery) – Recursively find all tests in testsuite directories and run them
- [**get_config**](#grass.gunittest.main.get_config) – Read configuration if available, return empty section proxy if not
- [**main**](#grass.gunittest.main.main) –
- [**test**](#grass.gunittest.main.test) – Run a test of a module.

**Attributes:**

- [**CONFIG_FILENAME**](#grass.gunittest.main.CONFIG_FILENAME) –

##### grass.gunittest.main.CONFIG_FILENAME

```python
CONFIG_FILENAME = '.gunittest.cfg'
```

##### grass.gunittest.main.GrassTestProgram

```python
GrassTestProgram(exit_at_end, grass_location, clean_outputs=True, unittest_argv=None, module=None, verbosity=1, failfast=None, catchbreak=None)
```

Bases: <code>[TestProgram](#unittest.main.TestProgram)</code>

A class to be used by individual test files (wrapped in the function)

**Attributes:**

- [**grass_location**](#grass.gunittest.main.GrassTestProgram.grass_location) –
- [**test**](#grass.gunittest.main.GrassTestProgram.test) –

Prepares the tests in GRASS way and then runs the tests.

:param bool clean_outputs: if outputs in mapset and in ?

###### grass.gunittest.main.GrassTestProgram.grass_location

```python
grass_location = grass_location
```

###### grass.gunittest.main.GrassTestProgram.test

```python
test = None
```

##### grass.gunittest.main.discovery

```python
discovery()
```

Recursively find all tests in testsuite directories and run them

Everything is imported and runs in this process.

Runs using::
python main.py discovery [start_directory]

##### grass.gunittest.main.get_config

```python
get_config(start_directory, config_file)
```

Read configuration if available, return empty section proxy if not

If file is explicitly specified, it must exist.

Raises OSError if file is not accessible, e.g., if it exists,
but there is an issue with permissions.

##### grass.gunittest.main.main

```python
main()
```

##### grass.gunittest.main.test

```python
test()
```

Run a test of a module.

#### grass.gunittest.multireport

Testing framework module for multi report

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Classes:**

- [**TestResultSummary**](#grass.gunittest.multireport.TestResultSummary) –

**Functions:**

- [**files_percent_plot**](#grass.gunittest.multireport.files_percent_plot) –
- [**files_plot**](#grass.gunittest.multireport.files_plot) –
- [**files_successful_plot**](#grass.gunittest.multireport.files_successful_plot) –
- [**info_plot**](#grass.gunittest.multireport.info_plot) –
- [**main**](#grass.gunittest.multireport.main) –
- [**main_page**](#grass.gunittest.multireport.main_page) –
- [**plot_percent_successful**](#grass.gunittest.multireport.plot_percent_successful) –
- [**plot_percents**](#grass.gunittest.multireport.plot_percents) –
- [**tests_percent_plot**](#grass.gunittest.multireport.tests_percent_plot) –
- [**tests_plot**](#grass.gunittest.multireport.tests_plot) –
- [**tests_successful_plot**](#grass.gunittest.multireport.tests_successful_plot) –

##### grass.gunittest.multireport.TestResultSummary

```python
TestResultSummary()
```

**Attributes:**

- [**errors**](#grass.gunittest.multireport.TestResultSummary.errors) –
- [**expected_failures**](#grass.gunittest.multireport.TestResultSummary.expected_failures) –
- [**failures**](#grass.gunittest.multireport.TestResultSummary.failures) –
- [**files_failures**](#grass.gunittest.multireport.TestResultSummary.files_failures) –
- [**files_successes**](#grass.gunittest.multireport.TestResultSummary.files_successes) –
- [**files_total**](#grass.gunittest.multireport.TestResultSummary.files_total) –
- [**location**](#grass.gunittest.multireport.TestResultSummary.location) –
- [**location_type**](#grass.gunittest.multireport.TestResultSummary.location_type) –
- [**names**](#grass.gunittest.multireport.TestResultSummary.names) –
- [**report**](#grass.gunittest.multireport.TestResultSummary.report) –
- [**skipped**](#grass.gunittest.multireport.TestResultSummary.skipped) –
- [**successes**](#grass.gunittest.multireport.TestResultSummary.successes) –
- [**svn_revision**](#grass.gunittest.multireport.TestResultSummary.svn_revision) –
- [**test_files_authors**](#grass.gunittest.multireport.TestResultSummary.test_files_authors) –
- [**tested_dirs**](#grass.gunittest.multireport.TestResultSummary.tested_dirs) –
- [**tested_modules**](#grass.gunittest.multireport.TestResultSummary.tested_modules) –
- [**time**](#grass.gunittest.multireport.TestResultSummary.time) –
- [**timestamp**](#grass.gunittest.multireport.TestResultSummary.timestamp) –
- [**total**](#grass.gunittest.multireport.TestResultSummary.total) –
- [**unexpected_successes**](#grass.gunittest.multireport.TestResultSummary.unexpected_successes) –

###### grass.gunittest.multireport.TestResultSummary.errors

```python
errors = None
```

###### grass.gunittest.multireport.TestResultSummary.expected_failures

```python
expected_failures = []
```

###### grass.gunittest.multireport.TestResultSummary.failures

```python
failures = None
```

###### grass.gunittest.multireport.TestResultSummary.files_failures

```python
files_failures = None
```

###### grass.gunittest.multireport.TestResultSummary.files_successes

```python
files_successes = None
```

###### grass.gunittest.multireport.TestResultSummary.files_total

```python
files_total = None
```

###### grass.gunittest.multireport.TestResultSummary.location

```python
location = None
```

###### grass.gunittest.multireport.TestResultSummary.location_type

```python
location_type = None
```

###### grass.gunittest.multireport.TestResultSummary.names

```python
names = []
```

###### grass.gunittest.multireport.TestResultSummary.report

```python
report = None
```

###### grass.gunittest.multireport.TestResultSummary.skipped

```python
skipped = []
```

###### grass.gunittest.multireport.TestResultSummary.successes

```python
successes = None
```

###### grass.gunittest.multireport.TestResultSummary.svn_revision

```python
svn_revision = None
```

###### grass.gunittest.multireport.TestResultSummary.test_files_authors

```python
test_files_authors = []
```

###### grass.gunittest.multireport.TestResultSummary.tested_dirs

```python
tested_dirs = []
```

###### grass.gunittest.multireport.TestResultSummary.tested_modules

```python
tested_modules = []
```

###### grass.gunittest.multireport.TestResultSummary.time

```python
time = []
```

###### grass.gunittest.multireport.TestResultSummary.timestamp

```python
timestamp = None
```

###### grass.gunittest.multireport.TestResultSummary.total

```python
total = None
```

###### grass.gunittest.multireport.TestResultSummary.unexpected_successes

```python
unexpected_successes = []
```

##### grass.gunittest.multireport.files_percent_plot

```python
files_percent_plot(x, xticks, xlabels, results, filename, style)
```

##### grass.gunittest.multireport.files_plot

```python
files_plot(x, xticks, xlabels, results, filename, style)
```

##### grass.gunittest.multireport.files_successful_plot

```python
files_successful_plot(x, xticks, xlabels, results, filename, style)
```

##### grass.gunittest.multireport.info_plot

```python
info_plot(x, xticks, xlabels, results, filename, style)
```

##### grass.gunittest.multireport.main

```python
main()
```

##### grass.gunittest.multireport.main_page

```python
main_page(results, filename, images, captions, title='Test reports', directory=None)
```

##### grass.gunittest.multireport.plot_percent_successful

```python
plot_percent_successful(x, xticks, xlabels, successes, filename, style)
```

##### grass.gunittest.multireport.plot_percents

```python
plot_percents(x, xticks, xlabels, successes, failures, filename, style)
```

##### grass.gunittest.multireport.tests_percent_plot

```python
tests_percent_plot(x, xticks, xlabels, results, filename, style)
```

##### grass.gunittest.multireport.tests_plot

```python
tests_plot(x, xticks, xlabels, results, filename, style)
```

##### grass.gunittest.multireport.tests_successful_plot

```python
tests_successful_plot(x, xticks, xlabels, results, filename, style)
```

#### grass.gunittest.multirunner

Testing framework module for running tests in Python unittest fashion

Copyright (C) 2014-2021 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Functions:**

- [**decode**](#grass.gunittest.multirunner.decode) –
- [**encode**](#grass.gunittest.multirunner.encode) –
- [**main**](#grass.gunittest.multirunner.main) –
- [**text_to_string**](#grass.gunittest.multirunner.text_to_string) – Convert text to str. Useful when passing text into environments,

##### grass.gunittest.multirunner.decode

```python
decode(bytes_, encoding=None)
```

##### grass.gunittest.multirunner.encode

```python
encode(string, encoding=None)
```

##### grass.gunittest.multirunner.main

```python
main()
```

##### grass.gunittest.multirunner.text_to_string

```python
text_to_string(text)
```

Convert text to str. Useful when passing text into environments,
in Python 2 it needs to be bytes on Windows, in Python 3 in needs unicode.

#### grass.gunittest.reporters

GRASS Python testing framework module for report generation

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Classes:**

- [**FileAnonymizer**](#grass.gunittest.reporters.FileAnonymizer) –
- [**GrassTestFilesCountingReporter**](#grass.gunittest.reporters.GrassTestFilesCountingReporter) –
- [**GrassTestFilesHtmlReporter**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter) –
- [**GrassTestFilesKeyValueReporter**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter) –
- [**GrassTestFilesMultiReporter**](#grass.gunittest.reporters.GrassTestFilesMultiReporter) – Interface to multiple reporter objects
- [**GrassTestFilesTextReporter**](#grass.gunittest.reporters.GrassTestFilesTextReporter) –
- [**NoopFileAnonymizer**](#grass.gunittest.reporters.NoopFileAnonymizer) –
- [**TestsuiteDirReporter**](#grass.gunittest.reporters.TestsuiteDirReporter) –

**Functions:**

- [**color_error_line**](#grass.gunittest.reporters.color_error_line) –
- [**format_percentage**](#grass.gunittest.reporters.format_percentage) –
- [**get_html_test_authors_table**](#grass.gunittest.reporters.get_html_test_authors_table) –
- [**get_source_url**](#grass.gunittest.reporters.get_source_url) – :param path: directory or file path relative to remote repository root
- [**get_svn_info**](#grass.gunittest.reporters.get_svn_info) – Get important information from `svn info`
- [**get_svn_path_authors**](#grass.gunittest.reporters.get_svn_path_authors) – :returns: a set of authors
- [**get_svn_revision**](#grass.gunittest.reporters.get_svn_revision) – Get SVN revision number
- [**html_escape**](#grass.gunittest.reporters.html_escape) – Escape `'&'`, `'<'`, and `'>'` in a string of data.
- [**html_file_preview**](#grass.gunittest.reporters.html_file_preview) –
- [**html_unescape**](#grass.gunittest.reporters.html_unescape) – Unescape `'&amp;'`, `'&lt;'`, and `'&gt;'` in a string of data.
- [**keyvalue_to_text**](#grass.gunittest.reporters.keyvalue_to_text) –
- [**percent_to_html**](#grass.gunittest.reporters.percent_to_html) –
- [**replace_in_file**](#grass.gunittest.reporters.replace_in_file) – :param repl: a repl parameter of `re.sub()` function
- [**returncode_to_html_sentence**](#grass.gunittest.reporters.returncode_to_html_sentence) –
- [**returncode_to_html_text**](#grass.gunittest.reporters.returncode_to_html_text) –
- [**returncode_to_success_html_par**](#grass.gunittest.reporters.returncode_to_success_html_par) –
- [**success_to_html_percent**](#grass.gunittest.reporters.success_to_html_percent) –
- [**success_to_html_text**](#grass.gunittest.reporters.success_to_html_text) –
- [**to_web_path**](#grass.gunittest.reporters.to_web_path) – Replace OS dependent path separator with slash.
- [**wrap_stdstream_to_html**](#grass.gunittest.reporters.wrap_stdstream_to_html) –
- [**years_ago**](#grass.gunittest.reporters.years_ago) –

**Attributes:**

- [**UNKNOWN_NUMBER_HTML**](#grass.gunittest.reporters.UNKNOWN_NUMBER_HTML) –

##### grass.gunittest.reporters.FileAnonymizer

```python
FileAnonymizer(paths_to_remove, remove_gisbase=True, remove_gisdbase=False)
```

**Functions:**

- [**anonymize**](#grass.gunittest.reporters.FileAnonymizer.anonymize) –

###### grass.gunittest.reporters.FileAnonymizer.anonymize

```python
anonymize(filenames)
```

##### grass.gunittest.reporters.GrassTestFilesCountingReporter

```python
GrassTestFilesCountingReporter()
```

**Functions:**

- [**end_file_test**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.end_file_test) –
- [**finish**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.finish) –
- [**start**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.start) –
- [**start_file_test**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.start_file_test) –

**Attributes:**

- [**file_end_time**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.file_end_time) –
- [**file_fail_per**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.file_fail_per) –
- [**file_pass_per**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.file_pass_per) –
- [**file_start_time**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.file_start_time) –
- [**file_time**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.file_time) –
- [**files_fail**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.files_fail) –
- [**files_pass**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.files_pass) –
- [**main_end_time**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.main_end_time) –
- [**main_start_time**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.main_start_time) –
- [**main_time**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.main_time) –
- [**test_files**](#grass.gunittest.reporters.GrassTestFilesCountingReporter.test_files) –

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.end_file_test

```python
end_file_test(returncode, **kwargs)
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.file_end_time

```python
file_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.file_fail_per

```python
file_fail_per = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.file_pass_per

```python
file_pass_per = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.file_start_time

```python
file_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.file_time

```python
file_time = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.files_fail

```python
files_fail = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.files_pass

```python
files_pass = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.finish

```python
finish()
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.main_end_time

```python
main_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.main_start_time

```python
main_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.main_time

```python
main_time = None
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.start

```python
start(results_dir)
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.start_file_test

```python
start_file_test(module)
```

###### grass.gunittest.reporters.GrassTestFilesCountingReporter.test_files

```python
test_files = None
```

##### grass.gunittest.reporters.GrassTestFilesHtmlReporter

```python
GrassTestFilesHtmlReporter(file_anonymizer, main_page_name='index.html')
```

Bases: <code>[GrassTestFilesCountingReporter](#grass.gunittest.reporters.GrassTestFilesCountingReporter)</code>

**Functions:**

- [**end_file_test**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.end_file_test) –
- [**finish**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.finish) –
- [**start**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.start) –
- [**start_file_test**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.start_file_test) –

**Attributes:**

- [**file_end_time**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_end_time) –
- [**file_fail_per**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_fail_per) –
- [**file_pass_per**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_pass_per) –
- [**file_start_time**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_start_time) –
- [**file_time**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_time) –
- [**files_fail**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.files_fail) –
- [**files_pass**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.files_pass) –
- [**main_end_time**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_end_time) –
- [**main_index**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_index) –
- [**main_start_time**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_start_time) –
- [**main_time**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_time) –
- [**test_files**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.test_files) –
- [**unknown_number**](#grass.gunittest.reporters.GrassTestFilesHtmlReporter.unknown_number) –

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.end_file_test

```python
end_file_test(module, cwd, returncode, stdout, stderr, test_summary, timed_out=None)
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_end_time

```python
file_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_fail_per

```python
file_fail_per = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_pass_per

```python
file_pass_per = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_start_time

```python
file_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.file_time

```python
file_time = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.files_fail

```python
files_fail = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.files_pass

```python
files_pass = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.finish

```python
finish()
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_end_time

```python
main_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_index

```python
main_index = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_start_time

```python
main_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.main_time

```python
main_time = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.start

```python
start(results_dir)
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.start_file_test

```python
start_file_test(module)
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.test_files

```python
test_files = None
```

###### grass.gunittest.reporters.GrassTestFilesHtmlReporter.unknown_number

```python
unknown_number = UNKNOWN_NUMBER_HTML
```

##### grass.gunittest.reporters.GrassTestFilesKeyValueReporter

```python
GrassTestFilesKeyValueReporter(info=None)
```

Bases: <code>[GrassTestFilesCountingReporter](#grass.gunittest.reporters.GrassTestFilesCountingReporter)</code>

**Functions:**

- [**end_file_test**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.end_file_test) –
- [**finish**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.finish) –
- [**start**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.start) –
- [**start_file_test**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.start_file_test) –

**Attributes:**

- [**file_end_time**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_end_time) –
- [**file_fail_per**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_fail_per) –
- [**file_pass_per**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_pass_per) –
- [**file_start_time**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_start_time) –
- [**file_time**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_time) –
- [**files_fail**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.files_fail) –
- [**files_pass**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.files_pass) –
- [**main_end_time**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.main_end_time) –
- [**main_start_time**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.main_start_time) –
- [**main_time**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.main_time) –
- [**result_dir**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.result_dir) –
- [**test_files**](#grass.gunittest.reporters.GrassTestFilesKeyValueReporter.test_files) –

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.end_file_test

```python
end_file_test(module, cwd, returncode, stdout, stderr, test_summary, timed_out=None)
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_end_time

```python
file_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_fail_per

```python
file_fail_per = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_pass_per

```python
file_pass_per = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_start_time

```python
file_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.file_time

```python
file_time = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.files_fail

```python
files_fail = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.files_pass

```python
files_pass = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.finish

```python
finish()
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.main_end_time

```python
main_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.main_start_time

```python
main_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.main_time

```python
main_time = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.result_dir

```python
result_dir = None
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.start

```python
start(results_dir)
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.start_file_test

```python
start_file_test(module)
```

###### grass.gunittest.reporters.GrassTestFilesKeyValueReporter.test_files

```python
test_files = None
```

##### grass.gunittest.reporters.GrassTestFilesMultiReporter

```python
GrassTestFilesMultiReporter(reporters, forgiving=False)
```

Interface to multiple reporter objects

For start and finish of the tests and of a test of one file,
it calls corresponding methods of all contained reporters.
For all other attributes, it returns attribute of a first reporter
which has this attribute using the order in which the reporters were
provided.

**Functions:**

- [**end_file_test**](#grass.gunittest.reporters.GrassTestFilesMultiReporter.end_file_test) –
- [**finish**](#grass.gunittest.reporters.GrassTestFilesMultiReporter.finish) –
- [**start**](#grass.gunittest.reporters.GrassTestFilesMultiReporter.start) –
- [**start_file_test**](#grass.gunittest.reporters.GrassTestFilesMultiReporter.start_file_test) –

**Attributes:**

- [**forgiving**](#grass.gunittest.reporters.GrassTestFilesMultiReporter.forgiving) –
- [**reporters**](#grass.gunittest.reporters.GrassTestFilesMultiReporter.reporters) –

###### grass.gunittest.reporters.GrassTestFilesMultiReporter.end_file_test

```python
end_file_test(**kwargs)
```

###### grass.gunittest.reporters.GrassTestFilesMultiReporter.finish

```python
finish()
```

###### grass.gunittest.reporters.GrassTestFilesMultiReporter.forgiving

```python
forgiving = forgiving
```

###### grass.gunittest.reporters.GrassTestFilesMultiReporter.reporters

```python
reporters = reporters
```

###### grass.gunittest.reporters.GrassTestFilesMultiReporter.start

```python
start(results_dir)
```

###### grass.gunittest.reporters.GrassTestFilesMultiReporter.start_file_test

```python
start_file_test(module)
```

##### grass.gunittest.reporters.GrassTestFilesTextReporter

```python
GrassTestFilesTextReporter(stream)
```

Bases: <code>[GrassTestFilesCountingReporter](#grass.gunittest.reporters.GrassTestFilesCountingReporter)</code>

**Functions:**

- [**end_file_test**](#grass.gunittest.reporters.GrassTestFilesTextReporter.end_file_test) –
- [**finish**](#grass.gunittest.reporters.GrassTestFilesTextReporter.finish) –
- [**start**](#grass.gunittest.reporters.GrassTestFilesTextReporter.start) –
- [**start_file_test**](#grass.gunittest.reporters.GrassTestFilesTextReporter.start_file_test) –

**Attributes:**

- [**file_end_time**](#grass.gunittest.reporters.GrassTestFilesTextReporter.file_end_time) –
- [**file_fail_per**](#grass.gunittest.reporters.GrassTestFilesTextReporter.file_fail_per) –
- [**file_pass_per**](#grass.gunittest.reporters.GrassTestFilesTextReporter.file_pass_per) –
- [**file_start_time**](#grass.gunittest.reporters.GrassTestFilesTextReporter.file_start_time) –
- [**file_time**](#grass.gunittest.reporters.GrassTestFilesTextReporter.file_time) –
- [**files_fail**](#grass.gunittest.reporters.GrassTestFilesTextReporter.files_fail) –
- [**files_pass**](#grass.gunittest.reporters.GrassTestFilesTextReporter.files_pass) –
- [**main_end_time**](#grass.gunittest.reporters.GrassTestFilesTextReporter.main_end_time) –
- [**main_start_time**](#grass.gunittest.reporters.GrassTestFilesTextReporter.main_start_time) –
- [**main_time**](#grass.gunittest.reporters.GrassTestFilesTextReporter.main_time) –
- [**test_files**](#grass.gunittest.reporters.GrassTestFilesTextReporter.test_files) –

###### grass.gunittest.reporters.GrassTestFilesTextReporter.end_file_test

```python
end_file_test(module, cwd, returncode, stdout, stderr, test_summary, timed_out=None)
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.file_end_time

```python
file_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.file_fail_per

```python
file_fail_per = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.file_pass_per

```python
file_pass_per = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.file_start_time

```python
file_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.file_time

```python
file_time = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.files_fail

```python
files_fail = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.files_pass

```python
files_pass = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.finish

```python
finish()
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.main_end_time

```python
main_end_time = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.main_start_time

```python
main_start_time = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.main_time

```python
main_time = None
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.start

```python
start(results_dir)
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.start_file_test

```python
start_file_test(module)
```

###### grass.gunittest.reporters.GrassTestFilesTextReporter.test_files

```python
test_files = None
```

##### grass.gunittest.reporters.NoopFileAnonymizer

**Functions:**

- [**anonymize**](#grass.gunittest.reporters.NoopFileAnonymizer.anonymize) –

###### grass.gunittest.reporters.NoopFileAnonymizer.anonymize

```python
anonymize(filenames)
```

##### grass.gunittest.reporters.TestsuiteDirReporter

```python
TestsuiteDirReporter(main_page_name, testsuite_page_name='index.html', top_level_testsuite_page_name=None)
```

**Functions:**

- [**report_for_dir**](#grass.gunittest.reporters.TestsuiteDirReporter.report_for_dir) –
- [**report_for_dirs**](#grass.gunittest.reporters.TestsuiteDirReporter.report_for_dirs) –

**Attributes:**

- [**errors**](#grass.gunittest.reporters.TestsuiteDirReporter.errors) –
- [**expected_failures**](#grass.gunittest.reporters.TestsuiteDirReporter.expected_failures) –
- [**failures**](#grass.gunittest.reporters.TestsuiteDirReporter.failures) –
- [**files**](#grass.gunittest.reporters.TestsuiteDirReporter.files) –
- [**files_successes**](#grass.gunittest.reporters.TestsuiteDirReporter.files_successes) –
- [**main_page_name**](#grass.gunittest.reporters.TestsuiteDirReporter.main_page_name) –
- [**skipped**](#grass.gunittest.reporters.TestsuiteDirReporter.skipped) –
- [**successes**](#grass.gunittest.reporters.TestsuiteDirReporter.successes) –
- [**testsuite_page_name**](#grass.gunittest.reporters.TestsuiteDirReporter.testsuite_page_name) –
- [**testsuites**](#grass.gunittest.reporters.TestsuiteDirReporter.testsuites) –
- [**testsuites_successes**](#grass.gunittest.reporters.TestsuiteDirReporter.testsuites_successes) –
- [**top_level_testsuite_page_name**](#grass.gunittest.reporters.TestsuiteDirReporter.top_level_testsuite_page_name) –
- [**total**](#grass.gunittest.reporters.TestsuiteDirReporter.total) –
- [**unexpected_successes**](#grass.gunittest.reporters.TestsuiteDirReporter.unexpected_successes) –

###### grass.gunittest.reporters.TestsuiteDirReporter.errors

```python
errors = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.expected_failures

```python
expected_failures = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.failures

```python
failures = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.files

```python
files = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.files_successes

```python
files_successes = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.main_page_name

```python
main_page_name = main_page_name
```

###### grass.gunittest.reporters.TestsuiteDirReporter.report_for_dir

```python
report_for_dir(root, directory, test_files)
```

###### grass.gunittest.reporters.TestsuiteDirReporter.report_for_dirs

```python
report_for_dirs(root, directories)
```

###### grass.gunittest.reporters.TestsuiteDirReporter.skipped

```python
skipped = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.successes

```python
successes = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.testsuite_page_name

```python
testsuite_page_name = testsuite_page_name
```

###### grass.gunittest.reporters.TestsuiteDirReporter.testsuites

```python
testsuites = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.testsuites_successes

```python
testsuites_successes = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.top_level_testsuite_page_name

```python
top_level_testsuite_page_name = top_level_testsuite_page_name
```

###### grass.gunittest.reporters.TestsuiteDirReporter.total

```python
total = 0
```

###### grass.gunittest.reporters.TestsuiteDirReporter.unexpected_successes

```python
unexpected_successes = 0
```

##### grass.gunittest.reporters.UNKNOWN_NUMBER_HTML

```python
UNKNOWN_NUMBER_HTML = '<span style="font-size: 60%">unknown</span>'
```

##### grass.gunittest.reporters.color_error_line

```python
color_error_line(line)
```

##### grass.gunittest.reporters.format_percentage

```python
format_percentage(percentage)
```

##### grass.gunittest.reporters.get_html_test_authors_table

```python
get_html_test_authors_table(directory, tests_authors)
```

##### grass.gunittest.reporters.get_source_url

```python
get_source_url(path, revision, line=None)
```

:param path: directory or file path relative to remote repository root
:param revision: SVN revision (should be a number)
:param line: line in the file (should be None for directories)

##### grass.gunittest.reporters.get_svn_info

```python
get_svn_info()
```

Get important information from `svn info`

:returns: SVN info as dictionary or None
if it is not possible to obtain it

##### grass.gunittest.reporters.get_svn_path_authors

```python
get_svn_path_authors(path, from_date=None)
```

:returns: a set of authors

##### grass.gunittest.reporters.get_svn_revision

```python
get_svn_revision()
```

Get SVN revision number

:returns: SVN revision number as string or None if it is
not possible to get

##### grass.gunittest.reporters.html_escape

```python
html_escape(text)
```

Escape `'&'`, `'<'`, and `'>'` in a string of data.

##### grass.gunittest.reporters.html_file_preview

```python
html_file_preview(filename)
```

##### grass.gunittest.reporters.html_unescape

```python
html_unescape(text)
```

Unescape `'&amp;'`, `'&lt;'`, and `'&gt;'` in a string of data.

##### grass.gunittest.reporters.keyvalue_to_text

```python
keyvalue_to_text(keyvalue, sep='=', vsep='\n', isep=',', last_vertical=None)
```

##### grass.gunittest.reporters.percent_to_html

```python
percent_to_html(percent)
```

##### grass.gunittest.reporters.replace_in_file

```python
replace_in_file(file_path, pattern, repl)
```

:param repl: a repl parameter of `re.sub()` function

##### grass.gunittest.reporters.returncode_to_html_sentence

```python
returncode_to_html_sentence(returncode)
```

##### grass.gunittest.reporters.returncode_to_html_text

```python
returncode_to_html_text(returncode, timed_out=None)
```

##### grass.gunittest.reporters.returncode_to_success_html_par

```python
returncode_to_success_html_par(returncode)
```

##### grass.gunittest.reporters.success_to_html_percent

```python
success_to_html_percent(total, successes)
```

##### grass.gunittest.reporters.success_to_html_text

```python
success_to_html_text(total, successes)
```

##### grass.gunittest.reporters.to_web_path

```python
to_web_path(path)
```

Replace OS dependent path separator with slash.

Path on MS Windows are not usable in links on web. For MS Windows,
this replaces backslash with (forward) slash.

##### grass.gunittest.reporters.wrap_stdstream_to_html

```python
wrap_stdstream_to_html(infile, outfile, module, stream)
```

##### grass.gunittest.reporters.years_ago

```python
years_ago(date, years)
```

#### grass.gunittest.runner

Testing framework module for running tests in Python unittest fashion

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

File content taken from Python's `unittest.runner`, it will be used as
a template. It is not expected that something will left.

**Classes:**

- [**GrassTestRunner**](#grass.gunittest.runner.GrassTestRunner) –
- [**KeyValueTestResult**](#grass.gunittest.runner.KeyValueTestResult) – A test result class that can print formatted text results to a stream.
- [**MultiTestResult**](#grass.gunittest.runner.MultiTestResult) –
- [**TestResult**](#grass.gunittest.runner.TestResult) –
- [**TextTestResult**](#grass.gunittest.runner.TextTestResult) – A test result class that can print formatted text results to a stream.

##### grass.gunittest.runner.GrassTestRunner

```python
GrassTestRunner(stream=sys.stderr, descriptions=True, verbosity=1, failfast=False, buffer=False, result=None)
```

**Functions:**

- [**run**](#grass.gunittest.runner.GrassTestRunner.run) – Run the given test case or test suite.

**Attributes:**

- [**buffer**](#grass.gunittest.runner.GrassTestRunner.buffer) –
- [**descriptions**](#grass.gunittest.runner.GrassTestRunner.descriptions) –
- [**failfast**](#grass.gunittest.runner.GrassTestRunner.failfast) –
- [**stream**](#grass.gunittest.runner.GrassTestRunner.stream) –
- [**verbosity**](#grass.gunittest.runner.GrassTestRunner.verbosity) –

###### grass.gunittest.runner.GrassTestRunner.buffer

```python
buffer = buffer
```

###### grass.gunittest.runner.GrassTestRunner.descriptions

```python
descriptions = descriptions
```

###### grass.gunittest.runner.GrassTestRunner.failfast

```python
failfast = failfast
```

###### grass.gunittest.runner.GrassTestRunner.run

```python
run(test)
```

Run the given test case or test suite.

###### grass.gunittest.runner.GrassTestRunner.stream

```python
stream = _WritelnDecorator(stream)
```

###### grass.gunittest.runner.GrassTestRunner.verbosity

```python
verbosity = verbosity
```

##### grass.gunittest.runner.KeyValueTestResult

```python
KeyValueTestResult(stream, test_type=None)
```

Bases: <code>[TestResult](#grass.gunittest.runner.TestResult)</code>

A test result class that can print formatted text results to a stream.

Used by TextTestRunner.

**Functions:**

- [**addSuccess**](#grass.gunittest.runner.KeyValueTestResult.addSuccess) –
- [**setTimes**](#grass.gunittest.runner.KeyValueTestResult.setTimes) –
- [**stopTest**](#grass.gunittest.runner.KeyValueTestResult.stopTest) –
- [**stopTestRun**](#grass.gunittest.runner.KeyValueTestResult.stopTestRun) –

**Attributes:**

- [**end_time**](#grass.gunittest.runner.KeyValueTestResult.end_time) –
- [**separator1**](#grass.gunittest.runner.KeyValueTestResult.separator1) –
- [**separator2**](#grass.gunittest.runner.KeyValueTestResult.separator2) –
- [**start_time**](#grass.gunittest.runner.KeyValueTestResult.start_time) –
- [**successes**](#grass.gunittest.runner.KeyValueTestResult.successes) –
- [**test_type**](#grass.gunittest.runner.KeyValueTestResult.test_type) –
- [**time_taken**](#grass.gunittest.runner.KeyValueTestResult.time_taken) –

###### grass.gunittest.runner.KeyValueTestResult.addSuccess

```python
addSuccess(test)
```

###### grass.gunittest.runner.KeyValueTestResult.end_time

```python
end_time = None
```

###### grass.gunittest.runner.KeyValueTestResult.separator1

```python
separator1 = '=' * 70
```

###### grass.gunittest.runner.KeyValueTestResult.separator2

```python
separator2 = '-' * 70
```

###### grass.gunittest.runner.KeyValueTestResult.setTimes

```python
setTimes(start_time, end_time, time_taken)
```

###### grass.gunittest.runner.KeyValueTestResult.start_time

```python
start_time = None
```

###### grass.gunittest.runner.KeyValueTestResult.stopTest

```python
stopTest(test)
```

###### grass.gunittest.runner.KeyValueTestResult.stopTestRun

```python
stopTestRun()
```

###### grass.gunittest.runner.KeyValueTestResult.successes

```python
successes = []
```

###### grass.gunittest.runner.KeyValueTestResult.test_type

```python
test_type = test_type
```

###### grass.gunittest.runner.KeyValueTestResult.time_taken

```python
time_taken = None
```

##### grass.gunittest.runner.MultiTestResult

```python
MultiTestResult(results, forgiving=False, descriptions=None, verbosity=None)
```

Bases: <code>[TestResult](#grass.gunittest.runner.TestResult)</code>

**Functions:**

- [**addError**](#grass.gunittest.runner.MultiTestResult.addError) –
- [**addExpectedFailure**](#grass.gunittest.runner.MultiTestResult.addExpectedFailure) –
- [**addFailure**](#grass.gunittest.runner.MultiTestResult.addFailure) –
- [**addSkip**](#grass.gunittest.runner.MultiTestResult.addSkip) –
- [**addSuccess**](#grass.gunittest.runner.MultiTestResult.addSuccess) –
- [**addUnexpectedSuccess**](#grass.gunittest.runner.MultiTestResult.addUnexpectedSuccess) –
- [**printErrors**](#grass.gunittest.runner.MultiTestResult.printErrors) – Called by TestRunner after test run
- [**setTimes**](#grass.gunittest.runner.MultiTestResult.setTimes) –
- [**startTest**](#grass.gunittest.runner.MultiTestResult.startTest) –
- [**startTestRun**](#grass.gunittest.runner.MultiTestResult.startTestRun) – Called once before any tests are executed.
- [**stopTest**](#grass.gunittest.runner.MultiTestResult.stopTest) – Called when the given test has been run
- [**stopTestRun**](#grass.gunittest.runner.MultiTestResult.stopTestRun) – Called once after all tests are executed.

**Attributes:**

- [**successes**](#grass.gunittest.runner.MultiTestResult.successes) –

###### grass.gunittest.runner.MultiTestResult.addError

```python
addError(test, err)
```

###### grass.gunittest.runner.MultiTestResult.addExpectedFailure

```python
addExpectedFailure(test, err)
```

###### grass.gunittest.runner.MultiTestResult.addFailure

```python
addFailure(test, err)
```

###### grass.gunittest.runner.MultiTestResult.addSkip

```python
addSkip(test, reason)
```

###### grass.gunittest.runner.MultiTestResult.addSuccess

```python
addSuccess(test)
```

###### grass.gunittest.runner.MultiTestResult.addUnexpectedSuccess

```python
addUnexpectedSuccess(test)
```

###### grass.gunittest.runner.MultiTestResult.printErrors

```python
printErrors()
```

Called by TestRunner after test run

###### grass.gunittest.runner.MultiTestResult.setTimes

```python
setTimes(start_time, end_time, time_taken)
```

###### grass.gunittest.runner.MultiTestResult.startTest

```python
startTest(test)
```

###### grass.gunittest.runner.MultiTestResult.startTestRun

```python
startTestRun()
```

Called once before any tests are executed.

See startTest for a method called before each test.

###### grass.gunittest.runner.MultiTestResult.stopTest

```python
stopTest(test)
```

Called when the given test has been run

###### grass.gunittest.runner.MultiTestResult.stopTestRun

```python
stopTestRun()
```

Called once after all tests are executed.

See stopTest for a method called after each test.

###### grass.gunittest.runner.MultiTestResult.successes

```python
successes = []
```

##### grass.gunittest.runner.TestResult

```python
TestResult(stream=None, descriptions=None, verbosity=None)
```

Bases: <code>[TestResult](#unittest.TestResult)</code>

**Functions:**

- [**addSuccess**](#grass.gunittest.runner.TestResult.addSuccess) –
- [**setTimes**](#grass.gunittest.runner.TestResult.setTimes) –

**Attributes:**

- [**successes**](#grass.gunittest.runner.TestResult.successes) –

###### grass.gunittest.runner.TestResult.addSuccess

```python
addSuccess(test)
```

###### grass.gunittest.runner.TestResult.setTimes

```python
setTimes(start_time, end_time, time_taken)
```

###### grass.gunittest.runner.TestResult.successes

```python
successes = []
```

##### grass.gunittest.runner.TextTestResult

```python
TextTestResult(stream, descriptions, verbosity)
```

Bases: <code>[TestResult](#grass.gunittest.runner.TestResult)</code>

A test result class that can print formatted text results to a stream.

Used by TextTestRunner.

**Functions:**

- [**addError**](#grass.gunittest.runner.TextTestResult.addError) –
- [**addExpectedFailure**](#grass.gunittest.runner.TextTestResult.addExpectedFailure) –
- [**addFailure**](#grass.gunittest.runner.TextTestResult.addFailure) –
- [**addSkip**](#grass.gunittest.runner.TextTestResult.addSkip) –
- [**addSuccess**](#grass.gunittest.runner.TextTestResult.addSuccess) –
- [**addUnexpectedSuccess**](#grass.gunittest.runner.TextTestResult.addUnexpectedSuccess) –
- [**getDescription**](#grass.gunittest.runner.TextTestResult.getDescription) –
- [**printErrorList**](#grass.gunittest.runner.TextTestResult.printErrorList) –
- [**printErrors**](#grass.gunittest.runner.TextTestResult.printErrors) –
- [**setTimes**](#grass.gunittest.runner.TextTestResult.setTimes) –
- [**startTest**](#grass.gunittest.runner.TextTestResult.startTest) –
- [**stopTestRun**](#grass.gunittest.runner.TextTestResult.stopTestRun) –

**Attributes:**

- [**descriptions**](#grass.gunittest.runner.TextTestResult.descriptions) –
- [**dots**](#grass.gunittest.runner.TextTestResult.dots) –
- [**end_time**](#grass.gunittest.runner.TextTestResult.end_time) –
- [**separator1**](#grass.gunittest.runner.TextTestResult.separator1) –
- [**separator2**](#grass.gunittest.runner.TextTestResult.separator2) –
- [**showAll**](#grass.gunittest.runner.TextTestResult.showAll) –
- [**start_time**](#grass.gunittest.runner.TextTestResult.start_time) –
- [**stream**](#grass.gunittest.runner.TextTestResult.stream) –
- [**successes**](#grass.gunittest.runner.TextTestResult.successes) –
- [**time_taken**](#grass.gunittest.runner.TextTestResult.time_taken) –

###### grass.gunittest.runner.TextTestResult.addError

```python
addError(test, err)
```

###### grass.gunittest.runner.TextTestResult.addExpectedFailure

```python
addExpectedFailure(test, err)
```

###### grass.gunittest.runner.TextTestResult.addFailure

```python
addFailure(test, err)
```

###### grass.gunittest.runner.TextTestResult.addSkip

```python
addSkip(test, reason)
```

###### grass.gunittest.runner.TextTestResult.addSuccess

```python
addSuccess(test)
```

###### grass.gunittest.runner.TextTestResult.addUnexpectedSuccess

```python
addUnexpectedSuccess(test)
```

###### grass.gunittest.runner.TextTestResult.descriptions

```python
descriptions = descriptions
```

###### grass.gunittest.runner.TextTestResult.dots

```python
dots = verbosity == 1
```

###### grass.gunittest.runner.TextTestResult.end_time

```python
end_time = None
```

###### grass.gunittest.runner.TextTestResult.getDescription

```python
getDescription(test)
```

###### grass.gunittest.runner.TextTestResult.printErrorList

```python
printErrorList(flavour, errors)
```

###### grass.gunittest.runner.TextTestResult.printErrors

```python
printErrors()
```

###### grass.gunittest.runner.TextTestResult.separator1

```python
separator1 = '=' * 70
```

###### grass.gunittest.runner.TextTestResult.separator2

```python
separator2 = '-' * 70
```

###### grass.gunittest.runner.TextTestResult.setTimes

```python
setTimes(start_time, end_time, time_taken)
```

###### grass.gunittest.runner.TextTestResult.showAll

```python
showAll = verbosity > 1
```

###### grass.gunittest.runner.TextTestResult.startTest

```python
startTest(test)
```

###### grass.gunittest.runner.TextTestResult.start_time

```python
start_time = None
```

###### grass.gunittest.runner.TextTestResult.stopTestRun

```python
stopTestRun()
```

###### grass.gunittest.runner.TextTestResult.stream

```python
stream = _WritelnDecorator(stream)
```

###### grass.gunittest.runner.TextTestResult.successes

```python
successes = []
```

###### grass.gunittest.runner.TextTestResult.time_taken

```python
time_taken = None
```

#### grass.gunittest.utils

GRASS Python testing framework utilities (general and test-specific)

Copyright (C) 2014 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS GIS
for details.

:authors: Vaclav Petras

**Functions:**

- [**add_gitignore_to_dir**](#grass.gunittest.utils.add_gitignore_to_dir) –
- [**do_doctest_gettext_workaround**](#grass.gunittest.utils.do_doctest_gettext_workaround) – Setups environment for doing a doctest with gettext usage.
- [**ensure_dir**](#grass.gunittest.utils.ensure_dir) – Create all directories in the given path if needed.
- [**safe_repr**](#grass.gunittest.utils.safe_repr) –
- [**silent_rmtree**](#grass.gunittest.utils.silent_rmtree) – Remove the file but do nothing if file does not exist.
- [**xfail_windows**](#grass.gunittest.utils.xfail_windows) – Marks a test as an expected failure or error only on Windows

##### grass.gunittest.utils.add_gitignore_to_dir

```python
add_gitignore_to_dir(directory)
```

##### grass.gunittest.utils.do_doctest_gettext_workaround

```python
do_doctest_gettext_workaround()
```

Setups environment for doing a doctest with gettext usage.

When using gettext with dynamically defined underscore function
(`_("For translation")`), doctest does not work properly. One option is
to use `import as` instead of dynamically defined underscore function but
this would require change all modules which are used by tested module.
This should be considered for the future. The second option is to define
dummy underscore function and one other function which creates the right
environment to satisfy all. This is done by this function.

##### grass.gunittest.utils.ensure_dir

```python
ensure_dir(directory)
```

Create all directories in the given path if needed.

##### grass.gunittest.utils.safe_repr

```python
safe_repr(obj, short=False)
```

##### grass.gunittest.utils.silent_rmtree

```python
silent_rmtree(filename)
```

Remove the file but do nothing if file does not exist.

##### grass.gunittest.utils.xfail_windows

```python
xfail_windows(test_item)
```

Marks a test as an expected failure or error only on Windows
Equivalent to applying @unittest.expectedFailure only when running
on Windows.

### grass.imaging

**Modules:**

- [**images2avi**](#grass.imaging.images2avi) – Module images2avi
- [**images2gif**](#grass.imaging.images2gif) – Module images2gif
- [**images2ims**](#grass.imaging.images2ims) – Module images2ims
- [**images2swf**](#grass.imaging.images2swf) – Module images2swf
- [**operations**](#grass.imaging.operations) – Image non-geospatial operations and manipulations

**Functions:**

- [**readAvi**](#grass.imaging.readAvi) – Read images from an AVI (or MPG) movie.
- [**readGif**](#grass.imaging.readGif) – Read images from an animated GIF file. Returns a list of numpy
- [**readIms**](#grass.imaging.readIms) – Read images from a series of images in a single directory. Returns a
- [**readSwf**](#grass.imaging.readSwf) – Read all images from an SWF (shockwave flash) file. Returns a list
- [**writeAvi**](#grass.imaging.writeAvi) – Export movie to a AVI file, which is encoded with the given
- [**writeGif**](#grass.imaging.writeGif) – Write an animated gif from the specified images.
- [**writeIms**](#grass.imaging.writeIms) – Export movie to a series of image files. If the filenenumber
- [**writeSwf**](#grass.imaging.writeSwf) – Write an swf-file from the specified images. If repeat is False,

#### grass.imaging.images2avi

Module images2avi

Uses ffmpeg to read and write AVI files. Requires PIL

I found these sites useful:
http://www.catswhocode.com/blog/19-ffmpeg-commands-for-all-needs
http://linux.die.net/man/1/ffmpeg

**Functions:**

- [**readAvi**](#grass.imaging.images2avi.readAvi) – Read images from an AVI (or MPG) movie.
- [**writeAvi**](#grass.imaging.images2avi.writeAvi) – Export movie to a AVI file, which is encoded with the given

##### grass.imaging.images2avi.readAvi

```python
readAvi(filename, asNumpy=True)
```

Read images from an AVI (or MPG) movie.

Requires the "ffmpeg" application:

- Most linux users can install using their package manager
- There is a windows installer on the visvis website

:param str filename: name of input movie file
:param bool asNumpy:

##### grass.imaging.images2avi.writeAvi

```python
writeAvi(filename, images, duration=0.1, encoding='mpeg4', inputOptions='', outputOptions='', bg_task=False)
```

Export movie to a AVI file, which is encoded with the given
encoding. Hint for Windows users: the 'msmpeg4v2' codec is
natively supported on Windows.

Images should be a list consisting of PIL images or numpy arrays.
The latter should be between 0 and 255 for integer types, and
between 0 and 1 for float types.

Requires the "ffmpeg" application:

- Most linux users can install using their package manager
- There is a windows installer on the visvis website

:param str filename: output filename
:param images:
:param float duration:
:param str encoding: the encoding type
:param inputOptions:
:param outputOptions:
:param bool bg_task: if thread background task, not raise but
return error message

:return str: error message

#### grass.imaging.images2gif

Module images2gif

Provides functionality for reading and writing animated GIF images.
Use writeGif to write a series of numpy arrays or PIL images as an
animated GIF. Use readGif to read an animated gif as a series of numpy
arrays.

Note that since July 2004, all patents on the LZW compression patent have
expired. Therefore the GIF format may now be used freely.

Acknowledgements:

Many thanks to Ant1 for:

- noting the use of "palette=PIL.Image.ADAPTIVE", which significantly
  improves the results.
- the modifications to save each image with its own palette, or optionally
  the global palette (if its the same).

Many thanks to Marius van Voorden for porting the NeuQuant quantization
algorithm of Anthony Dekker to Python (See the NeuQuant class for its
license).

Many thanks to Alex Robinson for implementing the concept of subrectangles,
which (depending on image content) can give a very significant reduction in
file size.

This code is based on gifmaker (in the scripts folder of the source
distribution of PIL)

Useful links:

- http://tronche.com/computer-graphics/gif/
- https://en.wikipedia.org/wiki/Graphics_Interchange_Format
- http://www.w3.org/Graphics/GIF/spec-gif89a.txt

**Classes:**

- [**GifWriter**](#grass.imaging.images2gif.GifWriter) – Class that contains methods for helping write the animated GIF file.
- [**NeuQuant**](#grass.imaging.images2gif.NeuQuant) – NeuQuant(image, samplefac=10, colors=256)

**Functions:**

- [**checkImages**](#grass.imaging.images2gif.checkImages) – Check numpy images and correct intensity range etc.
- [**get_cKDTree**](#grass.imaging.images2gif.get_cKDTree) –
- [**intToBin**](#grass.imaging.images2gif.intToBin) – Integer to two bytes
- [**readGif**](#grass.imaging.images2gif.readGif) – Read images from an animated GIF file. Returns a list of numpy
- [**writeGif**](#grass.imaging.images2gif.writeGif) – Write an animated gif from the specified images.
- [**writeGifPillow**](#grass.imaging.images2gif.writeGifPillow) – Write an animated gif from the specified images.
- [**writeGifVisvis**](#grass.imaging.images2gif.writeGifVisvis) – Write an animated gif from the specified images.

**Attributes:**

- [**PIL_version**](#grass.imaging.images2gif.PIL_version) –
- [**im**](#grass.imaging.images2gif.im) –
- [**images**](#grass.imaging.images2gif.images) –
- [**pillow**](#grass.imaging.images2gif.pillow) –

##### grass.imaging.images2gif.GifWriter

Class that contains methods for helping write the animated GIF file.

**Functions:**

- [**convertImagesToPIL**](#grass.imaging.images2gif.GifWriter.convertImagesToPIL) – Convert images to Paletted PIL images, which can then be
- [**getAppExt**](#grass.imaging.images2gif.GifWriter.getAppExt) – Application extension. This part specifies the amount of loops.
- [**getGraphicsControlExt**](#grass.imaging.images2gif.GifWriter.getGraphicsControlExt) – Graphics Control Extension. A sort of header at the start of
- [**getImageDescriptor**](#grass.imaging.images2gif.GifWriter.getImageDescriptor) – Used for the local color table properties per image.
- [**getSubRectangles**](#grass.imaging.images2gif.GifWriter.getSubRectangles) – Calculate the minimal rectangles that need updating each frame.
- [**getheaderAnim**](#grass.imaging.images2gif.GifWriter.getheaderAnim) – Get animation header. To replace PILs getheader()[0]
- [**handleSubRectangles**](#grass.imaging.images2gif.GifWriter.handleSubRectangles) – Handle the sub-rectangle stuff. If the rectangles are given by the
- [**writeGifToFile**](#grass.imaging.images2gif.GifWriter.writeGifToFile) – Given a set of images writes the bytes to the specified stream.

###### grass.imaging.images2gif.GifWriter.convertImagesToPIL

```python
convertImagesToPIL(images, dither, nq=0)
```

Convert images to Paletted PIL images, which can then be
written to a single animaged GIF.

convertImagesToPIL(images, nq=0)

###### grass.imaging.images2gif.GifWriter.getAppExt

```python
getAppExt(loops=float('inf'))
```

Application extension. This part specifies the amount of loops.
If loops is 0 or inf, it goes on infinitely.

:param float loops:

###### grass.imaging.images2gif.GifWriter.getGraphicsControlExt

```python
getGraphicsControlExt(duration=0.1, dispose=2)
```

Graphics Control Extension. A sort of header at the start of
each image. Specifies duration and transparency.

Dispose:

- 0 - No disposal specified.
- 1 - Do not dispose. The graphic is to be left in place.
- 2 - Restore to background color. The area used by the graphic
  must be restored to the background color.
- 3 - Restore to previous. The decoder is required to restore the
  area overwritten by the graphic with what was there prior to
  rendering the graphic.
- 4-7 -To be defined.

:param double duration:
:param dispose:

###### grass.imaging.images2gif.GifWriter.getImageDescriptor

```python
getImageDescriptor(im, xy=None)
```

Used for the local color table properties per image.
Otherwise global color table applies to all frames irrespective of
whether additional colors comes in play that require a redefined
palette. Still a maximum of 256 color per frame, obviously.

Written by Ant1 on 2010-08-22
Modified by Alex Robinson in Janurari 2011 to implement subrectangles.

:param im:
:param xy:

###### grass.imaging.images2gif.GifWriter.getSubRectangles

```python
getSubRectangles(ims)
```

Calculate the minimal rectangles that need updating each frame.
Returns a two-element tuple containing the cropped images and a
list of x-y positions.

Calculating the subrectangles takes extra time, obviously. However,
if the image sizes were reduced, the actual writing of the GIF
goes faster. In some cases applying this method produces a GIF faster.

###### grass.imaging.images2gif.GifWriter.getheaderAnim

```python
getheaderAnim(im)
```

Get animation header. To replace PILs getheader()[0]

:param im:

###### grass.imaging.images2gif.GifWriter.handleSubRectangles

```python
handleSubRectangles(images, subRectangles)
```

Handle the sub-rectangle stuff. If the rectangles are given by the
user, the values are checked. Otherwise the subrectangles are
calculated automatically.

###### grass.imaging.images2gif.GifWriter.writeGifToFile

```python
writeGifToFile(fp, images, durations, loops, xys, disposes)
```

Given a set of images writes the bytes to the specified stream.
Requires different handling of palette for PIL and Pillow:
based on https://github.com/rec/echomesh/blob/master/
code/python/external/images2gif.py

##### grass.imaging.images2gif.NeuQuant

```python
NeuQuant(image, samplefac=10, colors=256)
```

NeuQuant(image, samplefac=10, colors=256)

samplefac should be an integer number of 1 or higher, 1
being the highest quality, but the slowest performance.
With avalue of 10, one tenth of all pixels are used during
training. This value seems a nice tradeof between speed
and quality.

colors is the amount of colors to reduce the image to. This
should best be a power of two.

See also:
http://members.ozemail.com.au/~dekker/NEUQUANT.HTML

**License of the NeuQuant Neural-Net Quantization Algorithm**

Copyright (c) 1994 Anthony Dekker
Ported to python by Marius van Voorden in 2010

NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.
See "Kohonen neural networks for optimal colour quantization"
in "network: Computation in Neural Systems" Vol. 5 (1994) pp 351-367.
for a discussion of the algorithm.
See also http://members.ozemail.com.au/~dekker/NEUQUANT.HTML

Any party obtaining a copy of these files from the author, directly or
indirectly, is granted, free of charge, a full and unrestricted
irrevocable, world-wide, paid up, royalty-free, nonexclusive right and
license to deal in this software and documentation files (the "Software"),
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and
to permit persons who receive copies from any such party to do so, with
the only requirement being that this copyright notice remain intact.

**Functions:**

- [**alterneigh**](#grass.imaging.images2gif.NeuQuant.alterneigh) –
- [**altersingle**](#grass.imaging.images2gif.NeuQuant.altersingle) – Move neuron i towards biased (b, g, r) by factor alpha
- [**contest**](#grass.imaging.images2gif.NeuQuant.contest) – Search for biased BGR values
- [**convert**](#grass.imaging.images2gif.NeuQuant.convert) –
- [**fix**](#grass.imaging.images2gif.NeuQuant.fix) –
- [**geta**](#grass.imaging.images2gif.NeuQuant.geta) –
- [**inxbuild**](#grass.imaging.images2gif.NeuQuant.inxbuild) –
- [**inxsearch**](#grass.imaging.images2gif.NeuQuant.inxsearch) – Search for BGR values 0..255 and return colour index
- [**learn**](#grass.imaging.images2gif.NeuQuant.learn) –
- [**paletteImage**](#grass.imaging.images2gif.NeuQuant.paletteImage) – PIL weird interface for making a paletted image: create an image
- [**quantize**](#grass.imaging.images2gif.NeuQuant.quantize) – Use a kdtree to quickly find the closest palette colors for the
- [**quantize_with_scipy**](#grass.imaging.images2gif.NeuQuant.quantize_with_scipy) –
- [**quantize_without_scipy**](#grass.imaging.images2gif.NeuQuant.quantize_without_scipy) – This function can be used if no scipy is available.
- [**setUpArrays**](#grass.imaging.images2gif.NeuQuant.setUpArrays) –
- [**setconstants**](#grass.imaging.images2gif.NeuQuant.setconstants) –
- [**specialFind**](#grass.imaging.images2gif.NeuQuant.specialFind) –
- [**writeColourMap**](#grass.imaging.images2gif.NeuQuant.writeColourMap) –

**Attributes:**

- [**ALPHABIASSHIFT**](#grass.imaging.images2gif.NeuQuant.ALPHABIASSHIFT) –
- [**BETA**](#grass.imaging.images2gif.NeuQuant.BETA) –
- [**BETAGAMMA**](#grass.imaging.images2gif.NeuQuant.BETAGAMMA) –
- [**BGCOLOR**](#grass.imaging.images2gif.NeuQuant.BGCOLOR) –
- [**CUTNETSIZE**](#grass.imaging.images2gif.NeuQuant.CUTNETSIZE) –
- [**GAMMA**](#grass.imaging.images2gif.NeuQuant.GAMMA) –
- [**INITALPHA**](#grass.imaging.images2gif.NeuQuant.INITALPHA) –
- [**INITBIASRADIUS**](#grass.imaging.images2gif.NeuQuant.INITBIASRADIUS) –
- [**INITRAD**](#grass.imaging.images2gif.NeuQuant.INITRAD) –
- [**MAXNETPOS**](#grass.imaging.images2gif.NeuQuant.MAXNETPOS) –
- [**MAXPRIME**](#grass.imaging.images2gif.NeuQuant.MAXPRIME) –
- [**NCYCLES**](#grass.imaging.images2gif.NeuQuant.NCYCLES) –
- [**NETSIZE**](#grass.imaging.images2gif.NeuQuant.NETSIZE) –
- [**PRIME1**](#grass.imaging.images2gif.NeuQuant.PRIME1) –
- [**PRIME2**](#grass.imaging.images2gif.NeuQuant.PRIME2) –
- [**PRIME3**](#grass.imaging.images2gif.NeuQuant.PRIME3) –
- [**PRIME4**](#grass.imaging.images2gif.NeuQuant.PRIME4) –
- [**RADIUSBIAS**](#grass.imaging.images2gif.NeuQuant.RADIUSBIAS) –
- [**RADIUSBIASSHIFT**](#grass.imaging.images2gif.NeuQuant.RADIUSBIASSHIFT) –
- [**RADIUSDEC**](#grass.imaging.images2gif.NeuQuant.RADIUSDEC) –
- [**SPECIALS**](#grass.imaging.images2gif.NeuQuant.SPECIALS) –
- [**a_s**](#grass.imaging.images2gif.NeuQuant.a_s) –
- [**bias**](#grass.imaging.images2gif.NeuQuant.bias) –
- [**colormap**](#grass.imaging.images2gif.NeuQuant.colormap) –
- [**freq**](#grass.imaging.images2gif.NeuQuant.freq) –
- [**netindex**](#grass.imaging.images2gif.NeuQuant.netindex) –
- [**network**](#grass.imaging.images2gif.NeuQuant.network) –
- [**pimage**](#grass.imaging.images2gif.NeuQuant.pimage) –
- [**pixels**](#grass.imaging.images2gif.NeuQuant.pixels) –
- [**samplefac**](#grass.imaging.images2gif.NeuQuant.samplefac) –

###### grass.imaging.images2gif.NeuQuant.ALPHABIASSHIFT

```python
ALPHABIASSHIFT = None
```

###### grass.imaging.images2gif.NeuQuant.BETA

```python
BETA = None
```

###### grass.imaging.images2gif.NeuQuant.BETAGAMMA

```python
BETAGAMMA = None
```

###### grass.imaging.images2gif.NeuQuant.BGCOLOR

```python
BGCOLOR = None
```

###### grass.imaging.images2gif.NeuQuant.CUTNETSIZE

```python
CUTNETSIZE = None
```

###### grass.imaging.images2gif.NeuQuant.GAMMA

```python
GAMMA = None
```

###### grass.imaging.images2gif.NeuQuant.INITALPHA

```python
INITALPHA = None
```

###### grass.imaging.images2gif.NeuQuant.INITBIASRADIUS

```python
INITBIASRADIUS = None
```

###### grass.imaging.images2gif.NeuQuant.INITRAD

```python
INITRAD = None
```

###### grass.imaging.images2gif.NeuQuant.MAXNETPOS

```python
MAXNETPOS = None
```

###### grass.imaging.images2gif.NeuQuant.MAXPRIME

```python
MAXPRIME = PRIME4
```

###### grass.imaging.images2gif.NeuQuant.NCYCLES

```python
NCYCLES = None
```

###### grass.imaging.images2gif.NeuQuant.NETSIZE

```python
NETSIZE = None
```

###### grass.imaging.images2gif.NeuQuant.PRIME1

```python
PRIME1 = 499
```

###### grass.imaging.images2gif.NeuQuant.PRIME2

```python
PRIME2 = 491
```

###### grass.imaging.images2gif.NeuQuant.PRIME3

```python
PRIME3 = 487
```

###### grass.imaging.images2gif.NeuQuant.PRIME4

```python
PRIME4 = 503
```

###### grass.imaging.images2gif.NeuQuant.RADIUSBIAS

```python
RADIUSBIAS = None
```

###### grass.imaging.images2gif.NeuQuant.RADIUSBIASSHIFT

```python
RADIUSBIASSHIFT = None
```

###### grass.imaging.images2gif.NeuQuant.RADIUSDEC

```python
RADIUSDEC = None
```

###### grass.imaging.images2gif.NeuQuant.SPECIALS

```python
SPECIALS = None
```

###### grass.imaging.images2gif.NeuQuant.a_s

```python
a_s = None
```

###### grass.imaging.images2gif.NeuQuant.alterneigh

```python
alterneigh(alpha, rad, i, b, g, r)
```

###### grass.imaging.images2gif.NeuQuant.altersingle

```python
altersingle(alpha, i, b, g, r)
```

Move neuron i towards biased (b, g, r) by factor alpha

###### grass.imaging.images2gif.NeuQuant.bias

```python
bias = None
```

###### grass.imaging.images2gif.NeuQuant.colormap

```python
colormap = None
```

###### grass.imaging.images2gif.NeuQuant.contest

```python
contest(b, g, r)
```

Search for biased BGR values
Finds closest neuron (min dist) and updates self.freq
finds best neuron (min dist-self.bias) and returns position
for frequently chosen neurons, self.freq[i] is high and self.bias[i]
is negative self.bias[i] = self.GAMMA * ((1/self.NETSIZE)-self.freq[i])

###### grass.imaging.images2gif.NeuQuant.convert

```python
convert(*color)
```

###### grass.imaging.images2gif.NeuQuant.fix

```python
fix()
```

###### grass.imaging.images2gif.NeuQuant.freq

```python
freq = None
```

###### grass.imaging.images2gif.NeuQuant.geta

```python
geta(alpha, rad)
```

###### grass.imaging.images2gif.NeuQuant.inxbuild

```python
inxbuild()
```

###### grass.imaging.images2gif.NeuQuant.inxsearch

```python
inxsearch(r, g, b)
```

Search for BGR values 0..255 and return colour index

###### grass.imaging.images2gif.NeuQuant.learn

```python
learn()
```

###### grass.imaging.images2gif.NeuQuant.netindex

```python
netindex = None
```

###### grass.imaging.images2gif.NeuQuant.network

```python
network = None
```

###### grass.imaging.images2gif.NeuQuant.paletteImage

```python
paletteImage()
```

PIL weird interface for making a paletted image: create an image
which already has the palette, and use that in Image.quantize. This
function returns this palette image.

###### grass.imaging.images2gif.NeuQuant.pimage

```python
pimage = None
```

###### grass.imaging.images2gif.NeuQuant.pixels

```python
pixels = np.fromstring(image.tobytes(), np.uint32)
```

###### grass.imaging.images2gif.NeuQuant.quantize

```python
quantize(image)
```

Use a kdtree to quickly find the closest palette colors for the
pixels

:param image:

###### grass.imaging.images2gif.NeuQuant.quantize_with_scipy

```python
quantize_with_scipy(image)
```

###### grass.imaging.images2gif.NeuQuant.quantize_without_scipy

```python
quantize_without_scipy(image)
```

This function can be used if no scipy is available.
It's 7 times slower though.

:param image:

###### grass.imaging.images2gif.NeuQuant.samplefac

```python
samplefac = None
```

###### grass.imaging.images2gif.NeuQuant.setUpArrays

```python
setUpArrays()
```

###### grass.imaging.images2gif.NeuQuant.setconstants

```python
setconstants(samplefac, colors)
```

###### grass.imaging.images2gif.NeuQuant.specialFind

```python
specialFind(b, g, r)
```

###### grass.imaging.images2gif.NeuQuant.writeColourMap

```python
writeColourMap(rgb, outstream)
```

##### grass.imaging.images2gif.PIL_version

```python
PIL_version = PIL.__version__
```

##### grass.imaging.images2gif.checkImages

```python
checkImages(images)
```

Check numpy images and correct intensity range etc.
The same for all movie formats.

:param images:

##### grass.imaging.images2gif.get_cKDTree

```python
get_cKDTree()
```

##### grass.imaging.images2gif.im

```python
im = np.zeros((200, 200), dtype=np.uint8)
```

##### grass.imaging.images2gif.images

```python
images = [im * 1.0, im * 0.8, im * 0.6, im * 0.4, im * 0]
```

##### grass.imaging.images2gif.intToBin

```python
intToBin(i)
```

Integer to two bytes

##### grass.imaging.images2gif.pillow

```python
pillow = True
```

##### grass.imaging.images2gif.readGif

```python
readGif(filename, asNumpy=True)
```

Read images from an animated GIF file. Returns a list of numpy
arrays, or, if asNumpy is false, a list if PIL images.

##### grass.imaging.images2gif.writeGif

```python
writeGif(filename, images, duration=0.1, repeat=True, **kwargs)
```

Write an animated gif from the specified images.
Depending on which PIL library is used, either writeGifVisvis or writeGifPillow
is used here.

:param str filename: the name of the file to write the image to.
:param list images: should be a list consisting of PIL images or numpy
arrays. The latter should be between 0 and 255 for
integer types, and between 0 and 1 for float types.
:param duration: scalar or list of scalars The duration for all frames, or
(if a list) for each frame.
:param repeat: bool or integer The amount of loops. If True, loops infinitetel
:param kwargs: additional parameters for writeGifVisvis

##### grass.imaging.images2gif.writeGifPillow

```python
writeGifPillow(filename, images, duration=0.1, repeat=True)
```

Write an animated gif from the specified images.
Uses native Pillow implementation, which is available since Pillow 3.4.0.

:param str filename: the name of the file to write the image to.
:param list images: should be a list consisting of PIL images or numpy
arrays. The latter should be between 0 and 255 for
integer types, and between 0 and 1 for float types.
:param duration: scalar or list of scalars The duration for all frames, or
(if a list) for each frame.
:param repeat: bool or integer The amount of loops. If True, loops infinitetel

##### grass.imaging.images2gif.writeGifVisvis

```python
writeGifVisvis(filename, images, duration=0.1, repeat=True, dither=False, nq=0, subRectangles=True, dispose=None)
```

Write an animated gif from the specified images.
Uses VisVis implementation. Unfortunately it produces corrupted GIF
with Pillow >= 3.4.0.

:param str filename: the name of the file to write the image to.
:param list images: should be a list consisting of PIL images or numpy
arrays. The latter should be between 0 and 255 for
integer types, and between 0 and 1 for float types.
:param duration: scalar or list of scalars The duration for all frames, or
(if a list) for each frame.
:param repeat: bool or integer The amount of loops. If True, loops infinitely.
:param bool dither: whether to apply dithering
:param int nq: If nonzero, applies the NeuQuant quantization algorithm to
create the color palette. This algorithm is superior, but
slower than the standard PIL algorithm. The value of nq is
the quality parameter. 1 represents the best quality. 10 is
in general a good tradeoff between quality and speed. When
using this option, better results are usually obtained when
subRectangles is False.
:param subRectangles: False, True, or a list of 2-element tuples
Whether to use sub-rectangles. If True, the minimal
rectangle that is required to update each frame is
automatically detected. This can give significant
reductions in file size, particularly if only a part
of the image changes. One can also give a list of x-y
coordinates if you want to do the cropping yourself.
The default is True.
:param int dispose: how to dispose each frame. 1 means that each frame is
to be left in place. 2 means the background color
should be restored after each frame. 3 means the
decoder should restore the previous frame. If
subRectangles==False, the default is 2, otherwise it is 1.

#### grass.imaging.images2ims

Module images2ims

Use PIL to create a series of images.

**Functions:**

- [**checkImages**](#grass.imaging.images2ims.checkImages) – Check numpy images and correct intensity range etc.
- [**readIms**](#grass.imaging.images2ims.readIms) – Read images from a series of images in a single directory. Returns a
- [**writeIms**](#grass.imaging.images2ims.writeIms) – Export movie to a series of image files. If the filenenumber

##### grass.imaging.images2ims.checkImages

```python
checkImages(images)
```

Check numpy images and correct intensity range etc.
The same for all movie formats.

:param images:

##### grass.imaging.images2ims.readIms

```python
readIms(filename, asNumpy=True)
```

Read images from a series of images in a single directory. Returns a
list of numpy arrays, or, if asNumpy is false, a list if PIL images.

:param filename:
:param bool asNumpy:

##### grass.imaging.images2ims.writeIms

```python
writeIms(filename, images)
```

Export movie to a series of image files. If the filenenumber
contains an asterix, a sequence number is introduced at its
location. Otherwise the sequence number is introduced right
before the final dot.

To enable easy creation of a new directory with image files,
it is made sure that the full path exists.

Images should be a list consisting of PIL images or numpy arrays.
The latter should be between 0 and 255 for integer types, and
between 0 and 1 for float types.

:param filename:
:param images:

#### grass.imaging.images2swf

Module images2swf

Provides a function (writeSwf) to store a series of PIL images or numpy
arrays in an SWF movie, that can be played on a wide range of OS's.

This module came into being because I wanted to store a series of images
in a movie that can be viewed by other people, and which I can embed in
flash presentations. For writing AVI or MPEG you really need a c/c++
library, and although the filesize is then very small, the quality is
sometimes not adequate. Besides I'd like to be independent of yet another
package. I tried writing animated gif using PIL (which is widely available),
but the quality is so poor because it only allows for 256 different colors.
[EDIT: thanks to Ant1, now the quality of animated gif isn't so bad!]
I also looked into MNG and APNG, two standards similar to the PNG stanard.
Both standards promise exactly what I need. However, hardly any application
can read those formats, and I cannot import them in flash.

Therefore I decided to check out the swf file format, which is very well
documented. This is the result: a pure python module to create an SWF file
that shows a series of images. The images are stored using the DEFLATE
algorithm (same as PNG and ZIP and which is included in the standard Python
distribution). As this compression algorithm is much more effective than
that used in GIF images, we obtain better quality (24 bit colors + alpha
channel) while still producesing smaller files (a test showed ~75%).
Although SWF also allows for JPEG compression, doing so would probably
require a third party library (because encoding JPEG is much harder).

This module requires Python 2.x and numpy.

sources and tools:

- SWF on wikipedia
- Adobes "SWF File Format Specification" version 10
  (http://www.adobe.com/devnet/swf/pdf/swf_file_format_spec_v10.pdf)
- swftools (swfdump in specific) for debugging
- iwisoft swf2avi can be used to convert swf to avi/mpg/flv with really
  good quality, while file size is reduced with factors 20-100.
  A good program in my opinion. The free version has the limitation
  of a watermark in the upper left corner.

**Classes:**

- [**BitArray**](#grass.imaging.images2swf.BitArray) – Dynamic array of bits that automatically resizes
- [**BitmapTag**](#grass.imaging.images2swf.BitmapTag) –
- [**ControlTag**](#grass.imaging.images2swf.ControlTag) –
- [**DefinitionTag**](#grass.imaging.images2swf.DefinitionTag) –
- [**DoActionTag**](#grass.imaging.images2swf.DoActionTag) –
- [**FileAttributesTag**](#grass.imaging.images2swf.FileAttributesTag) –
- [**PlaceObjectTag**](#grass.imaging.images2swf.PlaceObjectTag) –
- [**SetBackgroundTag**](#grass.imaging.images2swf.SetBackgroundTag) – Set the color in 0-255, or 0-1 (if floats given).
- [**ShapeTag**](#grass.imaging.images2swf.ShapeTag) –
- [**ShowFrameTag**](#grass.imaging.images2swf.ShowFrameTag) –
- [**Tag**](#grass.imaging.images2swf.Tag) –

**Functions:**

- [**bitsToInt**](#grass.imaging.images2swf.bitsToInt) –
- [**buildFile**](#grass.imaging.images2swf.buildFile) – Give the given file (as bytes) a header.
- [**checkImages**](#grass.imaging.images2swf.checkImages) – Check numpy images and correct intensity range etc.
- [**floatsToBits**](#grass.imaging.images2swf.floatsToBits) – Given a few (signed) numbers, convert them to bits,
- [**getTypeAndLen**](#grass.imaging.images2swf.getTypeAndLen) – bb should be 6 bytes at least
- [**intToBits**](#grass.imaging.images2swf.intToBits) – convert int to a string of bits (0's and 1's in a string),
- [**intToUint16**](#grass.imaging.images2swf.intToUint16) –
- [**intToUint32**](#grass.imaging.images2swf.intToUint32) –
- [**intToUint8**](#grass.imaging.images2swf.intToUint8) –
- [**readSwf**](#grass.imaging.images2swf.readSwf) – Read all images from an SWF (shockwave flash) file. Returns a list
- [**signedIntToBits**](#grass.imaging.images2swf.signedIntToBits) – convert signed int to a string of bits (0's and 1's in a string),
- [**twitsToBits**](#grass.imaging.images2swf.twitsToBits) – Given a few (signed) numbers, store them
- [**writeSwf**](#grass.imaging.images2swf.writeSwf) – Write an swf-file from the specified images. If repeat is False,

**Attributes:**

- [**binary_type**](#grass.imaging.images2swf.binary_type) –
- [**class_types**](#grass.imaging.images2swf.class_types) –
- [**integer_types**](#grass.imaging.images2swf.integer_types) –
- [**string_types**](#grass.imaging.images2swf.string_types) –
- [**text_type**](#grass.imaging.images2swf.text_type) –

##### grass.imaging.images2swf.BitArray

```python
BitArray(initvalue=None)
```

Dynamic array of bits that automatically resizes
with factors of two.
Append bits using .Append() or +=
You can reverse bits using .Reverse()

**Functions:**

- [**Append**](#grass.imaging.images2swf.BitArray.Append) –
- [**Reverse**](#grass.imaging.images2swf.BitArray.Reverse) – In-place reverse.
- [**ToBytes**](#grass.imaging.images2swf.BitArray.ToBytes) – Convert to bytes. If necessary,

**Attributes:**

- [**data**](#grass.imaging.images2swf.BitArray.data) –

###### grass.imaging.images2swf.BitArray.Append

```python
Append(bits)
```

###### grass.imaging.images2swf.BitArray.Reverse

```python
Reverse()
```

In-place reverse.

###### grass.imaging.images2swf.BitArray.ToBytes

```python
ToBytes()
```

Convert to bytes. If necessary,
zeros are padded to the end (right side).

###### grass.imaging.images2swf.BitArray.data

```python
data = np.zeros((16,), dtype=np.uint8)
```

##### grass.imaging.images2swf.BitmapTag

```python
BitmapTag(im)
```

Bases: <code>[DefinitionTag](#grass.imaging.images2swf.DefinitionTag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.BitmapTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.BitmapTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.BitmapTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.BitmapTag.ProcessTag) –

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.BitmapTag.bytes) –
- [**counter**](#grass.imaging.images2swf.BitmapTag.counter) –
- [**id**](#grass.imaging.images2swf.BitmapTag.id) –
- [**imshape**](#grass.imaging.images2swf.BitmapTag.imshape) –
- [**tagtype**](#grass.imaging.images2swf.BitmapTag.tagtype) –

###### grass.imaging.images2swf.BitmapTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.BitmapTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.BitmapTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.BitmapTag.ProcessTag

```python
ProcessTag()
```

###### grass.imaging.images2swf.BitmapTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.BitmapTag.counter

```python
counter = 0
```

###### grass.imaging.images2swf.BitmapTag.id

```python
id = DefinitionTag.counter
```

###### grass.imaging.images2swf.BitmapTag.imshape

```python
imshape = im.shape
```

###### grass.imaging.images2swf.BitmapTag.tagtype

```python
tagtype = 36
```

##### grass.imaging.images2swf.ControlTag

```python
ControlTag()
```

Bases: <code>[Tag](#grass.imaging.images2swf.Tag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.ControlTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.ControlTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.ControlTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.ControlTag.ProcessTag) – Implement this to create the tag.

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.ControlTag.bytes) –
- [**tagtype**](#grass.imaging.images2swf.ControlTag.tagtype) –

###### grass.imaging.images2swf.ControlTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.ControlTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.ControlTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.ControlTag.ProcessTag

```python
ProcessTag()
```

Implement this to create the tag.

###### grass.imaging.images2swf.ControlTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.ControlTag.tagtype

```python
tagtype = -1
```

##### grass.imaging.images2swf.DefinitionTag

```python
DefinitionTag()
```

Bases: <code>[Tag](#grass.imaging.images2swf.Tag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.DefinitionTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.DefinitionTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.DefinitionTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.DefinitionTag.ProcessTag) – Implement this to create the tag.

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.DefinitionTag.bytes) –
- [**counter**](#grass.imaging.images2swf.DefinitionTag.counter) –
- [**id**](#grass.imaging.images2swf.DefinitionTag.id) –
- [**tagtype**](#grass.imaging.images2swf.DefinitionTag.tagtype) –

###### grass.imaging.images2swf.DefinitionTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.DefinitionTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.DefinitionTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.DefinitionTag.ProcessTag

```python
ProcessTag()
```

Implement this to create the tag.

###### grass.imaging.images2swf.DefinitionTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.DefinitionTag.counter

```python
counter = 0
```

###### grass.imaging.images2swf.DefinitionTag.id

```python
id = DefinitionTag.counter
```

###### grass.imaging.images2swf.DefinitionTag.tagtype

```python
tagtype = -1
```

##### grass.imaging.images2swf.DoActionTag

```python
DoActionTag(action='stop')
```

Bases: <code>[Tag](#grass.imaging.images2swf.Tag)</code>

**Functions:**

- [**Append**](#grass.imaging.images2swf.DoActionTag.Append) –
- [**GetTag**](#grass.imaging.images2swf.DoActionTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.DoActionTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.DoActionTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.DoActionTag.ProcessTag) –

**Attributes:**

- [**actions**](#grass.imaging.images2swf.DoActionTag.actions) –
- [**bytes**](#grass.imaging.images2swf.DoActionTag.bytes) –
- [**tagtype**](#grass.imaging.images2swf.DoActionTag.tagtype) –

###### grass.imaging.images2swf.DoActionTag.Append

```python
Append(action)
```

###### grass.imaging.images2swf.DoActionTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.DoActionTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.DoActionTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.DoActionTag.ProcessTag

```python
ProcessTag()
```

###### grass.imaging.images2swf.DoActionTag.actions

```python
actions = [action]
```

###### grass.imaging.images2swf.DoActionTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.DoActionTag.tagtype

```python
tagtype = 12
```

##### grass.imaging.images2swf.FileAttributesTag

```python
FileAttributesTag()
```

Bases: <code>[ControlTag](#grass.imaging.images2swf.ControlTag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.FileAttributesTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.FileAttributesTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.FileAttributesTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.FileAttributesTag.ProcessTag) –

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.FileAttributesTag.bytes) –
- [**tagtype**](#grass.imaging.images2swf.FileAttributesTag.tagtype) –

###### grass.imaging.images2swf.FileAttributesTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.FileAttributesTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.FileAttributesTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.FileAttributesTag.ProcessTag

```python
ProcessTag()
```

###### grass.imaging.images2swf.FileAttributesTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.FileAttributesTag.tagtype

```python
tagtype = 69
```

##### grass.imaging.images2swf.PlaceObjectTag

```python
PlaceObjectTag(depth, idToPlace=None, xy=(0, 0), move=False)
```

Bases: <code>[ControlTag](#grass.imaging.images2swf.ControlTag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.PlaceObjectTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.PlaceObjectTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.PlaceObjectTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.PlaceObjectTag.ProcessTag) –

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.PlaceObjectTag.bytes) –
- [**depth**](#grass.imaging.images2swf.PlaceObjectTag.depth) –
- [**idToPlace**](#grass.imaging.images2swf.PlaceObjectTag.idToPlace) –
- [**move**](#grass.imaging.images2swf.PlaceObjectTag.move) –
- [**tagtype**](#grass.imaging.images2swf.PlaceObjectTag.tagtype) –
- [**xy**](#grass.imaging.images2swf.PlaceObjectTag.xy) –

###### grass.imaging.images2swf.PlaceObjectTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.PlaceObjectTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.PlaceObjectTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.PlaceObjectTag.ProcessTag

```python
ProcessTag()
```

###### grass.imaging.images2swf.PlaceObjectTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.PlaceObjectTag.depth

```python
depth = depth
```

###### grass.imaging.images2swf.PlaceObjectTag.idToPlace

```python
idToPlace = idToPlace
```

###### grass.imaging.images2swf.PlaceObjectTag.move

```python
move = move
```

###### grass.imaging.images2swf.PlaceObjectTag.tagtype

```python
tagtype = 26
```

###### grass.imaging.images2swf.PlaceObjectTag.xy

```python
xy = xy
```

##### grass.imaging.images2swf.SetBackgroundTag

```python
SetBackgroundTag(*rgb)
```

Bases: <code>[ControlTag](#grass.imaging.images2swf.ControlTag)</code>

Set the color in 0-255, or 0-1 (if floats given).

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.SetBackgroundTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.SetBackgroundTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.SetBackgroundTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.SetBackgroundTag.ProcessTag) –

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.SetBackgroundTag.bytes) –
- [**rgb**](#grass.imaging.images2swf.SetBackgroundTag.rgb) –
- [**tagtype**](#grass.imaging.images2swf.SetBackgroundTag.tagtype) –

###### grass.imaging.images2swf.SetBackgroundTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.SetBackgroundTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.SetBackgroundTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.SetBackgroundTag.ProcessTag

```python
ProcessTag()
```

###### grass.imaging.images2swf.SetBackgroundTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.SetBackgroundTag.rgb

```python
rgb = rgb
```

###### grass.imaging.images2swf.SetBackgroundTag.tagtype

```python
tagtype = 9
```

##### grass.imaging.images2swf.ShapeTag

```python
ShapeTag(bitmapId, xy, wh)
```

Bases: <code>[DefinitionTag](#grass.imaging.images2swf.DefinitionTag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.ShapeTag.GetTag) – Calls processTag and attaches the header.
- [**MakeEndShapeRecord**](#grass.imaging.images2swf.ShapeTag.MakeEndShapeRecord) –
- [**MakeMatrixRecord**](#grass.imaging.images2swf.ShapeTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.ShapeTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**MakeStraightEdgeRecord**](#grass.imaging.images2swf.ShapeTag.MakeStraightEdgeRecord) –
- [**MakeStyleChangeRecord**](#grass.imaging.images2swf.ShapeTag.MakeStyleChangeRecord) –
- [**ProcessTag**](#grass.imaging.images2swf.ShapeTag.ProcessTag) – Returns a defineshape tag. with a bitmap fill

**Attributes:**

- [**bitmapId**](#grass.imaging.images2swf.ShapeTag.bitmapId) –
- [**bytes**](#grass.imaging.images2swf.ShapeTag.bytes) –
- [**counter**](#grass.imaging.images2swf.ShapeTag.counter) –
- [**id**](#grass.imaging.images2swf.ShapeTag.id) –
- [**tagtype**](#grass.imaging.images2swf.ShapeTag.tagtype) –
- [**wh**](#grass.imaging.images2swf.ShapeTag.wh) –
- [**xy**](#grass.imaging.images2swf.ShapeTag.xy) –

###### grass.imaging.images2swf.ShapeTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.ShapeTag.MakeEndShapeRecord

```python
MakeEndShapeRecord()
```

###### grass.imaging.images2swf.ShapeTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.ShapeTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.ShapeTag.MakeStraightEdgeRecord

```python
MakeStraightEdgeRecord(*dxdy)
```

###### grass.imaging.images2swf.ShapeTag.MakeStyleChangeRecord

```python
MakeStyleChangeRecord(lineStyle=None, fillStyle=None, moveTo=None)
```

###### grass.imaging.images2swf.ShapeTag.ProcessTag

```python
ProcessTag()
```

Returns a defineshape tag. with a bitmap fill

###### grass.imaging.images2swf.ShapeTag.bitmapId

```python
bitmapId = bitmapId
```

###### grass.imaging.images2swf.ShapeTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.ShapeTag.counter

```python
counter = 0
```

###### grass.imaging.images2swf.ShapeTag.id

```python
id = DefinitionTag.counter
```

###### grass.imaging.images2swf.ShapeTag.tagtype

```python
tagtype = 2
```

###### grass.imaging.images2swf.ShapeTag.wh

```python
wh = wh
```

###### grass.imaging.images2swf.ShapeTag.xy

```python
xy = xy
```

##### grass.imaging.images2swf.ShowFrameTag

```python
ShowFrameTag()
```

Bases: <code>[ControlTag](#grass.imaging.images2swf.ControlTag)</code>

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.ShowFrameTag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.ShowFrameTag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.ShowFrameTag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.ShowFrameTag.ProcessTag) –

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.ShowFrameTag.bytes) –
- [**tagtype**](#grass.imaging.images2swf.ShowFrameTag.tagtype) –

###### grass.imaging.images2swf.ShowFrameTag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.ShowFrameTag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.ShowFrameTag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.ShowFrameTag.ProcessTag

```python
ProcessTag()
```

###### grass.imaging.images2swf.ShowFrameTag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.ShowFrameTag.tagtype

```python
tagtype = 1
```

##### grass.imaging.images2swf.Tag

```python
Tag()
```

**Functions:**

- [**GetTag**](#grass.imaging.images2swf.Tag.GetTag) – Calls processTag and attaches the header.
- [**MakeMatrixRecord**](#grass.imaging.images2swf.Tag.MakeMatrixRecord) –
- [**MakeRectRecord**](#grass.imaging.images2swf.Tag.MakeRectRecord) – Simply uses makeCompactArray to produce
- [**ProcessTag**](#grass.imaging.images2swf.Tag.ProcessTag) – Implement this to create the tag.

**Attributes:**

- [**bytes**](#grass.imaging.images2swf.Tag.bytes) –
- [**tagtype**](#grass.imaging.images2swf.Tag.tagtype) –

###### grass.imaging.images2swf.Tag.GetTag

```python
GetTag()
```

Calls processTag and attaches the header.

###### grass.imaging.images2swf.Tag.MakeMatrixRecord

```python
MakeMatrixRecord(scale_xy=None, rot_xy=None, trans_xy=None)
```

###### grass.imaging.images2swf.Tag.MakeRectRecord

```python
MakeRectRecord(xmin, xmax, ymin, ymax)
```

Simply uses makeCompactArray to produce
a RECT Record.

###### grass.imaging.images2swf.Tag.ProcessTag

```python
ProcessTag()
```

Implement this to create the tag.

###### grass.imaging.images2swf.Tag.bytes

```python
bytes = binary_type()
```

###### grass.imaging.images2swf.Tag.tagtype

```python
tagtype = -1
```

##### grass.imaging.images2swf.binary_type

```python
binary_type = bytes
```

##### grass.imaging.images2swf.bitsToInt

```python
bitsToInt(bb, n=8)
```

##### grass.imaging.images2swf.buildFile

```python
buildFile(fp, taglist, nframes=1, framesize=(500, 500), fps=10, version=8)
```

Give the given file (as bytes) a header.

##### grass.imaging.images2swf.checkImages

```python
checkImages(images)
```

Check numpy images and correct intensity range etc.
The same for all movie formats.

##### grass.imaging.images2swf.class_types

```python
class_types = (type,)
```

##### grass.imaging.images2swf.floatsToBits

```python
floatsToBits(arr)
```

Given a few (signed) numbers, convert them to bits,
stored as FB (float bit values). We always use 16.16.
Negative numbers are not (yet) possible, because I don't
know how the're implemented (ambiguity).

##### grass.imaging.images2swf.getTypeAndLen

```python
getTypeAndLen(bb)
```

bb should be 6 bytes at least
Return (type, length, length_of_full_tag)

##### grass.imaging.images2swf.intToBits

```python
intToBits(i, n=None)
```

convert int to a string of bits (0's and 1's in a string),
pad to n elements. Convert back using int(ss,2).

##### grass.imaging.images2swf.intToUint16

```python
intToUint16(i)
```

##### grass.imaging.images2swf.intToUint32

```python
intToUint32(i)
```

##### grass.imaging.images2swf.intToUint8

```python
intToUint8(i)
```

##### grass.imaging.images2swf.integer_types

```python
integer_types = (int,)
```

##### grass.imaging.images2swf.readSwf

```python
readSwf(filename, asNumpy=True)
```

Read all images from an SWF (shockwave flash) file. Returns a list
of numpy arrays, or, if asNumpy is false, a list if PIL images.

Limitation: only read the PNG encoded images (not the JPG encoded ones).

##### grass.imaging.images2swf.signedIntToBits

```python
signedIntToBits(i, n=None)
```

convert signed int to a string of bits (0's and 1's in a string),
pad to n elements. Negative numbers are stored in 2's complement bit
patterns, thus positive numbers always start with a 0.

##### grass.imaging.images2swf.string_types

```python
string_types = (str,)
```

##### grass.imaging.images2swf.text_type

```python
text_type = str
```

##### grass.imaging.images2swf.twitsToBits

```python
twitsToBits(arr)
```

Given a few (signed) numbers, store them
as compactly as possible in the wat specifief by the swf format.
The numbers are multiplied by 20, assuming they
are twits.
Can be used to make the RECT record.

##### grass.imaging.images2swf.writeSwf

```python
writeSwf(filename, images, duration=0.1, repeat=True)
```

Write an swf-file from the specified images. If repeat is False,
the movie is finished with a stop action. Duration may also
be a list with durations for each frame (note that the duration
for each frame is always an integer amount of the minimum duration.)

Images should be a list consisting of PIL images or numpy arrays.
The latter should be between 0 and 255 for integer types, and
between 0 and 1 for float types.

#### grass.imaging.operations

Image non-geospatial operations and manipulations

Note: Functions in this module are experimental and are not considered
a stable API, i.e. may change in future releases of GRASS GIS.

It heavily relies on PIL but unlike PIL, the functions operate on
files instead of PIL Image objects (which are used internally).
These functions are convenient for post-processing outputs from GRASS
modules, e.g. after rendering. However, if you have multiple operations
you may want to consider using PIL directly for efficiency (to avoid
writing and reading from the files).

# Usage

Use keyword arguments for all parameters other than those for input,
output, and format. All function provide reasonable defaults if possible,
but note that they may not be applicable to you case or when developing
a general tool.

> > > import grass.imaging.operations as iop

> > > # replace white color in the image by 100% transparency
> > >
> > > iop.change_rbg_to_transparent("map.png", color=(255, 255, 255))

> > > # crop the image in place
> > >
> > > iop.crop_image("map.png")

> > > # create a new image with inverted colors of the original image
> > >
> > > iop.invert_image_colors("map.png", "map_inverted.png")

> > > # create a thumbnail of the original image
> > >
> > > iop.thumbnail_image("map.png", "map_thumbnail.png", size=(64, 64))

# Error handling

When PIL or a required submodule is not available, a RuntimeError
exception is raised with a message mentioning the missing dependency.
Additionally, any of the exceptions raised by PIL may be raised too,
for example, when the file is not found.

# Authors, copyright and license

(C) 2018 by Vaclav Petras and the GRASS Development Team

This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Vaclav Petras <wenzeslaus gmail com>

**Functions:**

- [**change_rbg_to_transparent**](#grass.imaging.operations.change_rbg_to_transparent) – Make a specified RGB color in the image transparent
- [**crop_image**](#grass.imaging.operations.crop_image) – Crop to non-zero area of the image
- [**invert_image_colors**](#grass.imaging.operations.invert_image_colors) – Invert colors in the image
- [**thumbnail_image**](#grass.imaging.operations.thumbnail_image) – Create a thumbnail of an image

##### grass.imaging.operations.change_rbg_to_transparent

```python
change_rbg_to_transparent(input_file, output_file=None, color='white', alpha=0, format=None)
```

Make a specified RGB color in the image transparent

The color is specified as a RGB tuple (triplet) or string 'white'
or 'black'. Note that GRASS color names are not supported.
The white (255, 255, 255) is replaced by default but each application
is encouraged to consider color to use and explicitly specify it.

:param input_file: Name of the file to manipulate
:param color: Color to be replaced by transparency (tuple of three ints)
:param alpha: Level of opacity (0 fully transparent, 255 fully opaque)
:param output_file: filename for the new file (same as input by default)
:param format: format to be used new file (if different from extension)

##### grass.imaging.operations.crop_image

```python
crop_image(input_file, output_file=None, format=None)
```

Crop to non-zero area of the image

:param input_file: Name of the file to manipulate
:param output_file: filename for the new file (same as input by default)
:param format: format to be used new file (if different from extension)

##### grass.imaging.operations.invert_image_colors

```python
invert_image_colors(input_file, output_file=None, format=None)
```

Invert colors in the image

The alpha channel, if present, is untouched by this function.

:param input_file: Name of the file to manipulate
:param output_file: filename for the new file (same as input by default)
:param format: format to be used new file (if different from extension)

##### grass.imaging.operations.thumbnail_image

```python
thumbnail_image(input_file, output_file=None, size=(200, 200), format=None)
```

Create a thumbnail of an image

The image aspect ratio is kept and its height and width are adjusted
accordingly to fit the `size` parameter.

:param input_file: Name of the file to manipulate
:param size: Size of the new image in pixels as tuple
:param output_file: filename for the new file (same as input by default)
:param format: format to be used new file (if different from extension)

#### grass.imaging.readAvi

```python
readAvi(filename, asNumpy=True)
```

Read images from an AVI (or MPG) movie.

Requires the "ffmpeg" application:

- Most linux users can install using their package manager
- There is a windows installer on the visvis website

:param str filename: name of input movie file
:param bool asNumpy:

#### grass.imaging.readGif

```python
readGif(filename, asNumpy=True)
```

Read images from an animated GIF file. Returns a list of numpy
arrays, or, if asNumpy is false, a list if PIL images.

#### grass.imaging.readIms

```python
readIms(filename, asNumpy=True)
```

Read images from a series of images in a single directory. Returns a
list of numpy arrays, or, if asNumpy is false, a list if PIL images.

:param filename:
:param bool asNumpy:

#### grass.imaging.readSwf

```python
readSwf(filename, asNumpy=True)
```

Read all images from an SWF (shockwave flash) file. Returns a list
of numpy arrays, or, if asNumpy is false, a list if PIL images.

Limitation: only read the PNG encoded images (not the JPG encoded ones).

#### grass.imaging.writeAvi

```python
writeAvi(filename, images, duration=0.1, encoding='mpeg4', inputOptions='', outputOptions='', bg_task=False)
```

Export movie to a AVI file, which is encoded with the given
encoding. Hint for Windows users: the 'msmpeg4v2' codec is
natively supported on Windows.

Images should be a list consisting of PIL images or numpy arrays.
The latter should be between 0 and 255 for integer types, and
between 0 and 1 for float types.

Requires the "ffmpeg" application:

- Most linux users can install using their package manager
- There is a windows installer on the visvis website

:param str filename: output filename
:param images:
:param float duration:
:param str encoding: the encoding type
:param inputOptions:
:param outputOptions:
:param bool bg_task: if thread background task, not raise but
return error message

:return str: error message

#### grass.imaging.writeGif

```python
writeGif(filename, images, duration=0.1, repeat=True, **kwargs)
```

Write an animated gif from the specified images.
Depending on which PIL library is used, either writeGifVisvis or writeGifPillow
is used here.

:param str filename: the name of the file to write the image to.
:param list images: should be a list consisting of PIL images or numpy
arrays. The latter should be between 0 and 255 for
integer types, and between 0 and 1 for float types.
:param duration: scalar or list of scalars The duration for all frames, or
(if a list) for each frame.
:param repeat: bool or integer The amount of loops. If True, loops infinitetel
:param kwargs: additional parameters for writeGifVisvis

#### grass.imaging.writeIms

```python
writeIms(filename, images)
```

Export movie to a series of image files. If the filenenumber
contains an asterix, a sequence number is introduced at its
location. Otherwise the sequence number is introduced right
before the final dot.

To enable easy creation of a new directory with image files,
it is made sure that the full path exists.

Images should be a list consisting of PIL images or numpy arrays.
The latter should be between 0 and 255 for integer types, and
between 0 and 1 for float types.

:param filename:
:param images:

#### grass.imaging.writeSwf

```python
writeSwf(filename, images, duration=0.1, repeat=True)
```

Write an swf-file from the specified images. If repeat is False,
the movie is finished with a stop action. Duration may also
be a list with durations for each frame (note that the duration
for each frame is always an integer amount of the minimum duration.)

Images should be a list consisting of PIL images or numpy arrays.
The latter should be between 0 and 255 for integer types, and
between 0 and 1 for float types.

### grass.jupyter

A convenient GRASS GIS interface for Jupyter notebooks.

Python is a great tool for data science and scientific computing. Jupyter\_ is an
environment with computational notebooks which makes it even better tool for
analysis and workflow prototyping. Computational notebooks are documents combining
code, text, and results such as figures and tables. JupyterLab is an environment where
you interact with all these parts. You can install it locally on your machine or
use it online from some service provider.

The *grass.jupyter* subpackage improves the integration of GRASS GIS and Jupyter
notebooks compared to the standard Python API. The original version was written
as part of Google Summer of Code in 2021 and experimental version was included in
GRASS GIS 8.0. Since then, much more development happened adding better session
handling and rendering of additional data types.

# Usage

To start using it in a notebook, import the top level package with a convenient alias,
such as *gj*, like this::

> > > import grass.jupyter as gj

.. note::
To import the package, you need to tell Python where the GRASS GIS Python package
is unless you manually set this on your system or in the command line. Please, refer
to the example notebooks linked below for an example of the full workflow.

.. note::
On Windows, there is no system Python and GRASS GIS needs to use its own Python.
Jupyter needs to be installed into that Python. Please, refer to the wiki\_
for Windows-specific instructions.

To use existing data, we start a GRASS session in an existing mapset::

> > > gj.init("grassdata/nc_basic_spm_grass7/user1")

.. note::
Contrary to typical command line / GUI module usage, grass.jupyter
enables output overwrite by default to align with behaviour of other
Python packages and to allow repeated executions of the same cells and
of the whole notebook. The default command line behaviour can be
restored by setting GRASS_OVERWRITE environmental variable to "0" after
`gj.init()` call: `os.environ["GRASS_OVERWRITE"] = "0"`.

All classes and functions for interaction in notebooks are now available under *gj*,
for example we can display a map with a selected raster and vector::

> > > streams_map = gj.Map()
> > > streams_map.d_rast(map="elevation")
> > > streams_map.d_vect(map="streams")
> > > streams_map.show()

Other classes and functions are described below and in the example notebooks.
Static HTML versions of the example notebooks are available on GitHub\_
and interactive ones with live code are available on Binder:

.. image:: https://mybinder.org/badge_logo.svg
:target:
https://mybinder.org/v2/gh/OSGeo/grass/main?urlpath=lab%2Ftree%2Fdoc%2Fexamples%2Fnotebooks%2Fjupyter_example.ipynb

There are also internal classes and functions which are not guaranteed to have
as stable API, although they are available through their specific submodules.
For all standard cases, use only classes and function imported with
`import grass.jupyter as gj`. If in doubt, use `dir(gj)` to see available objects.
Both the objects in submodules and names of submodules may change in the future.

.. note::
Although most of the functionality is general, the defaults, resource management,
and other behavior assumes usage in an interactive notebook, so using the
functionality in other contexts (e.g. a script) may result in unexpected behavior.
Consult the documentation or mailing list if in doubt. Suggest generalized
functionality using issues and pull requests.

.. versionadded:: 8.2

# Authors

Caitlin Haedrich, NC State University, Center for Geospatial Analytics

Vaclav Petras, NC State University, Center for Geospatial Analytics

Anna Petrasova, NC State University, Center for Geospatial Analytics

Initial development was done by Caitlin Haedrich during Google Summer of Code in 2021
mentored by Vaclav Petras, Stephan Blumentrath, and Helena Mitasova.

.. \_Jupyter: https://jupyter.org/
.. \_wiki: https://grasswiki.osgeo.org/wiki/GRASS_GIS_Jupyter_notebooks
.. \_GitHub: https://github.com/OSGeo/grass/blob/main/doc/examples/notebooks/jupyter_example.ipynb

**Modules:**

- [**baseseriesmap**](#grass.jupyter.baseseriesmap) – Base class for SeriesMap and TimeSeriesMap
- [**interactivemap**](#grass.jupyter.interactivemap) – Interactive visualizations map with folium or ipyleaflet
- [**map**](#grass.jupyter.map) – 2D rendering and display functionality
- [**map3d**](#grass.jupyter.map3d) – Render 3D visualizations
- [**region**](#grass.jupyter.region) – Manage computational or display region settings for display (render) classes.
- [**reprojection_renderer**](#grass.jupyter.reprojection_renderer) – Reprojects rasters to Pseudo-Mercator and vectors to WGS84. Exports reprojected
- [**seriesmap**](#grass.jupyter.seriesmap) – Create and display visualizations for a series of rasters.
- [**setup**](#grass.jupyter.setup) – Initialization GRASS GIS session and its finalization
- [**timeseriesmap**](#grass.jupyter.timeseriesmap) – Create and display visualizations for space-time datasets.
- [**utils**](#grass.jupyter.utils) – Utility functions warpping existing processes in a suitable way

**Classes:**

- [**InteractiveMap**](#grass.jupyter.InteractiveMap) – This class creates interactive GRASS maps with folium or ipyleaflet.
- [**Map**](#grass.jupyter.Map) – Map creates and displays GRASS maps in
- [**Map3D**](#grass.jupyter.Map3D) – Creates and displays 3D visualization using GRASS GIS 3D rendering engine NVIZ.
- [**Raster**](#grass.jupyter.Raster) – Overlays rasters on a folium or ipyleaflet map.
- [**SeriesMap**](#grass.jupyter.SeriesMap) – Creates visualizations from a series of rasters or vectors in Jupyter
- [**TimeSeriesMap**](#grass.jupyter.TimeSeriesMap) – Creates visualizations of time-space raster and vector datasets in Jupyter
- [**Vector**](#grass.jupyter.Vector) – Adds vectors to a folium or ipyleaflet map.

**Functions:**

- [**init**](#grass.jupyter.init) – Initiates a GRASS session and sets GRASS environment variables.

#### grass.jupyter.InteractiveMap

```python
InteractiveMap(width=400, height=400, tiles='CartoDB positron', API_key=None, use_region=False, saved_region=None, map_backend=None)
```

This class creates interactive GRASS maps with folium or ipyleaflet.

Basic Usage:

> > > m = InteractiveMap()
> > > m.add_vector("streams")
> > > m.add_raster("elevation")
> > > m.show()

**Functions:**

- [**add_layer_control**](#grass.jupyter.InteractiveMap.add_layer_control) – Add layer control to display.
- [**add_raster**](#grass.jupyter.InteractiveMap.add_raster) – Imports raster into temporary WGS84 location,
- [**add_vector**](#grass.jupyter.InteractiveMap.add_vector) – Imports vector into temporary WGS84 location, re-formats to a GeoJSON and
- [**save**](#grass.jupyter.InteractiveMap.save) – Save map as an html map.
- [**setup_computational_region_interface**](#grass.jupyter.InteractiveMap.setup_computational_region_interface) – Sets up the interface for users to draw and
- [**setup_drawing_interface**](#grass.jupyter.InteractiveMap.setup_drawing_interface) – Sets up the drawing interface for users
- [**setup_query_interface**](#grass.jupyter.InteractiveMap.setup_query_interface) – Sets up the query button interface.
- [**show**](#grass.jupyter.InteractiveMap.show) – This function returns a folium figure or ipyleaflet map object

**Attributes:**

- [**height**](#grass.jupyter.InteractiveMap.height) –
- [**layer_control_object**](#grass.jupyter.InteractiveMap.layer_control_object) –
- [**map**](#grass.jupyter.InteractiveMap.map) –
- [**raster_name**](#grass.jupyter.InteractiveMap.raster_name) –
- [**region**](#grass.jupyter.InteractiveMap.region) –
- [**region_rectangle**](#grass.jupyter.InteractiveMap.region_rectangle) –
- [**vector_name**](#grass.jupyter.InteractiveMap.vector_name) –
- [**width**](#grass.jupyter.InteractiveMap.width) –

Creates a blank folium/ipyleaflet map centered on g.region.

If map_backend is not specified, InteractiveMap tries to import
ipyleaflet first, then folium if it fails. The backend can be
specified explicitely with valid values "folium" and "ipyleaflet" .

In case of folium backend, tiles parameter is passed directly
to folium.Map() which supports several built-in tilesets
(including "OpenStreetMap", "Stamen Toner", "Stamen Terrain",
"Stamen Watercolor", "Mapbox Bright", "Mapbox Control Room", "CartoDB positron",
"CartoDB dark_matter") as well as custom tileset URL (i.e.
"http://{s}.yourtiles.com/{z}/{x}/{y}.png"). For more information, visit
folium documentation:
https://python-visualization.github.io/folium/modules.html
In case of ipyleaflet, only the tileset name and not the URL is
currently supported.

Raster and vector data are always reprojected to Pseudo-Mercator.
With use_region=True or saved_region=myregion, the region extent
is reprojected and the number of rows and columns of that region
is kept the same. This region is then used for reprojection.
By default, use_region is False, which results in the
reprojection of the entire raster in its native resolution.
The reprojected resolution is estimated with r.proj.
Vector data are always reprojected without any clipping,
i.e., region options don't do anything.

:param int height: height in pixels of figure (default 400)
:param int width: width in pixels of figure (default 400)
:param str tiles: map tileset to use
:param str API_key: API key for Mapbox or Cloudmade tiles
:param bool use_region: use computational region of current mapset
:param str saved_region: name of saved computation region
:param str map_backend: "ipyleaflet" or "folium" or None

##### grass.jupyter.InteractiveMap.add_layer_control

```python
add_layer_control(**kwargs)
```

Add layer control to display.

A Layer Control is added by default. Call this function to customize
layer control object. Accepts keyword arguments to be passed to leaflet
layer control object

##### grass.jupyter.InteractiveMap.add_raster

```python
add_raster(name, title=None, **kwargs)
```

Imports raster into temporary WGS84 location,
exports as png and overlays on a map.

Color table for the raster can be modified with `r.colors` before calling
this function.

.. note:: This will only work if the raster is located in the current mapset.
To change the color table of a raster located outside the current mapset,
switch to that mapset with `g.mapset`, modify the color table with `r.color`
then switch back to the initial mapset and run this function.

:param str name: name of raster to add to display; positional-only parameter
:param str title: raster name for layer control
:param kwargs: keyword arguments passed to image overlay

##### grass.jupyter.InteractiveMap.add_vector

```python
add_vector(name, title=None, **kwargs)
```

Imports vector into temporary WGS84 location, re-formats to a GeoJSON and
adds to map.

:param str name: name of vector to be added to map;
positional-only parameter
:param str title: vector name for layer control
:param kwargs: keyword arguments passed to GeoJSON overlay

##### grass.jupyter.InteractiveMap.height

```python
height = int(height)
```

##### grass.jupyter.InteractiveMap.layer_control_object

```python
layer_control_object = None
```

##### grass.jupyter.InteractiveMap.map

```python
map = self._ipyleaflet.Map(basemap=basemap, layout=layout, scroll_wheel_zoom=True)
```

##### grass.jupyter.InteractiveMap.raster_name

```python
raster_name = []
```

##### grass.jupyter.InteractiveMap.region

```python
region = None
```

##### grass.jupyter.InteractiveMap.region_rectangle

```python
region_rectangle = None
```

##### grass.jupyter.InteractiveMap.save

```python
save(filename)
```

Save map as an html map.

:param str filename: name of html file

##### grass.jupyter.InteractiveMap.setup_computational_region_interface

```python
setup_computational_region_interface()
```

Sets up the interface for users to draw and
modify the computational region on the map.

This includes creating a toggle button to activate the
region editing mode, and instantiating an InteractiveRegionController to
handle the region selection and modification functionality.

##### grass.jupyter.InteractiveMap.setup_drawing_interface

```python
setup_drawing_interface()
```

Sets up the drawing interface for users
to interactively draw and manage geometries on the map.

This includes creating a toggle button to activate the drawing mode, and
instantiating an InteractiveDrawController to handle the drawing functionality.

##### grass.jupyter.InteractiveMap.setup_query_interface

```python
setup_query_interface()
```

Sets up the query button interface.

This includes creating a toggle button to activate the
query mode, and instantiating an InteractiveQueryController to
handle the user query.

##### grass.jupyter.InteractiveMap.show

```python
show()
```

This function returns a folium figure or ipyleaflet map object
with a GRASS raster and/or vector overlaid on a basemap.

If map has layer control enabled, additional layers cannot be
added after calling show().

##### grass.jupyter.InteractiveMap.vector_name

```python
vector_name = []
```

##### grass.jupyter.InteractiveMap.width

```python
width = int(width)
```

#### grass.jupyter.Map

```python
Map(width=None, height=None, filename=None, env=None, font='sans', text_size=12, renderer='cairo', use_region=False, saved_region=None, read_file=False)
```

Map creates and displays GRASS maps in
Jupyter Notebooks.

Elements are added to the display by calling GRASS display modules.

Basic usage::

> > > m = Map()
> > > m.run("d.rast", map="elevation")
> > > m.run("d.legend", raster="elevation")
> > > m.show()

GRASS display modules can also be called by using the name of module
as a class method and replacing "." with "\_" in the name.

Shortcut usage::

> > > m = Map()
> > > m.d_rast(map="elevation")
> > > m.d_legend(raster="elevation")
> > > m.show()

**Functions:**

- [**run**](#grass.jupyter.Map.run) – Run modules from the GRASS display family (modules starting with "d.").
- [**save**](#grass.jupyter.Map.save) – Saves a PNG image of map to the specified *filename*
- [**show**](#grass.jupyter.Map.show) – Displays a PNG image of map

**Attributes:**

- [**filename**](#grass.jupyter.Map.filename) – Filename or full path to the file with the resulting image.
- [**region_manager**](#grass.jupyter.Map.region_manager) – Region manager object

Creates an instance of the Map class.

:param int height: height of map in pixels
:param int width: width of map in pixels
:param str filename: filename or path to save a PNG of map
:param str env: environment
:param str font: font to use in rendering; either the name of a font from
$GISBASE/etc/fontcap (or alternative fontcap file specified
by GRASS_FONT_CAP), or alternatively the full path to a FreeType
font file
:param int text_size: default text size, overwritten by most display modules
:param renderer: GRASS renderer driver (options: cairo, png, ps, html)
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering
:param bool read_file: if False (default), erase filename before re-writing to
clear contents. If True, read file without clearing contents
first.

##### grass.jupyter.Map.filename

```python
filename
```

Filename or full path to the file with the resulting image.

The value can be set during initialization. When the filename was not provided
during initialization, a path to temporary file is returned. In that case, the
file is guaranteed to exist as long as the object exists.

##### grass.jupyter.Map.region_manager

```python
region_manager
```

Region manager object

##### grass.jupyter.Map.run

```python
run(module, **kwargs)
```

Run modules from the GRASS display family (modules starting with "d.").

This function passes arguments directly to grass.script.run_command()
so the syntax is the same.

:param str module: name of GRASS module
:param `**kwargs`: named arguments passed to run_command()

##### grass.jupyter.Map.save

```python
save(filename)
```

Saves a PNG image of map to the specified *filename*

##### grass.jupyter.Map.show

```python
show()
```

Displays a PNG image of map

#### grass.jupyter.Map3D

```python
Map3D(width=600, height=400, filename=None, mode='fine', resolution_fine=1, screen_backend='auto', font='sans', text_size=12, renderer2d='cairo', use_region=False, saved_region=None)
```

Creates and displays 3D visualization using GRASS GIS 3D rendering engine NVIZ.

The 3D image is created using the *render* function which uses the *m.nviz.image*
module in the background. Additional images can be
placed on the image using the *overlay* attribute which is the 2D renderer, i.e.,
has interface of the *Map* class.

Basic usage::

> > > img = Map()
> > > img.render(elevation_map="elevation", color_map="elevation", perspective=20)
> > > img.overlay.d_legend(raster="elevation", at=(60, 97, 87, 92))
> > > img.show()

For the OpenGL rendering with *m.nviz.image* to work, a display (screen) is needed.
This is not guaranteed on headless systems such as continuous integration (CI) or
Binder service(s). This class uses Xvfb and PyVirtualDisplay to support rendering
in these environments.

**Functions:**

- [**render**](#grass.jupyter.Map3D.render) – Run rendering using *m.nviz.image*.
- [**save**](#grass.jupyter.Map3D.save) – Saves an image to the specified *filename*
- [**show**](#grass.jupyter.Map3D.show) – Displays a PNG image of map

**Attributes:**

- [**filename**](#grass.jupyter.Map3D.filename) – Filename or full path to the file with the resulting image.
- [**overlay**](#grass.jupyter.Map3D.overlay) –
- [**region_manager**](#grass.jupyter.Map3D.region_manager) – Region manager object

Checks screen_backend and creates a temporary directory for rendering.

:param width: width of image in pixels
:param height: height of image in pixels
:param filename: filename or path to save the resulting PNG image
:param mode: 3D rendering mode (options: fine, coarse, both)
:param resolution_fine: resolution multiplier for the fine mode
:param screen_backend: backend for running the 3D rendering
:param font: font to use in 2D rendering
:param text_size: default text size in 2D rendering, usually overwritten
:param renderer2d: GRASS 2D renderer driver (options: cairo, png)
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

When *resolution_fine* is 1, rasters are used in the resolution according
to the computational region as usual in GRASS GIS.
Setting *resolution_fine* to values higher than one, causes rasters to
be resampled to a coarser resolution (2 for twice as coarse than computational
region resolution). This allows for fast rendering of large rasters without
changing the computational region.

By default (`screen_backend="auto"`), when
pyvirtualdisplay Python package is present, the class assumes that it is
running in a headless environment, so pyvirtualdisplay is used. When the
package is not present, *m.nviz.image* is executed directly. When
*screen_backend* is set to `"pyvirtualdisplay"` and the package cannot be
imported, ValueError is raised. When *screen_backend* is set to `"simple"`,
*m.nviz.image* is executed directly. For other values of *screen_backend*,
ValueError is raised.

##### grass.jupyter.Map3D.filename

```python
filename
```

Filename or full path to the file with the resulting image.

The value can be set during initialization. When the filename was not provided
during initialization, a path to temporary file is returned. In that case, the
file is guaranteed to exist as long as the object exists.

##### grass.jupyter.Map3D.overlay

```python
overlay = Map(height=height, width=width, filename=self._filename, font=font, text_size=text_size, renderer=renderer2d, use_region=use_region, saved_region=saved_region)
```

##### grass.jupyter.Map3D.region_manager

```python
region_manager
```

Region manager object

##### grass.jupyter.Map3D.render

```python
render(**kwargs)
```

Run rendering using *m.nviz.image*.

Keyword arguments are passed as parameters to the *m.nviz.image* module.
Parameters set in constructor such as *mode* are used here unless another value
is provided. Parameters related to size, file, and format are handled
internally and will be ignored when passed here.

Calling this function again, overwrites the previously rendered image,
so typically, it is called only once.

##### grass.jupyter.Map3D.save

```python
save(filename)
```

Saves an image to the specified *filename*

##### grass.jupyter.Map3D.show

```python
show()
```

Displays a PNG image of map

#### grass.jupyter.Raster

```python
Raster(name, title=None, use_region=False, saved_region=None, renderer=None, **kwargs)
```

Bases: <code>[Layer](#grass.jupyter.interactivemap.Layer)</code>

Overlays rasters on a folium or ipyleaflet map.

Basic Usage:

> > > m = folium.Map()
> > > gj.Raster("elevation", opacity=0.5).add_to(m)
> > > m

> > > m = ipyleaflet.Map()
> > > gj.Raster("elevation", opacity=0.5).add_to(m)
> > > m

**Functions:**

- [**add_to**](#grass.jupyter.Raster.add_to) – Add raster to map object which is an instance of either

Reproject GRASS raster, export to PNG, and compute bounding box.

##### grass.jupyter.Raster.add_to

```python
add_to(interactive_map)
```

Add raster to map object which is an instance of either
folium.Map or ipyleaflet.Map

#### grass.jupyter.SeriesMap

```python
SeriesMap(width=None, height=None, env=None, use_region=False, saved_region=None)
```

Bases: <code>[BaseSeriesMap](#grass.jupyter.baseseriesmap.BaseSeriesMap)</code>

Creates visualizations from a series of rasters or vectors in Jupyter
Notebooks.

Basic usage::

> > > series = gj.SeriesMap(height=500)
> > > series.add_rasters(["elevation_shade", "geology", "soils"])
> > > series.add_vectors(["streams", "streets", "viewpoints"])
> > > series.d_barscale()
> > > series.show() # Create Slider
> > > series.save("image.gif")

This class of grass.jupyter is experimental and under development. The API can
change at anytime.

**Functions:**

- [**add_names**](#grass.jupyter.SeriesMap.add_names) – Add list of names associated with layers.
- [**add_rasters**](#grass.jupyter.SeriesMap.add_rasters) – :param list rasters: list of raster layers to add to SeriesMap
- [**add_vectors**](#grass.jupyter.SeriesMap.add_vectors) – :param list vectors: list of vector layers to add to SeriesMap
- [**render**](#grass.jupyter.SeriesMap.render) – Renders image for each raster in series.
- [**save**](#grass.jupyter.SeriesMap.save) – Creates a GIF animation of rendered layers.
- [**show**](#grass.jupyter.SeriesMap.show) – Create interactive timeline slider.

**Attributes:**

- [**base_file**](#grass.jupyter.SeriesMap.base_file) –
- [**baseseries**](#grass.jupyter.SeriesMap.baseseries) –

Creates an instance of the SeriesMap visualizations class.

:param int width: width of map in pixels
:param int height: height of map in pixels
:param str env: environment
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

##### grass.jupyter.SeriesMap.add_names

```python
add_names(names)
```

Add list of names associated with layers.
Default will be names of first series added.

##### grass.jupyter.SeriesMap.add_rasters

```python
add_rasters(rasters, **kwargs)
```

:param list rasters: list of raster layers to add to SeriesMap

##### grass.jupyter.SeriesMap.add_vectors

```python
add_vectors(vectors, **kwargs)
```

:param list vectors: list of vector layers to add to SeriesMap

##### grass.jupyter.SeriesMap.base_file

```python
base_file = None
```

##### grass.jupyter.SeriesMap.baseseries

```python
baseseries = None
```

##### grass.jupyter.SeriesMap.render

```python
render()
```

Renders image for each raster in series.

Save PNGs to temporary directory. Must be run before creating a visualization
(i.e. show or save).

##### grass.jupyter.SeriesMap.save

```python
save(filename, duration=500, label=True, font=None, text_size=12, text_color='gray')
```

Creates a GIF animation of rendered layers.

Text color must be in a format accepted by PIL ImageColor module. For supported
formats, visit:
https://pillow.readthedocs.io/en/stable/reference/ImageColor.html#color-names

param str filename: name of output GIF file
param int duration: time to display each frame; milliseconds
param bool label: include label on each frame
param str font: font file
param int text_size: size of label text
param str text_color: color to use for the text.

##### grass.jupyter.SeriesMap.show

```python
show(slider_width=None)
```

Create interactive timeline slider.

param str slider_width: width of datetime selection slider

The slider_width parameter sets the width of the slider in the output cell.
It should be formatted as a percentage (%) between 0 and 100 of the cell width
or in pixels (px). Values should be formatted as strings and include the "%"
or "px" suffix. For example, slider_width="80%" or slider_width="500px".
slider_width is passed to ipywidgets in ipywidgets.Layout(width=slider_width).

#### grass.jupyter.TimeSeriesMap

```python
TimeSeriesMap(width=None, height=None, env=None, use_region=False, saved_region=None)
```

Bases: <code>[BaseSeriesMap](#grass.jupyter.baseseriesmap.BaseSeriesMap)</code>

Creates visualizations of time-space raster and vector datasets in Jupyter
Notebooks.

Basic usage::

> > > img = TimeSeriesMap("series_name")
> > > img.d_legend() # Add legend
> > > img.show() # Create TimeSlider
> > > img.save("image.gif")

This class of grass.jupyter is experimental and under development. The API can
change at anytime.

**Functions:**

- [**add_raster_series**](#grass.jupyter.TimeSeriesMap.add_raster_series) – :param str baseseries: name of space-time dataset
- [**add_vector_series**](#grass.jupyter.TimeSeriesMap.add_vector_series) – :param str baseseries: name of space-time dataset
- [**d_legend**](#grass.jupyter.TimeSeriesMap.d_legend) – Display legend.
- [**render**](#grass.jupyter.TimeSeriesMap.render) – Renders image for each time-step in space-time dataset.
- [**save**](#grass.jupyter.TimeSeriesMap.save) – Creates a GIF animation of rendered layers.
- [**show**](#grass.jupyter.TimeSeriesMap.show) – Create interactive timeline slider.

**Attributes:**

- [**base_file**](#grass.jupyter.TimeSeriesMap.base_file) –
- [**baseseries**](#grass.jupyter.TimeSeriesMap.baseseries) –

Creates an instance of the TimeSeriesMap visualizations class.

:param int width: width of map in pixels
:param int height: height of map in pixels
:param str env: environment
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

##### grass.jupyter.TimeSeriesMap.add_raster_series

```python
add_raster_series(baseseries, fill_gaps=False)
```

:param str baseseries: name of space-time dataset
:param bool fill_gaps: fill empty time steps with data from previous step

##### grass.jupyter.TimeSeriesMap.add_vector_series

```python
add_vector_series(baseseries, fill_gaps=False)
```

:param str baseseries: name of space-time dataset
:param bool fill_gaps: fill empty time steps with data from previous step

##### grass.jupyter.TimeSeriesMap.base_file

```python
base_file = None
```

##### grass.jupyter.TimeSeriesMap.baseseries

```python
baseseries = None
```

##### grass.jupyter.TimeSeriesMap.d_legend

```python
d_legend(**kwargs)
```

Display legend.

Wraps d.legend and uses same keyword arguments.

##### grass.jupyter.TimeSeriesMap.render

```python
render()
```

Renders image for each time-step in space-time dataset.

##### grass.jupyter.TimeSeriesMap.save

```python
save(filename, duration=500, label=True, font=None, text_size=12, text_color='gray')
```

Creates a GIF animation of rendered layers.

Text color must be in a format accepted by PIL ImageColor module. For supported
formats, visit:
https://pillow.readthedocs.io/en/stable/reference/ImageColor.html#color-names

param str filename: name of output GIF file
param int duration: time to display each frame; milliseconds
param bool label: include label on each frame
param str font: font file
param int text_size: size of label text
param str text_color: color to use for the text.

##### grass.jupyter.TimeSeriesMap.show

```python
show(slider_width=None)
```

Create interactive timeline slider.

param str slider_width: width of datetime selection slider

The slider_width parameter sets the width of the slider in the output cell.
It should be formatted as a percentage (%) between 0 and 100 of the cell width
or in pixels (px). Values should be formatted as strings and include the "%"
or "px" suffix. For example, slider_width="80%" or slider_width="500px".
slider_width is passed to ipywidgets in ipywidgets.Layout(width=slider_width).

#### grass.jupyter.Vector

```python
Vector(name, title=None, use_region=False, saved_region=None, renderer=None, **kwargs)
```

Bases: <code>[Layer](#grass.jupyter.interactivemap.Layer)</code>

Adds vectors to a folium or ipyleaflet map.

Basic Usage:

> > > m = folium.Map()
> > > gj.Vector("roadsmajor").add_to(m)
> > > m

> > > m = ipyleaflet.Map()
> > > gj.Vector("roadsmajor").add_to(m)
> > > m

**Functions:**

- [**add_to**](#grass.jupyter.Vector.add_to) – Add vector to map

Reproject GRASS vector and export to GeoJSON.

##### grass.jupyter.Vector.add_to

```python
add_to(interactive_map)
```

Add vector to map

#### grass.jupyter.baseseriesmap

Base class for SeriesMap and TimeSeriesMap

**Classes:**

- [**BaseSeriesMap**](#grass.jupyter.baseseriesmap.BaseSeriesMap) – Base class for SeriesMap and TimeSeriesMap

##### grass.jupyter.baseseriesmap.BaseSeriesMap

```python
BaseSeriesMap(width=None, height=None, env=None)
```

Base class for SeriesMap and TimeSeriesMap

**Functions:**

- [**save**](#grass.jupyter.baseseriesmap.BaseSeriesMap.save) – Creates a GIF animation of rendered layers.
- [**show**](#grass.jupyter.baseseriesmap.BaseSeriesMap.show) – Create interactive timeline slider.

**Attributes:**

- [**base_file**](#grass.jupyter.baseseriesmap.BaseSeriesMap.base_file) –
- [**baseseries**](#grass.jupyter.baseseriesmap.BaseSeriesMap.baseseries) –

Creates an instance of the visualizations class.

:param int width: width of map in pixels
:param int height: height of map in pixels
:param str env: environment

###### grass.jupyter.baseseriesmap.BaseSeriesMap.base_file

```python
base_file = None
```

###### grass.jupyter.baseseriesmap.BaseSeriesMap.baseseries

```python
baseseries = None
```

###### grass.jupyter.baseseriesmap.BaseSeriesMap.save

```python
save(filename, duration=500, label=True, font=None, text_size=12, text_color='gray')
```

Creates a GIF animation of rendered layers.

Text color must be in a format accepted by PIL ImageColor module. For supported
formats, visit:
https://pillow.readthedocs.io/en/stable/reference/ImageColor.html#color-names

param str filename: name of output GIF file
param int duration: time to display each frame; milliseconds
param bool label: include label on each frame
param str font: font file
param int text_size: size of label text
param str text_color: color to use for the text.

###### grass.jupyter.baseseriesmap.BaseSeriesMap.show

```python
show(slider_width=None)
```

Create interactive timeline slider.

param str slider_width: width of datetime selection slider

The slider_width parameter sets the width of the slider in the output cell.
It should be formatted as a percentage (%) between 0 and 100 of the cell width
or in pixels (px). Values should be formatted as strings and include the "%"
or "px" suffix. For example, slider_width="80%" or slider_width="500px".
slider_width is passed to ipywidgets in ipywidgets.Layout(width=slider_width).

#### grass.jupyter.init

```python
init(path, location=None, mapset=None, grass_path=None)
```

Initiates a GRASS session and sets GRASS environment variables.

Calling this function returns an object which represents the session.

> > > import grass.jupyter as gj
> > > session = gj.init(...)

The session is ended when `session.finish` is called or when the object is
destroyed when kernel ends or restarts. This function returns a copy of an
internally kept reference, so the return value can be safely ignored when not
needed.

The returned object can be used to switch to another mapset:

> > > session.switch_mapset("mapset_name")

Subsequent calls to the *init* function result in switching the mapset if
a session is active and result in creation of new session if it is not active.
On the other hand, if you see `GISRC - variable not set` after calling
a GRASS module, you know you don't have an active GRASS session.

:param str path: path to GRASS mapset or database
:param str location: name of GRASS location within the database
:param str mapset: name of mapset within location

#### grass.jupyter.interactivemap

Interactive visualizations map with folium or ipyleaflet

**Classes:**

- [**InteractiveDrawController**](#grass.jupyter.interactivemap.InteractiveDrawController) – A controller for interactive drawing on a map.
- [**InteractiveMap**](#grass.jupyter.interactivemap.InteractiveMap) – This class creates interactive GRASS maps with folium or ipyleaflet.
- [**InteractiveQueryController**](#grass.jupyter.interactivemap.InteractiveQueryController) – A controller for interactive querying on a map.
- [**InteractiveRegionController**](#grass.jupyter.interactivemap.InteractiveRegionController) – A controller for interactive region selection on a map.
- [**Layer**](#grass.jupyter.interactivemap.Layer) – Base class for overlaing raster or vector layer
- [**Raster**](#grass.jupyter.interactivemap.Raster) – Overlays rasters on a folium or ipyleaflet map.
- [**Vector**](#grass.jupyter.interactivemap.Vector) – Adds vectors to a folium or ipyleaflet map.

**Functions:**

- [**get_backend**](#grass.jupyter.interactivemap.get_backend) – Identifies if interactive_map is of type folium.Map

##### grass.jupyter.interactivemap.InteractiveDrawController

```python
InteractiveDrawController(map_object, ipyleaflet, ipywidgets, toggle_button, vectors, **kwargs)
```

A controller for interactive drawing on a map.

**Attributes:**

- [**map**](#grass.jupyter.interactivemap.InteractiveDrawController.map) – The map object.
- [**\_ipyleaflet**](#grass.jupyter.interactivemap.InteractiveDrawController._ipyleaflet) – The ipyleaflet module.
- [**draw_control**](#grass.jupyter.interactivemap.InteractiveDrawController.draw_control) – The draw control.
- [**drawn_geometries**](#grass.jupyter.interactivemap.InteractiveDrawController.drawn_geometries) – The list of drawn geometries.
- [**self.vector_layers**](#grass.jupyter.interactivemap.InteractiveDrawController.self.vector_layers) – List of vector layers
- [**geo_json_layers**](#grass.jupyter.interactivemap.InteractiveDrawController.geo_json_layers) – The dictionary of GeoJSON layers.
- [**save_button_control**](#grass.jupyter.interactivemap.InteractiveDrawController.save_button_control) – The save button control.
- [**toggle_button**](#grass.jupyter.interactivemap.InteractiveDrawController.toggle_button) – The toggle button activating/deactivating drawing.

**Functions:**

- [**activate**](#grass.jupyter.interactivemap.InteractiveDrawController.activate) – Activates the interactive drawing.
- [**deactivate**](#grass.jupyter.interactivemap.InteractiveDrawController.deactivate) – Deactivates the interactive drawing.

**Attributes:**

- [**draw_control**](#grass.jupyter.interactivemap.InteractiveDrawController.draw_control) –
- [**drawn_geometries**](#grass.jupyter.interactivemap.InteractiveDrawController.drawn_geometries) –
- [**geo_json_layers**](#grass.jupyter.interactivemap.InteractiveDrawController.geo_json_layers) –
- [**map**](#grass.jupyter.interactivemap.InteractiveDrawController.map) –
- [**name_input**](#grass.jupyter.interactivemap.InteractiveDrawController.name_input) –
- [**save_button**](#grass.jupyter.interactivemap.InteractiveDrawController.save_button) –
- [**save_button_control**](#grass.jupyter.interactivemap.InteractiveDrawController.save_button_control) –
- [**toggle_button**](#grass.jupyter.interactivemap.InteractiveDrawController.toggle_button) –
- [**vector_layers**](#grass.jupyter.interactivemap.InteractiveDrawController.vector_layers) –

Initializes the InteractiveDrawController.

:param map_object: The map object.
:param ipyleaflet: The ipyleaflet module.
:param ipywidgets: The ipywidgets module.
:param toggle_button: The toggle button activating/deactivating drawing.
:param vectors: List of vector layers.

###### grass.jupyter.interactivemap.InteractiveDrawController.activate

```python
activate()
```

Activates the interactive drawing.

###### grass.jupyter.interactivemap.InteractiveDrawController.deactivate

```python
deactivate()
```

Deactivates the interactive drawing.

###### grass.jupyter.interactivemap.InteractiveDrawController.draw_control

```python
draw_control = self._ipyleaflet.DrawControl(edit=False, remove=False)
```

###### grass.jupyter.interactivemap.InteractiveDrawController.drawn_geometries

```python
drawn_geometries = []
```

###### grass.jupyter.interactivemap.InteractiveDrawController.geo_json_layers

```python
geo_json_layers = {}
```

###### grass.jupyter.interactivemap.InteractiveDrawController.map

```python
map = map_object
```

###### grass.jupyter.interactivemap.InteractiveDrawController.name_input

```python
name_input = self._ipywidgets.Text(description=_('New vector map name:'), style={'description_width': 'initial'}, layout=self._ipywidgets.Layout(width='80%', margin='1px 1px 1px 5px'))
```

###### grass.jupyter.interactivemap.InteractiveDrawController.save_button

```python
save_button = self._ipywidgets.Button(description=_('Save'), layout=self._ipywidgets.Layout(width='20%', margin='1px 1px 1px 1px'))
```

###### grass.jupyter.interactivemap.InteractiveDrawController.save_button_control

```python
save_button_control = None
```

###### grass.jupyter.interactivemap.InteractiveDrawController.toggle_button

```python
toggle_button = toggle_button
```

###### grass.jupyter.interactivemap.InteractiveDrawController.vector_layers

```python
vector_layers = vectors
```

##### grass.jupyter.interactivemap.InteractiveMap

```python
InteractiveMap(width=400, height=400, tiles='CartoDB positron', API_key=None, use_region=False, saved_region=None, map_backend=None)
```

This class creates interactive GRASS maps with folium or ipyleaflet.

Basic Usage:

> > > m = InteractiveMap()
> > > m.add_vector("streams")
> > > m.add_raster("elevation")
> > > m.show()

**Functions:**

- [**add_layer_control**](#grass.jupyter.interactivemap.InteractiveMap.add_layer_control) – Add layer control to display.
- [**add_raster**](#grass.jupyter.interactivemap.InteractiveMap.add_raster) – Imports raster into temporary WGS84 location,
- [**add_vector**](#grass.jupyter.interactivemap.InteractiveMap.add_vector) – Imports vector into temporary WGS84 location, re-formats to a GeoJSON and
- [**save**](#grass.jupyter.interactivemap.InteractiveMap.save) – Save map as an html map.
- [**setup_computational_region_interface**](#grass.jupyter.interactivemap.InteractiveMap.setup_computational_region_interface) – Sets up the interface for users to draw and
- [**setup_drawing_interface**](#grass.jupyter.interactivemap.InteractiveMap.setup_drawing_interface) – Sets up the drawing interface for users
- [**setup_query_interface**](#grass.jupyter.interactivemap.InteractiveMap.setup_query_interface) – Sets up the query button interface.
- [**show**](#grass.jupyter.interactivemap.InteractiveMap.show) – This function returns a folium figure or ipyleaflet map object

**Attributes:**

- [**height**](#grass.jupyter.interactivemap.InteractiveMap.height) –
- [**layer_control_object**](#grass.jupyter.interactivemap.InteractiveMap.layer_control_object) –
- [**map**](#grass.jupyter.interactivemap.InteractiveMap.map) –
- [**raster_name**](#grass.jupyter.interactivemap.InteractiveMap.raster_name) –
- [**region**](#grass.jupyter.interactivemap.InteractiveMap.region) –
- [**region_rectangle**](#grass.jupyter.interactivemap.InteractiveMap.region_rectangle) –
- [**vector_name**](#grass.jupyter.interactivemap.InteractiveMap.vector_name) –
- [**width**](#grass.jupyter.interactivemap.InteractiveMap.width) –

Creates a blank folium/ipyleaflet map centered on g.region.

If map_backend is not specified, InteractiveMap tries to import
ipyleaflet first, then folium if it fails. The backend can be
specified explicitely with valid values "folium" and "ipyleaflet" .

In case of folium backend, tiles parameter is passed directly
to folium.Map() which supports several built-in tilesets
(including "OpenStreetMap", "Stamen Toner", "Stamen Terrain",
"Stamen Watercolor", "Mapbox Bright", "Mapbox Control Room", "CartoDB positron",
"CartoDB dark_matter") as well as custom tileset URL (i.e.
"http://{s}.yourtiles.com/{z}/{x}/{y}.png"). For more information, visit
folium documentation:
https://python-visualization.github.io/folium/modules.html
In case of ipyleaflet, only the tileset name and not the URL is
currently supported.

Raster and vector data are always reprojected to Pseudo-Mercator.
With use_region=True or saved_region=myregion, the region extent
is reprojected and the number of rows and columns of that region
is kept the same. This region is then used for reprojection.
By default, use_region is False, which results in the
reprojection of the entire raster in its native resolution.
The reprojected resolution is estimated with r.proj.
Vector data are always reprojected without any clipping,
i.e., region options don't do anything.

:param int height: height in pixels of figure (default 400)
:param int width: width in pixels of figure (default 400)
:param str tiles: map tileset to use
:param str API_key: API key for Mapbox or Cloudmade tiles
:param bool use_region: use computational region of current mapset
:param str saved_region: name of saved computation region
:param str map_backend: "ipyleaflet" or "folium" or None

###### grass.jupyter.interactivemap.InteractiveMap.add_layer_control

```python
add_layer_control(**kwargs)
```

Add layer control to display.

A Layer Control is added by default. Call this function to customize
layer control object. Accepts keyword arguments to be passed to leaflet
layer control object

###### grass.jupyter.interactivemap.InteractiveMap.add_raster

```python
add_raster(name, title=None, **kwargs)
```

Imports raster into temporary WGS84 location,
exports as png and overlays on a map.

Color table for the raster can be modified with `r.colors` before calling
this function.

.. note:: This will only work if the raster is located in the current mapset.
To change the color table of a raster located outside the current mapset,
switch to that mapset with `g.mapset`, modify the color table with `r.color`
then switch back to the initial mapset and run this function.

:param str name: name of raster to add to display; positional-only parameter
:param str title: raster name for layer control
:param kwargs: keyword arguments passed to image overlay

###### grass.jupyter.interactivemap.InteractiveMap.add_vector

```python
add_vector(name, title=None, **kwargs)
```

Imports vector into temporary WGS84 location, re-formats to a GeoJSON and
adds to map.

:param str name: name of vector to be added to map;
positional-only parameter
:param str title: vector name for layer control
:param kwargs: keyword arguments passed to GeoJSON overlay

###### grass.jupyter.interactivemap.InteractiveMap.height

```python
height = int(height)
```

###### grass.jupyter.interactivemap.InteractiveMap.layer_control_object

```python
layer_control_object = None
```

###### grass.jupyter.interactivemap.InteractiveMap.map

```python
map = self._ipyleaflet.Map(basemap=basemap, layout=layout, scroll_wheel_zoom=True)
```

###### grass.jupyter.interactivemap.InteractiveMap.raster_name

```python
raster_name = []
```

###### grass.jupyter.interactivemap.InteractiveMap.region

```python
region = None
```

###### grass.jupyter.interactivemap.InteractiveMap.region_rectangle

```python
region_rectangle = None
```

###### grass.jupyter.interactivemap.InteractiveMap.save

```python
save(filename)
```

Save map as an html map.

:param str filename: name of html file

###### grass.jupyter.interactivemap.InteractiveMap.setup_computational_region_interface

```python
setup_computational_region_interface()
```

Sets up the interface for users to draw and
modify the computational region on the map.

This includes creating a toggle button to activate the
region editing mode, and instantiating an InteractiveRegionController to
handle the region selection and modification functionality.

###### grass.jupyter.interactivemap.InteractiveMap.setup_drawing_interface

```python
setup_drawing_interface()
```

Sets up the drawing interface for users
to interactively draw and manage geometries on the map.

This includes creating a toggle button to activate the drawing mode, and
instantiating an InteractiveDrawController to handle the drawing functionality.

###### grass.jupyter.interactivemap.InteractiveMap.setup_query_interface

```python
setup_query_interface()
```

Sets up the query button interface.

This includes creating a toggle button to activate the
query mode, and instantiating an InteractiveQueryController to
handle the user query.

###### grass.jupyter.interactivemap.InteractiveMap.show

```python
show()
```

This function returns a folium figure or ipyleaflet map object
with a GRASS raster and/or vector overlaid on a basemap.

If map has layer control enabled, additional layers cannot be
added after calling show().

###### grass.jupyter.interactivemap.InteractiveMap.vector_name

```python
vector_name = []
```

###### grass.jupyter.interactivemap.InteractiveMap.width

```python
width = int(width)
```

##### grass.jupyter.interactivemap.InteractiveQueryController

```python
InteractiveQueryController(map_object, ipyleaflet, ipywidgets, rasters, vectors, width, **kwargs)
```

A controller for interactive querying on a map.

**Attributes:**

- [**map**](#grass.jupyter.interactivemap.InteractiveQueryController.map) – The ipyleaflet.Map object.
- [**\_ipyleaflet**](#grass.jupyter.interactivemap.InteractiveQueryController._ipyleaflet) – The ipyleaflet module.
- [**\_ipywidgets**](#grass.jupyter.interactivemap.InteractiveQueryController._ipywidgets) – The ipywidgets module.
- [**raster_name**](#grass.jupyter.interactivemap.InteractiveQueryController.raster_name) – The name of the raster layer.
- [**vector_name**](#grass.jupyter.interactivemap.InteractiveQueryController.vector_name) – The name of the vector layer.
- [**width**](#grass.jupyter.interactivemap.InteractiveQueryController.width) – The width of the map as an int.
- [**query_control**](#grass.jupyter.interactivemap.InteractiveQueryController.query_control) – The query control.

**Functions:**

- [**activate**](#grass.jupyter.interactivemap.InteractiveQueryController.activate) – Activates the interactive querying.
- [**clear_popups**](#grass.jupyter.interactivemap.InteractiveQueryController.clear_popups) – Clears the popups.
- [**deactivate**](#grass.jupyter.interactivemap.InteractiveQueryController.deactivate) – Deactivates the interactive querying.
- [**handle_interaction**](#grass.jupyter.interactivemap.InteractiveQueryController.handle_interaction) – Handles the map interaction event.
- [**query_raster**](#grass.jupyter.interactivemap.InteractiveQueryController.query_raster) – Queries the raster layer.
- [**query_vector**](#grass.jupyter.interactivemap.InteractiveQueryController.query_vector) – Queries the vector layer.
- [**show_popup**](#grass.jupyter.interactivemap.InteractiveQueryController.show_popup) – Shows a popup with the query result.

**Attributes:**

- [**map**](#grass.jupyter.interactivemap.InteractiveQueryController.map) –
- [**query_control**](#grass.jupyter.interactivemap.InteractiveQueryController.query_control) –
- [**raster_name**](#grass.jupyter.interactivemap.InteractiveQueryController.raster_name) –
- [**vector_name**](#grass.jupyter.interactivemap.InteractiveQueryController.vector_name) –
- [**width**](#grass.jupyter.interactivemap.InteractiveQueryController.width) –

Initializes the InteractiveQueryController.

:param map: The map object.
:param ipyleaflet: The ipyleaflet module.
:param ipywidgets: The ipywidgets module.

###### grass.jupyter.interactivemap.InteractiveQueryController.activate

```python
activate()
```

Activates the interactive querying.

###### grass.jupyter.interactivemap.InteractiveQueryController.clear_popups

```python
clear_popups()
```

Clears the popups.

###### grass.jupyter.interactivemap.InteractiveQueryController.deactivate

```python
deactivate()
```

Deactivates the interactive querying.

###### grass.jupyter.interactivemap.InteractiveQueryController.handle_interaction

```python
handle_interaction(**kwargs)
```

Handles the map interaction event.

:param kwargs: The event arguments.

###### grass.jupyter.interactivemap.InteractiveQueryController.map

```python
map = map_object
```

###### grass.jupyter.interactivemap.InteractiveQueryController.query_control

```python
query_control = None
```

###### grass.jupyter.interactivemap.InteractiveQueryController.query_raster

```python
query_raster(coordinates)
```

Queries the raster layer.

:param coordinates: The coordinates.
:return: The raster output.

###### grass.jupyter.interactivemap.InteractiveQueryController.query_vector

```python
query_vector(coordinates)
```

Queries the vector layer.

:param coordinates: The coordinates.
:return: The vector output.

###### grass.jupyter.interactivemap.InteractiveQueryController.raster_name

```python
raster_name = rasters
```

###### grass.jupyter.interactivemap.InteractiveQueryController.show_popup

```python
show_popup(lonlat, message_content)
```

Shows a popup with the query result.

:param lonlat: The latitude and longitude coordinates.
:param message_content: The message content.

###### grass.jupyter.interactivemap.InteractiveQueryController.vector_name

```python
vector_name = vectors
```

###### grass.jupyter.interactivemap.InteractiveQueryController.width

```python
width = width
```

##### grass.jupyter.interactivemap.InteractiveRegionController

```python
InteractiveRegionController(map_object, ipyleaflet, ipywidgets, **kwargs)
```

A controller for interactive region selection on a map.

**Attributes:**

- [**map**](#grass.jupyter.interactivemap.InteractiveRegionController.map) – The map object.
- [**region_rectangle**](#grass.jupyter.interactivemap.InteractiveRegionController.region_rectangle) – The rectangle representing the selected region.
- [**\_ipyleaflet**](#grass.jupyter.interactivemap.InteractiveRegionController._ipyleaflet) – The ipyleaflet module.
- [**\_ipywidgets**](#grass.jupyter.interactivemap.InteractiveRegionController._ipywidgets) – The ipywidgets module.
- [**save_button**](#grass.jupyter.interactivemap.InteractiveRegionController.save_button) – The button to save the selected region.
- [**bottom_output_widget**](#grass.jupyter.interactivemap.InteractiveRegionController.bottom_output_widget) – The output widget to display the selected region.
- [**changed_region**](#grass.jupyter.interactivemap.InteractiveRegionController.changed_region) (<code>[dict](#dict)</code>) – The dictionary to store the changed region.

**Functions:**

- [**activate**](#grass.jupyter.interactivemap.InteractiveRegionController.activate) – Activates the interactive region selection.
- [**deactivate**](#grass.jupyter.interactivemap.InteractiveRegionController.deactivate) – Deactivates the interactive region selection.

**Attributes:**

- [**bottom_output_widget**](#grass.jupyter.interactivemap.InteractiveRegionController.bottom_output_widget) –
- [**changed_region**](#grass.jupyter.interactivemap.InteractiveRegionController.changed_region) –
- [**map**](#grass.jupyter.interactivemap.InteractiveRegionController.map) –
- [**region_rectangle**](#grass.jupyter.interactivemap.InteractiveRegionController.region_rectangle) –
- [**save_button**](#grass.jupyter.interactivemap.InteractiveRegionController.save_button) –
- [**save_button_control**](#grass.jupyter.interactivemap.InteractiveRegionController.save_button_control) –

Initializes the InteractiveRegionController.

:param map_object: The map object.
:param ipyleaflet: The ipyleaflet module.
:param ipywidgets: The ipywidgets module.

###### grass.jupyter.interactivemap.InteractiveRegionController.activate

```python
activate()
```

Activates the interactive region selection.

###### grass.jupyter.interactivemap.InteractiveRegionController.bottom_output_widget

```python
bottom_output_widget = self._ipywidgets.Output(layout={'width': '100%', 'max_height': '300px', 'overflow': 'auto', 'display': 'none'})
```

###### grass.jupyter.interactivemap.InteractiveRegionController.changed_region

```python
changed_region = {}
```

###### grass.jupyter.interactivemap.InteractiveRegionController.deactivate

```python
deactivate()
```

Deactivates the interactive region selection.

###### grass.jupyter.interactivemap.InteractiveRegionController.map

```python
map = map_object
```

###### grass.jupyter.interactivemap.InteractiveRegionController.region_rectangle

```python
region_rectangle = None
```

###### grass.jupyter.interactivemap.InteractiveRegionController.save_button

```python
save_button = self._ipywidgets.Button(description='Update region', tooltip='Click to update region', disabled=True)
```

###### grass.jupyter.interactivemap.InteractiveRegionController.save_button_control

```python
save_button_control = None
```

##### grass.jupyter.interactivemap.Layer

```python
Layer(name, title=None, use_region=False, saved_region=None, renderer=None, **kwargs)
```

Base class for overlaing raster or vector layer
on a folium or ipyleaflet map.

Reproject GRASS raster, export to PNG, and compute bounding box.

param str name: layer name
param str title: title of layer to display in layer control legend
param bool use_region: use computational region of current mapset
param str saved_region: name of saved computation region
param renderer: instance of ReprojectionRenderer
\*\*kwargs: keyword arguments passed to folium/ipyleaflet layer instance

##### grass.jupyter.interactivemap.Raster

```python
Raster(name, title=None, use_region=False, saved_region=None, renderer=None, **kwargs)
```

Bases: <code>[Layer](#grass.jupyter.interactivemap.Layer)</code>

Overlays rasters on a folium or ipyleaflet map.

Basic Usage:

> > > m = folium.Map()
> > > gj.Raster("elevation", opacity=0.5).add_to(m)
> > > m

> > > m = ipyleaflet.Map()
> > > gj.Raster("elevation", opacity=0.5).add_to(m)
> > > m

**Functions:**

- [**add_to**](#grass.jupyter.interactivemap.Raster.add_to) – Add raster to map object which is an instance of either

Reproject GRASS raster, export to PNG, and compute bounding box.

###### grass.jupyter.interactivemap.Raster.add_to

```python
add_to(interactive_map)
```

Add raster to map object which is an instance of either
folium.Map or ipyleaflet.Map

##### grass.jupyter.interactivemap.Vector

```python
Vector(name, title=None, use_region=False, saved_region=None, renderer=None, **kwargs)
```

Bases: <code>[Layer](#grass.jupyter.interactivemap.Layer)</code>

Adds vectors to a folium or ipyleaflet map.

Basic Usage:

> > > m = folium.Map()
> > > gj.Vector("roadsmajor").add_to(m)
> > > m

> > > m = ipyleaflet.Map()
> > > gj.Vector("roadsmajor").add_to(m)
> > > m

**Functions:**

- [**add_to**](#grass.jupyter.interactivemap.Vector.add_to) – Add vector to map

Reproject GRASS vector and export to GeoJSON.

###### grass.jupyter.interactivemap.Vector.add_to

```python
add_to(interactive_map)
```

Add vector to map

##### grass.jupyter.interactivemap.get_backend

```python
get_backend(interactive_map)
```

Identifies if interactive_map is of type folium.Map
or ipyleaflet.Map. Returns "folium" or "ipyleaflet".

#### grass.jupyter.map

2D rendering and display functionality

**Classes:**

- [**Map**](#grass.jupyter.map.Map) – Map creates and displays GRASS maps in

##### grass.jupyter.map.Map

```python
Map(width=None, height=None, filename=None, env=None, font='sans', text_size=12, renderer='cairo', use_region=False, saved_region=None, read_file=False)
```

Map creates and displays GRASS maps in
Jupyter Notebooks.

Elements are added to the display by calling GRASS display modules.

Basic usage::

> > > m = Map()
> > > m.run("d.rast", map="elevation")
> > > m.run("d.legend", raster="elevation")
> > > m.show()

GRASS display modules can also be called by using the name of module
as a class method and replacing "." with "\_" in the name.

Shortcut usage::

> > > m = Map()
> > > m.d_rast(map="elevation")
> > > m.d_legend(raster="elevation")
> > > m.show()

**Functions:**

- [**run**](#grass.jupyter.map.Map.run) – Run modules from the GRASS display family (modules starting with "d.").
- [**save**](#grass.jupyter.map.Map.save) – Saves a PNG image of map to the specified *filename*
- [**show**](#grass.jupyter.map.Map.show) – Displays a PNG image of map

**Attributes:**

- [**filename**](#grass.jupyter.map.Map.filename) – Filename or full path to the file with the resulting image.
- [**region_manager**](#grass.jupyter.map.Map.region_manager) – Region manager object

Creates an instance of the Map class.

:param int height: height of map in pixels
:param int width: width of map in pixels
:param str filename: filename or path to save a PNG of map
:param str env: environment
:param str font: font to use in rendering; either the name of a font from
$GISBASE/etc/fontcap (or alternative fontcap file specified
by GRASS_FONT_CAP), or alternatively the full path to a FreeType
font file
:param int text_size: default text size, overwritten by most display modules
:param renderer: GRASS renderer driver (options: cairo, png, ps, html)
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering
:param bool read_file: if False (default), erase filename before re-writing to
clear contents. If True, read file without clearing contents
first.

###### grass.jupyter.map.Map.filename

```python
filename
```

Filename or full path to the file with the resulting image.

The value can be set during initialization. When the filename was not provided
during initialization, a path to temporary file is returned. In that case, the
file is guaranteed to exist as long as the object exists.

###### grass.jupyter.map.Map.region_manager

```python
region_manager
```

Region manager object

###### grass.jupyter.map.Map.run

```python
run(module, **kwargs)
```

Run modules from the GRASS display family (modules starting with "d.").

This function passes arguments directly to grass.script.run_command()
so the syntax is the same.

:param str module: name of GRASS module
:param `**kwargs`: named arguments passed to run_command()

###### grass.jupyter.map.Map.save

```python
save(filename)
```

Saves a PNG image of map to the specified *filename*

###### grass.jupyter.map.Map.show

```python
show()
```

Displays a PNG image of map

#### grass.jupyter.map3d

Render 3D visualizations

**Classes:**

- [**Map3D**](#grass.jupyter.map3d.Map3D) – Creates and displays 3D visualization using GRASS GIS 3D rendering engine NVIZ.

##### grass.jupyter.map3d.Map3D

```python
Map3D(width=600, height=400, filename=None, mode='fine', resolution_fine=1, screen_backend='auto', font='sans', text_size=12, renderer2d='cairo', use_region=False, saved_region=None)
```

Creates and displays 3D visualization using GRASS GIS 3D rendering engine NVIZ.

The 3D image is created using the *render* function which uses the *m.nviz.image*
module in the background. Additional images can be
placed on the image using the *overlay* attribute which is the 2D renderer, i.e.,
has interface of the *Map* class.

Basic usage::

> > > img = Map()
> > > img.render(elevation_map="elevation", color_map="elevation", perspective=20)
> > > img.overlay.d_legend(raster="elevation", at=(60, 97, 87, 92))
> > > img.show()

For the OpenGL rendering with *m.nviz.image* to work, a display (screen) is needed.
This is not guaranteed on headless systems such as continuous integration (CI) or
Binder service(s). This class uses Xvfb and PyVirtualDisplay to support rendering
in these environments.

**Functions:**

- [**render**](#grass.jupyter.map3d.Map3D.render) – Run rendering using *m.nviz.image*.
- [**save**](#grass.jupyter.map3d.Map3D.save) – Saves an image to the specified *filename*
- [**show**](#grass.jupyter.map3d.Map3D.show) – Displays a PNG image of map

**Attributes:**

- [**filename**](#grass.jupyter.map3d.Map3D.filename) – Filename or full path to the file with the resulting image.
- [**overlay**](#grass.jupyter.map3d.Map3D.overlay) –
- [**region_manager**](#grass.jupyter.map3d.Map3D.region_manager) – Region manager object

Checks screen_backend and creates a temporary directory for rendering.

:param width: width of image in pixels
:param height: height of image in pixels
:param filename: filename or path to save the resulting PNG image
:param mode: 3D rendering mode (options: fine, coarse, both)
:param resolution_fine: resolution multiplier for the fine mode
:param screen_backend: backend for running the 3D rendering
:param font: font to use in 2D rendering
:param text_size: default text size in 2D rendering, usually overwritten
:param renderer2d: GRASS 2D renderer driver (options: cairo, png)
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

When *resolution_fine* is 1, rasters are used in the resolution according
to the computational region as usual in GRASS GIS.
Setting *resolution_fine* to values higher than one, causes rasters to
be resampled to a coarser resolution (2 for twice as coarse than computational
region resolution). This allows for fast rendering of large rasters without
changing the computational region.

By default (`screen_backend="auto"`), when
pyvirtualdisplay Python package is present, the class assumes that it is
running in a headless environment, so pyvirtualdisplay is used. When the
package is not present, *m.nviz.image* is executed directly. When
*screen_backend* is set to `"pyvirtualdisplay"` and the package cannot be
imported, ValueError is raised. When *screen_backend* is set to `"simple"`,
*m.nviz.image* is executed directly. For other values of *screen_backend*,
ValueError is raised.

###### grass.jupyter.map3d.Map3D.filename

```python
filename
```

Filename or full path to the file with the resulting image.

The value can be set during initialization. When the filename was not provided
during initialization, a path to temporary file is returned. In that case, the
file is guaranteed to exist as long as the object exists.

###### grass.jupyter.map3d.Map3D.overlay

```python
overlay = Map(height=height, width=width, filename=self._filename, font=font, text_size=text_size, renderer=renderer2d, use_region=use_region, saved_region=saved_region)
```

###### grass.jupyter.map3d.Map3D.region_manager

```python
region_manager
```

Region manager object

###### grass.jupyter.map3d.Map3D.render

```python
render(**kwargs)
```

Run rendering using *m.nviz.image*.

Keyword arguments are passed as parameters to the *m.nviz.image* module.
Parameters set in constructor such as *mode* are used here unless another value
is provided. Parameters related to size, file, and format are handled
internally and will be ignored when passed here.

Calling this function again, overwrites the previously rendered image,
so typically, it is called only once.

###### grass.jupyter.map3d.Map3D.save

```python
save(filename)
```

Saves an image to the specified *filename*

###### grass.jupyter.map3d.Map3D.show

```python
show()
```

Displays a PNG image of map

#### grass.jupyter.region

Manage computational or display region settings for display (render) classes.

**Classes:**

- [**RegionManagerFor2D**](#grass.jupyter.region.RegionManagerFor2D) – Region manager for 2D displays (gets region from display commands)
- [**RegionManagerFor3D**](#grass.jupyter.region.RegionManagerFor3D) – Region manager for 3D displays (gets region from m.nviz.image command)
- [**RegionManagerForInteractiveMap**](#grass.jupyter.region.RegionManagerForInteractiveMap) – Region manager for an interactive map (gets region from raster and vector)
- [**RegionManagerForSeries**](#grass.jupyter.region.RegionManagerForSeries) – Region manager for SeriesMap
- [**RegionManagerForTimeSeries**](#grass.jupyter.region.RegionManagerForTimeSeries) – Region manager for TimeSeries visualizations.

##### grass.jupyter.region.RegionManagerFor2D

```python
RegionManagerFor2D(use_region, saved_region, width, height, env)
```

Region manager for 2D displays (gets region from display commands)

**Functions:**

- [**adjust_rendering_size_from_region**](#grass.jupyter.region.RegionManagerFor2D.adjust_rendering_size_from_region) – Sets the environmental render width and height variables
- [**set_region_from_command**](#grass.jupyter.region.RegionManagerFor2D.set_region_from_command) – Sets computational region for rendering.
- [**set_region_from_env**](#grass.jupyter.region.RegionManagerFor2D.set_region_from_env) – Copies GRASS_REGION from provided environment

Manages region during rendering.

:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering
:param width: rendering width
:param height: rendering height
:param env: environment for rendering

###### grass.jupyter.region.RegionManagerFor2D.adjust_rendering_size_from_region

```python
adjust_rendering_size_from_region()
```

Sets the environmental render width and height variables
based on the region dimensions. Only first call of this
method sets the variables, subsequent calls do not adjust them.

###### grass.jupyter.region.RegionManagerFor2D.set_region_from_command

```python
set_region_from_command(module, **kwargs)
```

Sets computational region for rendering.

This functions identifies a raster/vector map from command
and tries to set computational region based on that.
It takes the extent from the first layer (raster or vector)
and resolution and alignment from first raster layer.

If user specified the name of saved region during object's initialization,
the provided region is used. If it's not specified
and use_region=True, current region is used.

###### grass.jupyter.region.RegionManagerFor2D.set_region_from_env

```python
set_region_from_env(env)
```

Copies GRASS_REGION from provided environment
to local environment to set the computational region

##### grass.jupyter.region.RegionManagerFor3D

```python
RegionManagerFor3D(use_region, saved_region)
```

Region manager for 3D displays (gets region from m.nviz.image command)

**Functions:**

- [**set_region_from_command**](#grass.jupyter.region.RegionManagerFor3D.set_region_from_command) – Sets computational region for rendering.

Manages region during rendering.

:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

###### grass.jupyter.region.RegionManagerFor3D.set_region_from_command

```python
set_region_from_command(env, **kwargs)
```

Sets computational region for rendering.

This functions identifies a raster map from m.nviz.image command
and tries to set computational region based on that.

If user specified the name of saved region during object's initialization,
the provided region is used. If it's not specified
and use_region=True, current region is used.

##### grass.jupyter.region.RegionManagerForInteractiveMap

```python
RegionManagerForInteractiveMap(use_region, saved_region, src_env, tgt_env)
```

Region manager for an interactive map (gets region from raster and vector)

**Functions:**

- [**set_bbox_vector**](#grass.jupyter.region.RegionManagerForInteractiveMap.set_bbox_vector) – Enlarge bounding box based on vector
- [**set_region_from_raster**](#grass.jupyter.region.RegionManagerForInteractiveMap.set_region_from_raster) – Sets computational region for rendering.

**Attributes:**

- [**bbox**](#grass.jupyter.region.RegionManagerForInteractiveMap.bbox) – Bbox property for accessing maximum bounding box of all rendered layers.
- [**resolution**](#grass.jupyter.region.RegionManagerForInteractiveMap.resolution) – Resolution to be used for reprojection.

Manages region during rendering for interactive map.

:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering
:param src_env: source environment (original projection)
:param tgt_env: target environment (pseudomercator)

###### grass.jupyter.region.RegionManagerForInteractiveMap.bbox

```python
bbox
```

Bbox property for accessing maximum bounding box of all rendered layers.

###### grass.jupyter.region.RegionManagerForInteractiveMap.resolution

```python
resolution
```

Resolution to be used for reprojection.

###### grass.jupyter.region.RegionManagerForInteractiveMap.set_bbox_vector

```python
set_bbox_vector(vector)
```

Enlarge bounding box based on vector

###### grass.jupyter.region.RegionManagerForInteractiveMap.set_region_from_raster

```python
set_region_from_raster(raster)
```

Sets computational region for rendering.

This functions sets computational region based on
a raster map in the target environment.

If user specified the name of saved region during object's initialization,
the provided region is used. If it's not specified
and use_region=True, current region is used.

Also enlarges bounding box based on the raster.

##### grass.jupyter.region.RegionManagerForSeries

```python
RegionManagerForSeries(use_region, saved_region, width, height, env)
```

Region manager for SeriesMap

**Functions:**

- [**set_region_from_rasters**](#grass.jupyter.region.RegionManagerForSeries.set_region_from_rasters) – Sets computational region for rendering from a series of rasters.
- [**set_region_from_vectors**](#grass.jupyter.region.RegionManagerForSeries.set_region_from_vectors) – Sets computational region extent for rendering from a series of vectors

Manages region during rendering.

:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering
:param width: rendering width
:param height: rendering height
:param env: environment for rendering

###### grass.jupyter.region.RegionManagerForSeries.set_region_from_rasters

```python
set_region_from_rasters(rasters)
```

Sets computational region for rendering from a series of rasters.

This function sets the region from a series of rasters. If the extent or
resolution has already been set by calling this function previously or by the
set_region_from vectors() function, this function will not modify it.

If user specified the name of saved region during object's initialization,
the provided region is used. If it's not specified
and use_region=True, current region is used.

###### grass.jupyter.region.RegionManagerForSeries.set_region_from_vectors

```python
set_region_from_vectors(vectors)
```

Sets computational region extent for rendering from a series of vectors

If the extent and resolution has already been set by set_region_from_rasters,
or by using the saved_region or use_region arguments, the region is not modified

##### grass.jupyter.region.RegionManagerForTimeSeries

```python
RegionManagerForTimeSeries(use_region, saved_region, env)
```

Region manager for TimeSeries visualizations.

**Functions:**

- [**set_region_from_timeseries**](#grass.jupyter.region.RegionManagerForTimeSeries.set_region_from_timeseries) – Sets computational region for rendering.

Manages region during rendering.

:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering
:param env: environment for rendering

###### grass.jupyter.region.RegionManagerForTimeSeries.set_region_from_timeseries

```python
set_region_from_timeseries(timeseries)
```

Sets computational region for rendering.

This function sets the computation region from the extent of
a space-time dataset by using its bounding box and resolution.

If user specified the name of saved region during object's initialization,
the provided region is used. If it's not specified
and use_region=True, current region is used.

#### grass.jupyter.reprojection_renderer

Reprojects rasters to Pseudo-Mercator and vectors to WGS84. Exports reprojected
rasters and vectors to PNGs and geoJSONs, respectively.

**Classes:**

- [**ReprojectionRenderer**](#grass.jupyter.reprojection_renderer.ReprojectionRenderer) – This class reprojects rasters and vectors to folium-compatible temporary location

##### grass.jupyter.reprojection_renderer.ReprojectionRenderer

```python
ReprojectionRenderer(use_region=False, saved_region=None, work_dir=None)
```

This class reprojects rasters and vectors to folium-compatible temporary location
and projection.

In preparation to displaying with folium, it saves vectors to geoJSON and rasters to
PNG images.

**Functions:**

- [**get_bbox**](#grass.jupyter.reprojection_renderer.ReprojectionRenderer.get_bbox) – Return bounding box of computation region in WGS84
- [**render_raster**](#grass.jupyter.reprojection_renderer.ReprojectionRenderer.render_raster) – Reprojects raster to Pseudo-Mercator and saves PNG in working directory.
- [**render_vector**](#grass.jupyter.reprojection_renderer.ReprojectionRenderer.render_vector) – Reproject vector to WGS84 and save geoJSON in working directory. Return

Creates Pseudo-Mercator and WGS84 locations. If no work_dir provided, also
creates temporary working directory to contain locations.

param bool use_region: use computational region of current mapset
param str saved_region: name of saved computation region to use
param work_dir: path to directory where locations, files should be written

###### grass.jupyter.reprojection_renderer.ReprojectionRenderer.get_bbox

```python
get_bbox()
```

Return bounding box of computation region in WGS84

###### grass.jupyter.reprojection_renderer.ReprojectionRenderer.render_raster

```python
render_raster(name)
```

Reprojects raster to Pseudo-Mercator and saves PNG in working directory.
Return PNG filename and bounding box of WGS84.

param str name: name of raster

###### grass.jupyter.reprojection_renderer.ReprojectionRenderer.render_vector

```python
render_vector(name)
```

Reproject vector to WGS84 and save geoJSON in working directory. Return
geoJSON filename.

param str name: name of vector

#### grass.jupyter.seriesmap

Create and display visualizations for a series of rasters.

**Classes:**

- [**SeriesMap**](#grass.jupyter.seriesmap.SeriesMap) – Creates visualizations from a series of rasters or vectors in Jupyter

##### grass.jupyter.seriesmap.SeriesMap

```python
SeriesMap(width=None, height=None, env=None, use_region=False, saved_region=None)
```

Bases: <code>[BaseSeriesMap](#grass.jupyter.baseseriesmap.BaseSeriesMap)</code>

Creates visualizations from a series of rasters or vectors in Jupyter
Notebooks.

Basic usage::

> > > series = gj.SeriesMap(height=500)
> > > series.add_rasters(["elevation_shade", "geology", "soils"])
> > > series.add_vectors(["streams", "streets", "viewpoints"])
> > > series.d_barscale()
> > > series.show() # Create Slider
> > > series.save("image.gif")

This class of grass.jupyter is experimental and under development. The API can
change at anytime.

**Functions:**

- [**add_names**](#grass.jupyter.seriesmap.SeriesMap.add_names) – Add list of names associated with layers.
- [**add_rasters**](#grass.jupyter.seriesmap.SeriesMap.add_rasters) – :param list rasters: list of raster layers to add to SeriesMap
- [**add_vectors**](#grass.jupyter.seriesmap.SeriesMap.add_vectors) – :param list vectors: list of vector layers to add to SeriesMap
- [**render**](#grass.jupyter.seriesmap.SeriesMap.render) – Renders image for each raster in series.
- [**save**](#grass.jupyter.seriesmap.SeriesMap.save) – Creates a GIF animation of rendered layers.
- [**show**](#grass.jupyter.seriesmap.SeriesMap.show) – Create interactive timeline slider.

**Attributes:**

- [**base_file**](#grass.jupyter.seriesmap.SeriesMap.base_file) –
- [**baseseries**](#grass.jupyter.seriesmap.SeriesMap.baseseries) –

Creates an instance of the SeriesMap visualizations class.

:param int width: width of map in pixels
:param int height: height of map in pixels
:param str env: environment
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

###### grass.jupyter.seriesmap.SeriesMap.add_names

```python
add_names(names)
```

Add list of names associated with layers.
Default will be names of first series added.

###### grass.jupyter.seriesmap.SeriesMap.add_rasters

```python
add_rasters(rasters, **kwargs)
```

:param list rasters: list of raster layers to add to SeriesMap

###### grass.jupyter.seriesmap.SeriesMap.add_vectors

```python
add_vectors(vectors, **kwargs)
```

:param list vectors: list of vector layers to add to SeriesMap

###### grass.jupyter.seriesmap.SeriesMap.base_file

```python
base_file = None
```

###### grass.jupyter.seriesmap.SeriesMap.baseseries

```python
baseseries = None
```

###### grass.jupyter.seriesmap.SeriesMap.render

```python
render()
```

Renders image for each raster in series.

Save PNGs to temporary directory. Must be run before creating a visualization
(i.e. show or save).

###### grass.jupyter.seriesmap.SeriesMap.save

```python
save(filename, duration=500, label=True, font=None, text_size=12, text_color='gray')
```

Creates a GIF animation of rendered layers.

Text color must be in a format accepted by PIL ImageColor module. For supported
formats, visit:
https://pillow.readthedocs.io/en/stable/reference/ImageColor.html#color-names

param str filename: name of output GIF file
param int duration: time to display each frame; milliseconds
param bool label: include label on each frame
param str font: font file
param int text_size: size of label text
param str text_color: color to use for the text.

###### grass.jupyter.seriesmap.SeriesMap.show

```python
show(slider_width=None)
```

Create interactive timeline slider.

param str slider_width: width of datetime selection slider

The slider_width parameter sets the width of the slider in the output cell.
It should be formatted as a percentage (%) between 0 and 100 of the cell width
or in pixels (px). Values should be formatted as strings and include the "%"
or "px" suffix. For example, slider_width="80%" or slider_width="500px".
slider_width is passed to ipywidgets in ipywidgets.Layout(width=slider_width).

#### grass.jupyter.setup

Initialization GRASS GIS session and its finalization

**Functions:**

- [**init**](#grass.jupyter.setup.init) – Initiates a GRASS session and sets GRASS environment variables.

##### grass.jupyter.setup.init

```python
init(path, location=None, mapset=None, grass_path=None)
```

Initiates a GRASS session and sets GRASS environment variables.

Calling this function returns an object which represents the session.

> > > import grass.jupyter as gj
> > > session = gj.init(...)

The session is ended when `session.finish` is called or when the object is
destroyed when kernel ends or restarts. This function returns a copy of an
internally kept reference, so the return value can be safely ignored when not
needed.

The returned object can be used to switch to another mapset:

> > > session.switch_mapset("mapset_name")

Subsequent calls to the *init* function result in switching the mapset if
a session is active and result in creation of new session if it is not active.
On the other hand, if you see `GISRC - variable not set` after calling
a GRASS module, you know you don't have an active GRASS session.

:param str path: path to GRASS mapset or database
:param str location: name of GRASS location within the database
:param str mapset: name of mapset within location

#### grass.jupyter.timeseriesmap

Create and display visualizations for space-time datasets.

**Classes:**

- [**TimeSeriesMap**](#grass.jupyter.timeseriesmap.TimeSeriesMap) – Creates visualizations of time-space raster and vector datasets in Jupyter

**Functions:**

- [**check_timeseries_exists**](#grass.jupyter.timeseriesmap.check_timeseries_exists) – Check that timeseries is time space dataset
- [**collect_layers**](#grass.jupyter.timeseriesmap.collect_layers) – Create lists of layer names and start_times for a
- [**fill_none_values**](#grass.jupyter.timeseriesmap.fill_none_values) – Replace `None` values in array with previous item

##### grass.jupyter.timeseriesmap.TimeSeriesMap

```python
TimeSeriesMap(width=None, height=None, env=None, use_region=False, saved_region=None)
```

Bases: <code>[BaseSeriesMap](#grass.jupyter.baseseriesmap.BaseSeriesMap)</code>

Creates visualizations of time-space raster and vector datasets in Jupyter
Notebooks.

Basic usage::

> > > img = TimeSeriesMap("series_name")
> > > img.d_legend() # Add legend
> > > img.show() # Create TimeSlider
> > > img.save("image.gif")

This class of grass.jupyter is experimental and under development. The API can
change at anytime.

**Functions:**

- [**add_raster_series**](#grass.jupyter.timeseriesmap.TimeSeriesMap.add_raster_series) – :param str baseseries: name of space-time dataset
- [**add_vector_series**](#grass.jupyter.timeseriesmap.TimeSeriesMap.add_vector_series) – :param str baseseries: name of space-time dataset
- [**d_legend**](#grass.jupyter.timeseriesmap.TimeSeriesMap.d_legend) – Display legend.
- [**render**](#grass.jupyter.timeseriesmap.TimeSeriesMap.render) – Renders image for each time-step in space-time dataset.
- [**save**](#grass.jupyter.timeseriesmap.TimeSeriesMap.save) – Creates a GIF animation of rendered layers.
- [**show**](#grass.jupyter.timeseriesmap.TimeSeriesMap.show) – Create interactive timeline slider.

**Attributes:**

- [**base_file**](#grass.jupyter.timeseriesmap.TimeSeriesMap.base_file) –
- [**baseseries**](#grass.jupyter.timeseriesmap.TimeSeriesMap.baseseries) –

Creates an instance of the TimeSeriesMap visualizations class.

:param int width: width of map in pixels
:param int height: height of map in pixels
:param str env: environment
:param use_region: if True, use either current or provided saved region,
else derive region from rendered layers
:param saved_region: if name of saved_region is provided,
this region is then used for rendering

###### grass.jupyter.timeseriesmap.TimeSeriesMap.add_raster_series

```python
add_raster_series(baseseries, fill_gaps=False)
```

:param str baseseries: name of space-time dataset
:param bool fill_gaps: fill empty time steps with data from previous step

###### grass.jupyter.timeseriesmap.TimeSeriesMap.add_vector_series

```python
add_vector_series(baseseries, fill_gaps=False)
```

:param str baseseries: name of space-time dataset
:param bool fill_gaps: fill empty time steps with data from previous step

###### grass.jupyter.timeseriesmap.TimeSeriesMap.base_file

```python
base_file = None
```

###### grass.jupyter.timeseriesmap.TimeSeriesMap.baseseries

```python
baseseries = None
```

###### grass.jupyter.timeseriesmap.TimeSeriesMap.d_legend

```python
d_legend(**kwargs)
```

Display legend.

Wraps d.legend and uses same keyword arguments.

###### grass.jupyter.timeseriesmap.TimeSeriesMap.render

```python
render()
```

Renders image for each time-step in space-time dataset.

###### grass.jupyter.timeseriesmap.TimeSeriesMap.save

```python
save(filename, duration=500, label=True, font=None, text_size=12, text_color='gray')
```

Creates a GIF animation of rendered layers.

Text color must be in a format accepted by PIL ImageColor module. For supported
formats, visit:
https://pillow.readthedocs.io/en/stable/reference/ImageColor.html#color-names

param str filename: name of output GIF file
param int duration: time to display each frame; milliseconds
param bool label: include label on each frame
param str font: font file
param int text_size: size of label text
param str text_color: color to use for the text.

###### grass.jupyter.timeseriesmap.TimeSeriesMap.show

```python
show(slider_width=None)
```

Create interactive timeline slider.

param str slider_width: width of datetime selection slider

The slider_width parameter sets the width of the slider in the output cell.
It should be formatted as a percentage (%) between 0 and 100 of the cell width
or in pixels (px). Values should be formatted as strings and include the "%"
or "px" suffix. For example, slider_width="80%" or slider_width="500px".
slider_width is passed to ipywidgets in ipywidgets.Layout(width=slider_width).

##### grass.jupyter.timeseriesmap.check_timeseries_exists

```python
check_timeseries_exists(timeseries, element_type)
```

Check that timeseries is time space dataset

##### grass.jupyter.timeseriesmap.collect_layers

```python
collect_layers(timeseries, element_type, fill_gaps)
```

Create lists of layer names and start_times for a
space-time raster or vector dataset.

For datasets with variable time steps, makes step regular with
"gran" method for t.rast.list or t.vect.list then fills in
missing layers with previous time step layer.

:param str timeseries: name of space-time dataset
:param str element_type: element type, "stvds" or "strds"
:param bool fill_gaps: fill empty time steps with data from previous step

##### grass.jupyter.timeseriesmap.fill_none_values

```python
fill_none_values(names)
```

Replace `None` values in array with previous item

#### grass.jupyter.utils

Utility functions warpping existing processes in a suitable way

**Functions:**

- [**estimate_resolution**](#grass.jupyter.utils.estimate_resolution) – Estimates resolution of reprojected raster.
- [**get_location_proj_string**](#grass.jupyter.utils.get_location_proj_string) – Returns projection of environment in PROJ.4 format
- [**get_map_name_from_d_command**](#grass.jupyter.utils.get_map_name_from_d_command) – Returns map name from display command.
- [**get_number_of_cores**](#grass.jupyter.utils.get_number_of_cores) – Get the number of cores to use for multiprocessing.
- [**get_region**](#grass.jupyter.utils.get_region) – Returns current computational region as dictionary.
- [**get_region_bounds_latlon**](#grass.jupyter.utils.get_region_bounds_latlon) – Gets the current computational region bounds in latlon.
- [**get_rendering_size**](#grass.jupyter.utils.get_rendering_size) – Returns the rendering width and height based
- [**query_raster**](#grass.jupyter.utils.query_raster) – Queries raster data at specified coordinates.
- [**query_vector**](#grass.jupyter.utils.query_vector) – Queries vector data at specified coordinates.
- [**reproject_latlon**](#grass.jupyter.utils.reproject_latlon) – Reproject coordinates
- [**reproject_region**](#grass.jupyter.utils.reproject_region) – Reproject boundary of region from one projection to another.
- [**save_gif**](#grass.jupyter.utils.save_gif) – Creates a GIF animation
- [**save_vector**](#grass.jupyter.utils.save_vector) – Saves the user drawn vector.
- [**set_target_region**](#grass.jupyter.utils.set_target_region) – Set target region based on source region.
- [**setup_location**](#grass.jupyter.utils.setup_location) – Setup temporary location with different projection but
- [**update_region**](#grass.jupyter.utils.update_region) – Updates the computational region bounds.

##### grass.jupyter.utils.estimate_resolution

```python
estimate_resolution(raster, mapset, location, dbase, env)
```

Estimates resolution of reprojected raster.

:param raster: name of raster
:param mapset: mapset of raster
:param location: name of source location
:param dbase: path to source database
:param dict env: target environment

:return estimate: estimated resolution of raster in destination environment

##### grass.jupyter.utils.get_location_proj_string

```python
get_location_proj_string(env=None)
```

Returns projection of environment in PROJ.4 format

##### grass.jupyter.utils.get_map_name_from_d_command

```python
get_map_name_from_d_command(module, **kwargs)
```

Returns map name from display command.

Assumes only positional parameters.
When more maps are present (e.g., d.rgb), it returns only 1.
Returns empty string if fails to find it.

##### grass.jupyter.utils.get_number_of_cores

```python
get_number_of_cores(requested, env=None)
```

Get the number of cores to use for multiprocessing.

:param int requested: Desired number of cores.
:param dict env: Optional process environment.

:return int: Number of cores to use, constrained by system availability.

##### grass.jupyter.utils.get_region

```python
get_region(env=None)
```

Returns current computational region as dictionary.

Additionally, it adds long key names.

##### grass.jupyter.utils.get_region_bounds_latlon

```python
get_region_bounds_latlon()
```

Gets the current computational region bounds in latlon.

:return list of tuples: represent the southwest and northeast
corners of the region in (latitude, longitude) format.

##### grass.jupyter.utils.get_rendering_size

```python
get_rendering_size(region, width, height, default_width=600, default_height=400)
```

Returns the rendering width and height based
on the region aspect ratio.

:param dict region: region dictionary
:param integer width: rendering width (can be None)
:param integer height: rendering height (can be None)
:param integer default_width: default rendering width (can be None)
:param integer default_height: default rendering height (can be None)

:return tuple (width, height): adjusted width and height

When both width and height are provided, values are returned without
adjustment. When one value is provided, the other is computed
based on the region aspect ratio. When no dimension is given,
the default width or height is used and the other dimension computed.

##### grass.jupyter.utils.query_raster

```python
query_raster(coord, raster_list)
```

Queries raster data at specified coordinates.

:param coord: Coordinates given as a tuple (latitude, longitude).
:param list raster_list: List of raster names to query.

:return: str: HTML formatted string containing the results of the raster queries.

##### grass.jupyter.utils.query_vector

```python
query_vector(coord, vector_list, distance)
```

Queries vector data at specified coordinates.

:param coord: Coordinates given as a tuple (latitude, longitude).
:param list vector_list: List of vector names to query.
:param distance: Distance within which to query the vector attributes.

:return: str: HTML formatted string containing the results of the vector queries.

##### grass.jupyter.utils.reproject_latlon

```python
reproject_latlon(coord)
```

Reproject coordinates

:param coord: coordinates given as tuple (latitude, longitude)
:return: reprojected coordinates (returned as tuple)

##### grass.jupyter.utils.reproject_region

```python
reproject_region(region, from_proj, to_proj)
```

Reproject boundary of region from one projection to another.

:param dict region: region to reproject as a dictionary with long key names
output of get_region
:param str from_proj: PROJ.4 string of region; output of get_location_proj_string
:param str in_proj: PROJ.4 string of target location;
output of get_location_proj_string

:return dict region: reprojected region as a dictionary with long key names

##### grass.jupyter.utils.save_gif

```python
save_gif(input_files, output_filename, duration=500, label=True, labels=None, font=None, text_size=12, text_color='gray')
```

Creates a GIF animation

param list input_files: list of paths to source
param str output_filename: destination gif filename
param int duration: time to display each frame; milliseconds
param bool label: include label stamp on each frame
param list labels: list of labels for each source image
param str font: font file
param int text_size: size of label text
param str text_color: color to use for the text

##### grass.jupyter.utils.save_vector

```python
save_vector(name, geo_json)
```

Saves the user drawn vector.

:param geo_json: name of the geojson file to be saved
:param name: name with which vector should be saved

##### grass.jupyter.utils.set_target_region

```python
set_target_region(src_env, tgt_env)
```

Set target region based on source region.

Number of rows and columns is preserved.

##### grass.jupyter.utils.setup_location

```python
setup_location(name, path, epsg, src_env)
```

Setup temporary location with different projection but
same computational region as source location

:param str name: name of new location
:param path path: path to new location's database
:param str epsg: EPSG code
:param dict src_env: source environment

:return str rcfile: name of new locations rcfile
:return dict new_env: new environment

##### grass.jupyter.utils.update_region

```python
update_region(region)
```

Updates the computational region bounds.

:param dict region: region dictionary
:return: the new region

### grass.pydispatch

Multi-consumer multi-producer dispatching mechanism

This Python library is used e.g. in wxGUI. The purpose of the library
is to provide mechanism for communication between objects in wxGUI.
The library consists of two parts:

- the Python Signal API which will be used in wxGUI, and
- this 3rd party package PyDispatcher does the hard work.

In short, simple function calls are not sufficient in the GUI, event
driven and large environment with many persistent objects because
using simple function calls would lead to tightly coupled code. Thus,
some better mechanism is needed such as Observer design pattern. In
GRASS GIS, we use the Signal system which is similar to Signals used in
PyQt and other frameworks. As the underlying library, we have chosen
PyDispatcher because it provides very general API which enables to
implement Signal API, wide and robust functionality which makes
implementation and use of Signals easier.

**Modules:**

- [**dispatcher**](#grass.pydispatch.dispatcher) – Multiple-producer-multiple-consumer signal-dispatching
- [**errors**](#grass.pydispatch.errors) – Error types for dispatcher mechanism
- [**robust**](#grass.pydispatch.robust) – Module implementing error-catching version of send (sendRobust)
- [**robustapply**](#grass.pydispatch.robustapply) – Robust apply mechanism
- [**saferef**](#grass.pydispatch.saferef) – Refactored "safe reference" from dispatcher.py
- [**signal**](#grass.pydispatch.signal) – Created on Mon Mar 11 18:39:13 2013

#### grass.pydispatch.dispatcher

Multiple-producer-multiple-consumer signal-dispatching

dispatcher is the core of the PyDispatcher system,
providing the primary API and the core logic for the
system.

Module attributes of note:

```
Any -- Singleton used to signal either "Any Sender" or
    "Any Signal".  See documentation of the _Any class.
Anonymous -- Singleton used to signal "Anonymous Sender"
    See documentation of the _Anonymous class.
```

<details class="internal-attributes" open>
<summary>Internal attributes</summary>
WEAKREF_TYPES -- tuple of types/classes which represent
    weak references to receivers, and thus must be de-
    referenced on retrieval to retrieve the callable
    object
connections -- { senderkey (id) : { signal : [receivers...]}}
senders -- { senderkey (id) : weakref(sender) }
    used for cleaning up sender references on sender
    deletion
sendersBack -- { receiverkey (id) : [senderkey (id)...] }
    used for cleaning up receiver references on receiver
    deletion, (considerably speeds up the cleanup process
    vs. the original code.)
</details>

**Functions:**

- [**connect**](#grass.pydispatch.dispatcher.connect) – Connect receiver to sender for signal
- [**disconnect**](#grass.pydispatch.dispatcher.disconnect) – Disconnect receiver from sender for signal
- [**getAllReceivers**](#grass.pydispatch.dispatcher.getAllReceivers) – Get list of all receivers from global tables
- [**getReceivers**](#grass.pydispatch.dispatcher.getReceivers) – Get list of receivers from global tables
- [**liveReceivers**](#grass.pydispatch.dispatcher.liveReceivers) – Filter sequence of receivers to get resolved, live receivers
- [**send**](#grass.pydispatch.dispatcher.send) – Send signal from sender to all connected receivers.
- [**sendExact**](#grass.pydispatch.dispatcher.sendExact) – Send signal only to those receivers registered for exact message

**Attributes:**

- [**Anonymous**](#grass.pydispatch.dispatcher.Anonymous) –
- [**Any**](#grass.pydispatch.dispatcher.Any) –
- [**WEAKREF_TYPES**](#grass.pydispatch.dispatcher.WEAKREF_TYPES) –
- [**connections**](#grass.pydispatch.dispatcher.connections) –
- [**senders**](#grass.pydispatch.dispatcher.senders) –
- [**sendersBack**](#grass.pydispatch.dispatcher.sendersBack) –

##### grass.pydispatch.dispatcher.Anonymous

```python
Anonymous = _Anonymous()
```

##### grass.pydispatch.dispatcher.Any

```python
Any = _Any()
```

##### grass.pydispatch.dispatcher.WEAKREF_TYPES

```python
WEAKREF_TYPES = (weakref.ReferenceType, saferef.BoundMethodWeakref)
```

##### grass.pydispatch.dispatcher.connect

```python
connect(receiver, signal=Any, sender=Any, weak=True)
```

Connect receiver to sender for signal

receiver -- a callable Python object which is to receive
messages/signals/events. Receivers must be hashable
objects.

```
if weak is True, then receiver must be weak-referencable
(more precisely saferef.safeRef() must be able to create
a reference to the receiver).

Receivers are fairly flexible in their specification,
as the machinery in the robustApply module takes care
of most of the details regarding figuring out appropriate
subsets of the sent arguments to apply to a given
receiver.

Note:
    if receiver is itself a weak reference (a callable),
    it will be de-referenced by the system's machinery,
    so *generally* weak references are not suitable as
    receivers, though some use might be found for the
    facility whereby a higher-level library passes in
    pre-weakrefed receiver references.
```

signal -- the signal to which the receiver should respond

```
if Any, receiver will receive any signal from the
indicated sender (which might also be Any, but is not
necessarily Any).

Otherwise must be a hashable Python object other than
None (DispatcherError raised on None).
```

sender -- the sender to which the receiver should respond

```
if Any, receiver will receive the indicated signals
from any sender.

if Anonymous, receiver will only receive indicated
signals from send/sendExact which do not specify a
sender, or specify Anonymous explicitly as the sender.

Otherwise can be any python object.
```

weak -- whether to use weak references to the receiver
By default, the module will attempt to use weak
references to the receiver objects. If this parameter
is false, then strong references will be used.

returns None, may raise DispatcherTypeError

##### grass.pydispatch.dispatcher.connections

```python
connections = {}
```

##### grass.pydispatch.dispatcher.disconnect

```python
disconnect(receiver, signal=Any, sender=Any, weak=True)
```

Disconnect receiver from sender for signal

receiver -- the registered receiver to disconnect
signal -- the registered signal to disconnect
sender -- the registered sender to disconnect
weak -- the weakref state to disconnect

disconnect reverses the process of connect,
the semantics for the individual elements are
logically equivalent to a tuple of
(receiver, signal, sender, weak) used as a key
to be deleted from the internal routing tables.
(The actual process is slightly more complex
but the semantics are basically the same).

<details class="note" open>
<summary>Note</summary>
Using disconnect is not required to cleanup
routing when an object is deleted, the framework
will remove routes for deleted objects
automatically.  It's only necessary to disconnect
if you want to stop routing to a live object.
</details>

returns None, may raise DispatcherTypeError or
DispatcherKeyError

##### grass.pydispatch.dispatcher.getAllReceivers

```python
getAllReceivers(sender=Any, signal=Any)
```

Get list of all receivers from global tables

This gets all receivers which should receive
the given signal from sender, each receiver should
be produced only once by the resulting generator

##### grass.pydispatch.dispatcher.getReceivers

```python
getReceivers(sender=Any, signal=Any)
```

Get list of receivers from global tables

This utility function allows you to retrieve the
raw list of receivers from the connections table
for the given sender and signal pair.

<details class="note" open>
<summary>Note</summary>
there is no guarantee that this is the actual list
stored in the connections table, so the value
should be treated as a simple iterable/truth value
rather than, for instance a list to which you
might append new records.
</details>

Normally you would use liveReceivers(getReceivers(...))
to retrieve the actual receiver objects as an iterable
object.

##### grass.pydispatch.dispatcher.liveReceivers

```python
liveReceivers(receivers)
```

Filter sequence of receivers to get resolved, live receivers

This is a generator which will iterate over
the passed sequence, checking for weak references
and resolving them, then returning all live
receivers.

##### grass.pydispatch.dispatcher.send

```python
send(signal=Any, sender=Anonymous, *arguments, **named)
```

Send signal from sender to all connected receivers.

signal -- (hashable) signal value, see connect for details

sender -- the sender of the signal

```
if Any, only receivers registered for Any will receive
the message.

if Anonymous, only receivers registered to receive
messages from Anonymous or Any will receive the message

Otherwise can be any python object (normally one
registered with a connect if you actually want
something to occur).
```

arguments -- positional arguments which will be passed to
*all* receivers. Note that this may raise TypeErrors
if the receivers do not allow the particular arguments.
Note also that arguments are applied before named
arguments, so they should be used with care.

named -- named arguments which will be filtered according
to the parameters of the receivers to only provide those
acceptable to the receiver.

Return a list of tuple pairs [(receiver, response), ... ]

if any receiver raises an error, the error propagates back
through send, terminating the dispatch loop, so it is quite
possible to not have all receivers called if a raises an
error.

##### grass.pydispatch.dispatcher.sendExact

```python
sendExact(signal=Any, sender=Anonymous, *arguments, **named)
```

Send signal only to those receivers registered for exact message

sendExact allows for avoiding Any/Anonymous registered
handlers, sending only to those receivers explicitly
registered for a particular signal on a particular
sender.

##### grass.pydispatch.dispatcher.senders

```python
senders = {}
```

##### grass.pydispatch.dispatcher.sendersBack

```python
sendersBack = {}
```

#### grass.pydispatch.errors

Error types for dispatcher mechanism

**Classes:**

- [**DispatcherError**](#grass.pydispatch.errors.DispatcherError) – Base class for all Dispatcher errors
- [**DispatcherKeyError**](#grass.pydispatch.errors.DispatcherKeyError) – Error raised when unknown (sender,signal) set specified
- [**DispatcherTypeError**](#grass.pydispatch.errors.DispatcherTypeError) – Error raised when inappropriate signal-type specified (None)

##### grass.pydispatch.errors.DispatcherError

Bases: <code>[Exception](#Exception)</code>

Base class for all Dispatcher errors

##### grass.pydispatch.errors.DispatcherKeyError

Bases: <code>[KeyError](#KeyError)</code>, <code>[DispatcherError](#grass.pydispatch.errors.DispatcherError)</code>

Error raised when unknown (sender,signal) set specified

##### grass.pydispatch.errors.DispatcherTypeError

Bases: <code>[TypeError](#TypeError)</code>, <code>[DispatcherError](#grass.pydispatch.errors.DispatcherError)</code>

Error raised when inappropriate signal-type specified (None)

#### grass.pydispatch.robust

Module implementing error-catching version of send (sendRobust)

**Functions:**

- [**sendRobust**](#grass.pydispatch.robust.sendRobust) – Send signal from sender to all connected receivers catching errors

##### grass.pydispatch.robust.sendRobust

```python
sendRobust(signal=Any, sender=Anonymous, *arguments, **named)
```

Send signal from sender to all connected receivers catching errors

signal -- (hashable) signal value, see connect for details

sender -- the sender of the signal

```
if Any, only receivers registered for Any will receive
the message.

if Anonymous, only receivers registered to receive
messages from Anonymous or Any will receive the message

Otherwise can be any python object (normally one
registered with a connect if you actually want
something to occur).
```

arguments -- positional arguments which will be passed to
*all* receivers. Note that this may raise TypeErrors
if the receivers do not allow the particular arguments.
Note also that arguments are applied before named
arguments, so they should be used with care.

named -- named arguments which will be filtered according
to the parameters of the receivers to only provide those
acceptable to the receiver.

Return a list of tuple pairs [(receiver, response), ... ]

if any receiver raises an error (specifically any subclass of Exception),
the error instance is returned as the result for that receiver.

#### grass.pydispatch.robustapply

Robust apply mechanism

Provides a function "call", which can sort out
what arguments a given callable object can take,
and subset the given arguments to match only
those which are acceptable.

**Functions:**

- [**function**](#grass.pydispatch.robustapply.function) – Get function-like callable object for given receiver
- [**robustApply**](#grass.pydispatch.robustapply.robustApply) – Call receiver with arguments and an appropriate subset of named

**Attributes:**

- [**VAR_ARGS**](#grass.pydispatch.robustapply.VAR_ARGS) –
- [**VAR_NAMES**](#grass.pydispatch.robustapply.VAR_NAMES) –
- [**func_code**](#grass.pydispatch.robustapply.func_code) –
- [**im_code**](#grass.pydispatch.robustapply.im_code) –
- [**im_func**](#grass.pydispatch.robustapply.im_func) –
- [**im_self**](#grass.pydispatch.robustapply.im_self) –

##### grass.pydispatch.robustapply.VAR_ARGS

```python
VAR_ARGS = 4
```

##### grass.pydispatch.robustapply.VAR_NAMES

```python
VAR_NAMES = 8
```

##### grass.pydispatch.robustapply.func_code

```python
func_code = '__code__'
```

##### grass.pydispatch.robustapply.function

```python
function(receiver)
```

Get function-like callable object for given receiver

returns (function_or_method, codeObject, fromMethod)

If fromMethod is true, then the callable already
has its first argument bound

##### grass.pydispatch.robustapply.im_code

```python
im_code = '__code__'
```

##### grass.pydispatch.robustapply.im_func

```python
im_func = '__func__'
```

##### grass.pydispatch.robustapply.im_self

```python
im_self = '__self__'
```

##### grass.pydispatch.robustapply.robustApply

```python
robustApply(receiver, *arguments, **named)
```

Call receiver with arguments and an appropriate subset of named

The effect of this wrapper is to allow for specifying a large number
of parameters which may not exist in the final function via named
parameters, and have those parameters ignored in the final call.

#### grass.pydispatch.saferef

Refactored "safe reference" from dispatcher.py

**Classes:**

- [**BoundMethodWeakref**](#grass.pydispatch.saferef.BoundMethodWeakref) – 'Safe' and reusable weak references to instance methods

**Functions:**

- [**safeRef**](#grass.pydispatch.saferef.safeRef) – Return a *safe* weak reference to a callable target

**Attributes:**

- [**im_func**](#grass.pydispatch.saferef.im_func) –
- [**im_self**](#grass.pydispatch.saferef.im_self) –

##### grass.pydispatch.saferef.BoundMethodWeakref

```python
BoundMethodWeakref(target, onDelete=None)
```

'Safe' and reusable weak references to instance methods

BoundMethodWeakref objects provide a mechanism for
referencing a bound method without requiring that the
method object itself (which is normally a transient
object) is kept alive. Instead, the BoundMethodWeakref
object keeps weak references to both the object and the
function which together define the instance method.

<details class="class-attributes" open>
<summary>Class Attributes</summary>
_allInstances -- class attribute pointing to all live
    BoundMethodWeakref objects indexed by the class's
    calculateKey(target) method applied to the target
    objects.  This weak value dictionary is used to
    short-circuit creation so that multiple references
    to the same (object, function) pair produce the
    same BoundMethodWeakref instance.
</details>

**Functions:**

- [**calculateKey**](#grass.pydispatch.saferef.BoundMethodWeakref.calculateKey) – Calculate the reference key for this reference

**Attributes:**

- [**deletionMethods**](#grass.pydispatch.saferef.BoundMethodWeakref.deletionMethods) –
- [**funcName**](#grass.pydispatch.saferef.BoundMethodWeakref.funcName) –
- [**key**](#grass.pydispatch.saferef.BoundMethodWeakref.key) –
- [**selfName**](#grass.pydispatch.saferef.BoundMethodWeakref.selfName) –
- [**weakFunc**](#grass.pydispatch.saferef.BoundMethodWeakref.weakFunc) –
- [**weakSelf**](#grass.pydispatch.saferef.BoundMethodWeakref.weakSelf) –

Return a weak-reference-like instance for a bound method

target -- the instance-method target for the weak
reference, must have \<im_self> and \<im_func> attributes
and be reconstructable via:
target.\<im_func>.__get__( target.\<im_self> )
which is true of built-in instance methods.
onDelete -- optional callback which will be called
when this weak reference ceases to be valid
(i.e. either the object or the function is garbage
collected). Should take a single argument,
which will be passed a pointer to this object.

###### grass.pydispatch.saferef.BoundMethodWeakref.calculateKey

```python
calculateKey(target)
```

Calculate the reference key for this reference

Currently this is a two-tuple of the id()'s of the
target object and the target function respectively.

###### grass.pydispatch.saferef.BoundMethodWeakref.deletionMethods

```python
deletionMethods = [onDelete]
```

###### grass.pydispatch.saferef.BoundMethodWeakref.funcName

```python
funcName = str(getattr(target, im_func).__name__)
```

###### grass.pydispatch.saferef.BoundMethodWeakref.key

```python
key = self.calculateKey(target)
```

###### grass.pydispatch.saferef.BoundMethodWeakref.selfName

```python
selfName = getattr(target, im_self).__class__.__name__
```

###### grass.pydispatch.saferef.BoundMethodWeakref.weakFunc

```python
weakFunc = weakref.ref(getattr(target, im_func), remove)
```

###### grass.pydispatch.saferef.BoundMethodWeakref.weakSelf

```python
weakSelf = weakref.ref(getattr(target, im_self), remove)
```

##### grass.pydispatch.saferef.im_func

```python
im_func = '__func__'
```

##### grass.pydispatch.saferef.im_self

```python
im_self = '__self__'
```

##### grass.pydispatch.saferef.safeRef

```python
safeRef(target, onDelete=None)
```

Return a *safe* weak reference to a callable target

target -- the object to be weakly referenced, if it's a
bound method reference, will create a BoundMethodWeakref,
otherwise creates a simple weakref.
onDelete -- if provided, will have a hard reference stored
to the callable to be called after the safe reference
goes out of scope with the reference object, (either a
weakref or a BoundMethodWeakref) as argument.

#### grass.pydispatch.signal

Created on Mon Mar 11 18:39:13 2013

@author Vaclav Petras <wenzeslaus gmail.com>

**Classes:**

- [**Signal**](#grass.pydispatch.signal.Signal) – The signal object is created usually as a instance attribute.

##### grass.pydispatch.signal.Signal

```python
Signal(name)
```

The signal object is created usually as a instance attribute.
However, it can be created anywhere.

> > > signal1 = Signal("signal1")

The function has to be connected to a signal in order to be called when
the signal is emitted. The connection can be done where the function is
defined (e. g., a class) but also on some other place, typically,
user of a class connects some signal to the method of some other class.

> > > def handler1():
> > > ... print "from handler1"
> > > signal1.connect(handler1)

Emitting of the signal is done usually only in the class which has the
signal as a instance attribute. Again, generally, it can be emitted
anywhere.

> > > signal1.emit()
> > > from handler1

The signal can have parameters. These parameters are specified when
emitting but should be documented together with the signal (e.g., in the
class documentation). Parameters should be keyword arguments and handlers
must use these names (if the names cannot be the same, lambda function
can be used to overcome this problem).

> > > signal2 = Signal("signal2")
> > > def handler2(text):
> > > ... print "handler2: %s" % text
> > > signal2.connect(handler2)
> > > signal2.emit(text="Hello")
> > > handler2: Hello

Do not emit the same signal with different parameters when emitting at
different places.

A handler is the standard function, lambda function, method or any other
callable object.

> > > import sys
> > > signal2.connect(lambda text: sys.stdout.write("lambda handler: %s\\n" % text))
> > > signal2.emit(text="Hi")
> > > handler2: Hi
> > > lambda handler: Hi

The handler function can have only some of the signal parameters or no
parameters at all even if the signal has some.

> > > def handler3():
> > > ... print "from handler3"
> > > signal2.connect(handler3)
> > > signal2.emit(text="Ciao")
> > > handler2: Ciao
> > > lambda handler: Ciao
> > > from handler3

It is possible to use signal as a handler. By this, signals can be
forwarded from one object to another. In other words, one object can
expose signal of some object.

> > > signal3 = Signal("signal3")
> > > signal3.connect(handler3)
> > > signal1.connect(signal3)
> > > signal1.emit()
> > > from handler1
> > > from handler3

It is possible to disconnect a particular handler.

> > > signal3.disconnect(handler3)
> > > signal1.emit()
> > > from handler1
> > > signal2.disconnect(handler2)
> > > signal2.disconnect(handler3)
> > > signal2.emit(text="Hello")
> > > lambda handler: Hello

**Functions:**

- [**connect**](#grass.pydispatch.signal.Signal.connect) – Connects handler to a signal.
- [**disconnect**](#grass.pydispatch.signal.Signal.disconnect) – Disconnects a specified handler.
- [**emit**](#grass.pydispatch.signal.Signal.emit) – Emits the signal which means that all connected handlers will be

Creates a signal object.

The parameter name is used for debugging.

###### grass.pydispatch.signal.Signal.connect

```python
connect(handler, weak=None)
```

Connects handler to a signal.

Typically, a signal is defined in some class and the user of this
class connects to the signal::

```
from module import SomeClass

...
self.someObject = SomeClass()
self.someObject.connect(self.someMethod)
```

Usually, it is not needed to set the weak parameter. This method
creates weak references for all handlers but for lambda functions, it
automatically creates (standard) references (otherwise, lambdas would be
garbage collected. If you want to force some behaviour, specify the
weak parameter.

> > > signal1 = Signal("signal1")
> > > import sys
> > > signal1.connect(lambda: sys.stdout.write("will print\\n"))
> > > signal1.connect(lambda: sys.stdout.write("will print\\n"), weak=False)
> > > signal1.connect(lambda: sys.stdout.write("will not print"), weak=True)
> > > signal1.emit()
> > > will print
> > > will print

###### grass.pydispatch.signal.Signal.disconnect

```python
disconnect(handler, weak=True)
```

Disconnects a specified handler.

It is not necessary to disconnect object when it is deleted.
Underlying PyDispatcher will take care of connections to deleted
objects.

> > > signal1 = Signal("signal1")
> > > import sys
> > > signal1.connect(sys.stdout.write)
> > > signal1.disconnect(sys.stdout.write)

The weak parameter of must have the same value as for connection.
If you not specified the parameter when connecting,
you don't have to specify it when disconnecting.

Disconnecting the not-connected handler will result in error.

> > > signal1.disconnect(sys.stdout.flush) # doctest: +ELLIPSIS
> > > Traceback (most recent call last):
> > > DispatcherKeyError: 'No receivers found for signal ...'

Disconnecting the non-exiting or unknown handler will result in error.

> > > signal1.disconnect(some_function)
> > > Traceback (most recent call last):
> > > NameError: name 'some_function' is not defined
> > > signal1.emit()

###### grass.pydispatch.signal.Signal.emit

```python
emit(*args, **kwargs)
```

Emits the signal which means that all connected handlers will be
called.

It is advised to have signals as instance attributes and emit signals
only in the class which owns the signal::

```
class Abc(object):
    def __init__(self):
        self.colorChanged = Signal("Abc.colorChanged")
        ...

    def setColor(self, color):
        ...
        self.colorChanged.emit(oldColor=self.Color, newColor=color)
        ...
```

Documentation of an signal should be placed to the class documentation
or to the code (this need to be more specified).

Calling a signal from outside the class is usually not good
practice. The only case when it is permitted is when signal is the part
of some globaly shared object and permission to emit is stayed in the
documentation.

The parameters of the emit function must be the same as the parameters
of the handlers. However, handler can omit some parameters.
The associated parameters shall be documented for each Signal instance.
Use only keyword arguments when emitting.

> > > signal1 = Signal("signal1")
> > > def mywrite(text):
> > > ... print text
> > > signal1.connect(mywrite)
> > > signal1.emit(text="Hello")
> > > Hello
> > > signal1.emit()
> > > Traceback (most recent call last):
> > > TypeError: mywrite() takes exactly 1 argument (0 given)
> > > signal1.emit("Hello")
> > > Traceback (most recent call last):
> > > TypeError: send() got multiple values for keyword argument 'signal'

### grass.pygrass

**Modules:**

- [**errors**](#grass.pygrass.errors) –
- [**gis**](#grass.pygrass.gis) –
- [**messages**](#grass.pygrass.messages) – @package grass.pygrass.messages
- [**modules**](#grass.pygrass.modules) –
- [**raster**](#grass.pygrass.raster) –
- [**rpc**](#grass.pygrass.rpc) – Fast and exit-safe interface to PyGRASS Raster and Vector layer
- [**shell**](#grass.pygrass.shell) –
- [**tests**](#grass.pygrass.tests) –
- [**utils**](#grass.pygrass.utils) –
- [**vector**](#grass.pygrass.vector) –

#### grass.pygrass.errors

**Functions:**

- [**mapinfo_must_be_set**](#grass.pygrass.errors.mapinfo_must_be_set) –
- [**must_be_in_current_mapset**](#grass.pygrass.errors.must_be_in_current_mapset) –
- [**must_be_open**](#grass.pygrass.errors.must_be_open) –

##### grass.pygrass.errors.mapinfo_must_be_set

```python
mapinfo_must_be_set(method)
```

##### grass.pygrass.errors.must_be_in_current_mapset

```python
must_be_in_current_mapset(method)
```

##### grass.pygrass.errors.must_be_open

```python
must_be_open(method)
```

#### grass.pygrass.gis

**Modules:**

- [**region**](#grass.pygrass.gis.region) – Created on Fri May 25 12:57:10 2012

**Classes:**

- [**Gisdbase**](#grass.pygrass.gis.Gisdbase) – Return Gisdbase object. ::
- [**Location**](#grass.pygrass.gis.Location) – Location object ::
- [**Mapset**](#grass.pygrass.gis.Mapset) – Mapset ::
- [**VisibleMapset**](#grass.pygrass.gis.VisibleMapset) – VisibleMapset object

**Functions:**

- [**is_valid**](#grass.pygrass.gis.is_valid) – Private function to check the correctness of a value.
- [**make_mapset**](#grass.pygrass.gis.make_mapset) – Create a new mapset
- [**set_current_mapset**](#grass.pygrass.gis.set_current_mapset) – Set the current mapset as working area

**Attributes:**

- [**CHECK_IS**](#grass.pygrass.gis.CHECK_IS) –
- [**ETYPE**](#grass.pygrass.gis.ETYPE) –
- [**mset**](#grass.pygrass.gis.mset) –
- [**test_raster_name**](#grass.pygrass.gis.test_raster_name) –
- [**test_vector_name**](#grass.pygrass.gis.test_vector_name) –

##### grass.pygrass.gis.CHECK_IS

```python
CHECK_IS = {'GISBASE': libgis.G_is_gisbase, 'GISDBASE': lambda x: True, 'LOCATION_NAME': libgis.G_is_location, 'MAPSET': libgis.G_is_mapset}
```

##### grass.pygrass.gis.ETYPE

```python
ETYPE = {'raster': libgis.G_ELEMENT_RASTER, 'raster_3d': libgis.G_ELEMENT_RASTER3D, 'vector': libgis.G_ELEMENT_VECTOR, 'label': libgis.G_ELEMENT_LABEL, 'region': libgis.G_ELEMENT_REGION, 'group': libgis.G_ELEMENT_GROUP}
```

##### grass.pygrass.gis.Gisdbase

```python
Gisdbase(gisdbase='')
```

Return Gisdbase object. ::

```
>>> from grass.script.core import gisenv
>>> gisdbase = Gisdbase()
>>> gisdbase.name == gisenv()["GISDBASE"]
True
```

..

**Functions:**

- [**locations**](#grass.pygrass.gis.Gisdbase.locations) – Return a list of locations that are available in the gisdbase: ::
- [**new_location**](#grass.pygrass.gis.Gisdbase.new_location) –

**Attributes:**

- [**name**](#grass.pygrass.gis.Gisdbase.name) –

###### grass.pygrass.gis.Gisdbase.locations

```python
locations()
```

Return a list of locations that are available in the gisdbase: ::

```
>>> gisdbase = Gisdbase()
>>> gisdbase.locations()  # doctest: +ELLIPSIS
[...]
```

..

###### grass.pygrass.gis.Gisdbase.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set or obtain the name of GISDBASE')
```

###### grass.pygrass.gis.Gisdbase.new_location

```python
new_location()
```

##### grass.pygrass.gis.Location

```python
Location(location='', gisdbase='')
```

Location object ::

```
>>> from grass.script.core import gisenv
>>> location = Location()
>>> location  # doctest: +ELLIPSIS
Location(...)
>>> location.gisdbase == gisenv()["GISDBASE"]
True
>>> location.name == gisenv()["LOCATION_NAME"]
True
```

..

**Functions:**

- [**mapsets**](#grass.pygrass.gis.Location.mapsets) – Return a list of the available mapsets.
- [**path**](#grass.pygrass.gis.Location.path) – Return the complete path of the location

**Attributes:**

- [**gisdbase**](#grass.pygrass.gis.Location.gisdbase) –
- [**name**](#grass.pygrass.gis.Location.name) –

###### grass.pygrass.gis.Location.gisdbase

```python
gisdbase = property(fget=_get_gisdb, fset=_set_gisdb, doc='Set or obtain the name of GISDBASE')
```

###### grass.pygrass.gis.Location.mapsets

```python
mapsets(pattern=None, permissions=True)
```

Return a list of the available mapsets.

:param pattern: the pattern to filter the result
:type pattern: str
:param permissions: check the permission of mapset
:type permissions: bool
:return: a list of mapset's names
:rtype: list of strings

::

```
>>> location = Location()
>>> sorted(location.mapsets())                # doctest: +ELLIPSIS
[...]
```

###### grass.pygrass.gis.Location.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set or obtain the name of LOCATION')
```

###### grass.pygrass.gis.Location.path

```python
path()
```

Return the complete path of the location

##### grass.pygrass.gis.Mapset

```python
Mapset(mapset='', location='', gisdbase='')
```

Mapset ::

```
>>> from grass.script.core import gisenv
>>> genv = gisenv()
>>> mapset = Mapset()
>>> mapset  # doctest: +ELLIPSIS
Mapset(...)
>>> mapset.gisdbase == genv["GISDBASE"]
True
>>> mapset.location == genv["LOCATION_NAME"]
True
>>> mapset.name == genv["MAPSET"]
True
```

..

**Functions:**

- [**current**](#grass.pygrass.gis.Mapset.current) – Set the mapset as current
- [**delete**](#grass.pygrass.gis.Mapset.delete) – Delete the mapset
- [**glist**](#grass.pygrass.gis.Mapset.glist) – Return a list of grass types like:
- [**is_current**](#grass.pygrass.gis.Mapset.is_current) – Check if the MAPSET is the working MAPSET
- [**path**](#grass.pygrass.gis.Mapset.path) – Return the complete path of the mapset

**Attributes:**

- [**gisdbase**](#grass.pygrass.gis.Mapset.gisdbase) –
- [**location**](#grass.pygrass.gis.Mapset.location) –
- [**name**](#grass.pygrass.gis.Mapset.name) –
- [**visible**](#grass.pygrass.gis.Mapset.visible) –

###### grass.pygrass.gis.Mapset.current

```python
current()
```

Set the mapset as current

###### grass.pygrass.gis.Mapset.delete

```python
delete()
```

Delete the mapset

###### grass.pygrass.gis.Mapset.gisdbase

```python
gisdbase = property(fget=_get_gisdb, fset=_set_gisdb, doc='Set or obtain the name of GISDBASE')
```

###### grass.pygrass.gis.Mapset.glist

```python
glist(type, pattern=None)
```

Return a list of grass types like:

```
* 'group',
* 'label',
* 'raster',
* 'raster_3d',
* 'region',
* 'vector',
```

:param type: the type of element to query
:type type: str
:param pattern: the pattern to filter the result
:type pattern: str

::

```
>>> mapset = Mapset()
>>> mapset.current()
>>> rast = mapset.glist('raster')
>>> test_raster_name in rast
True
>>> vect = mapset.glist('vector')
>>> test_vector_name in vect
True
```

..

###### grass.pygrass.gis.Mapset.is_current

```python
is_current()
```

Check if the MAPSET is the working MAPSET

###### grass.pygrass.gis.Mapset.location

```python
location = property(fget=_get_loc, fset=_set_loc, doc='Set or obtain the name of LOCATION')
```

###### grass.pygrass.gis.Mapset.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set or obtain the name of MAPSET')
```

###### grass.pygrass.gis.Mapset.path

```python
path()
```

Return the complete path of the mapset

###### grass.pygrass.gis.Mapset.visible

```python
visible = VisibleMapset(self.name, self.location, self.gisdbase)
```

##### grass.pygrass.gis.VisibleMapset

```python
VisibleMapset(mapset, location='', gisdbase='')
```

VisibleMapset object

**Functions:**

- [**add**](#grass.pygrass.gis.VisibleMapset.add) – Add a mapset to the search path
- [**extend**](#grass.pygrass.gis.VisibleMapset.extend) – Add more mapsets to the search path
- [**read**](#grass.pygrass.gis.VisibleMapset.read) – Return the mapsets in the search path
- [**remove**](#grass.pygrass.gis.VisibleMapset.remove) – Remove mapset to the search path
- [**reset**](#grass.pygrass.gis.VisibleMapset.reset) – Reset to the original search path

**Attributes:**

- [**location**](#grass.pygrass.gis.VisibleMapset.location) –
- [**mapset**](#grass.pygrass.gis.VisibleMapset.mapset) –
- [**spath**](#grass.pygrass.gis.VisibleMapset.spath) –

###### grass.pygrass.gis.VisibleMapset.add

```python
add(mapset)
```

Add a mapset to the search path

:param mapset: a mapset's name
:type mapset: str

###### grass.pygrass.gis.VisibleMapset.extend

```python
extend(mapsets)
```

Add more mapsets to the search path

:param mapsets: a list of mapset's names
:type mapsets: list

###### grass.pygrass.gis.VisibleMapset.location

```python
location = Location(location, gisdbase)
```

###### grass.pygrass.gis.VisibleMapset.mapset

```python
mapset = mapset
```

###### grass.pygrass.gis.VisibleMapset.read

```python
read()
```

Return the mapsets in the search path

###### grass.pygrass.gis.VisibleMapset.remove

```python
remove(mapset)
```

Remove mapset to the search path

:param mapset: a mapset's name
:type mapset: str

###### grass.pygrass.gis.VisibleMapset.reset

```python
reset()
```

Reset to the original search path

###### grass.pygrass.gis.VisibleMapset.spath

```python
spath = join(self.location.path(), self.mapset, 'SEARCH_PATH')
```

##### grass.pygrass.gis.is_valid

```python
is_valid(value, path, type)
```

Private function to check the correctness of a value.

:param value: Name of the directory
:type value: str

:param path: Path where the directory is located
:type path: path

:param type: it is a string defining the type that will e checked,
valid types are: GISBASE, GISDBASE, LOCATION_NAME, MAPSET
:type type: str

:return: True if valid else False
:rtype: str

##### grass.pygrass.gis.make_mapset

```python
make_mapset(mapset, location=None, gisdbase=None)
```

Create a new mapset

:param mapset: Name of the mapset
:type value: str

:param location: Name of the location
:type location: str

:param gisdbase: Name of the gisdbase
:type gisdbase: str

##### grass.pygrass.gis.mset

```python
mset = utils.get_mapset_vector(test_vector_name, mapset='')
```

##### grass.pygrass.gis.region

Created on Fri May 25 12:57:10 2012

@author: Pietro Zambelli

**Classes:**

- [**Region**](#grass.pygrass.gis.region.Region) – This class is design to easily access and modify GRASS computational

**Attributes:**

- [**mset**](#grass.pygrass.gis.region.mset) –
- [**test_raster_name**](#grass.pygrass.gis.region.test_raster_name) –
- [**test_vector_name**](#grass.pygrass.gis.region.test_vector_name) –

###### grass.pygrass.gis.region.Region

```python
Region(default=False)
```

This class is design to easily access and modify GRASS computational
region. ::

```
>>> r = Region()
>>> r.north
40.0
>>> r.south
0.0
>>> r.east
40.0
>>> r.west
0.0
>>> r.cols
20
>>> r.rows
20
>>> r.nsres
2.0
>>> r.ewres
2.0

>>> r.north = 100
>>> r.east = 100
>>> r.adjust(rows=True, cols=True)
>>> r.nsres
5.0
>>> r.ewres
5.0
>>> r.cols
20
>>> r.rows
20

>>> r.read()
>>> r.north = 100
>>> r.east = 100
>>> r.adjust(rows=False, cols=True)
>>> r.nsres
2.0
>>> r.ewres
5.0
>>> r.cols
20
>>> r.rows
50

>>> r.read()
>>> r.north = 100
>>> r.east = 100
>>> r.adjust(rows=True, cols=False)
>>> r.nsres
5.0
>>> r.ewres
2.0
>>> r.cols
50
>>> r.rows
20

>>> r.read()
>>> r.north = 100
>>> r.east = 100
>>> r.adjust(rows=False, cols=False)
>>> r.nsres
2.0
>>> r.ewres
2.0
>>> r.cols
50
>>> r.rows
50

>>> r.read()
>>> r.cols = 1000
>>> r.ewres
0.04
>>> r.rows = 1000
>>> r.nsres
0.04
```

..

**Functions:**

- [**adjust**](#grass.pygrass.gis.region.Region.adjust) – Adjust rows and cols number according with the nsres and ewres
- [**align**](#grass.pygrass.gis.region.Region.align) – Adjust region cells to cleanly align with this raster map
- [**byref**](#grass.pygrass.gis.region.Region.byref) – Return the internal region representation as pointer
- [**from_rast**](#grass.pygrass.gis.region.Region.from_rast) – Set the region from the computational region
- [**from_vect**](#grass.pygrass.gis.region.Region.from_vect) – Adjust bounding box of region using a vector
- [**get_bbox**](#grass.pygrass.gis.region.Region.get_bbox) – Return a Bbox object with the extension of the region. ::
- [**get_current**](#grass.pygrass.gis.region.Region.get_current) – Get the current working region of this process
- [**items**](#grass.pygrass.gis.region.Region.items) – Return a list of tuple with key and value.
- [**keys**](#grass.pygrass.gis.region.Region.keys) – Return a list of valid keys. ::
- [**read**](#grass.pygrass.gis.region.Region.read) – Read the region into this region object
- [**read_default**](#grass.pygrass.gis.region.Region.read_default) – Get the default region
- [**set_bbox**](#grass.pygrass.gis.region.Region.set_bbox) – Set region extent from Bbox
- [**set_current**](#grass.pygrass.gis.region.Region.set_current) – Set the current working region from this region object
- [**set_raster_region**](#grass.pygrass.gis.region.Region.set_raster_region) – Set the computational region (window) for all raster maps in the current
- [**write**](#grass.pygrass.gis.region.Region.write) – Writes the region from this region object
- [**zoom**](#grass.pygrass.gis.region.Region.zoom) – Shrink region until it meets non-NULL data from this raster map

**Attributes:**

- [**bottom**](#grass.pygrass.gis.region.Region.bottom) –
- [**c_region**](#grass.pygrass.gis.region.Region.c_region) –
- [**cells**](#grass.pygrass.gis.region.Region.cells) – Return the number of cells
- [**cols**](#grass.pygrass.gis.region.Region.cols) –
- [**depths**](#grass.pygrass.gis.region.Region.depths) –
- [**east**](#grass.pygrass.gis.region.Region.east) –
- [**ewres**](#grass.pygrass.gis.region.Region.ewres) –
- [**north**](#grass.pygrass.gis.region.Region.north) –
- [**nsres**](#grass.pygrass.gis.region.Region.nsres) –
- [**proj**](#grass.pygrass.gis.region.Region.proj) – Return a code for projection
- [**rows**](#grass.pygrass.gis.region.Region.rows) –
- [**south**](#grass.pygrass.gis.region.Region.south) –
- [**tbres**](#grass.pygrass.gis.region.Region.tbres) –
- [**top**](#grass.pygrass.gis.region.Region.top) –
- [**west**](#grass.pygrass.gis.region.Region.west) –
- [**zone**](#grass.pygrass.gis.region.Region.zone) – Return the zone of projection

####### grass.pygrass.gis.region.Region.adjust

```python
adjust(rows=False, cols=False)
```

Adjust rows and cols number according with the nsres and ewres
resolutions. If rows or cols parameters are True, the adjust method
update nsres and ewres according with the rows and cols numbers.

####### grass.pygrass.gis.region.Region.align

```python
align(raster_name)
```

Adjust region cells to cleanly align with this raster map

Warning: This will change the user GRASS region settings

:param raster_name: the name of raster
:type raster_name: str

####### grass.pygrass.gis.region.Region.bottom

```python
bottom = property(fget=_get_b, fset=_set_b, doc='Set and obtain bottom value')
```

####### grass.pygrass.gis.region.Region.byref

```python
byref()
```

Return the internal region representation as pointer

####### grass.pygrass.gis.region.Region.c_region

```python
c_region = libgis.Cell_head()
```

####### grass.pygrass.gis.region.Region.cells

```python
cells
```

Return the number of cells

####### grass.pygrass.gis.region.Region.cols

```python
cols = property(fget=_get_cols, fset=_set_cols, doc='Set and obtain number of columns')
```

####### grass.pygrass.gis.region.Region.depths

```python
depths = property(fget=_get_depths, fset=_set_depths, doc='Set and obtain number of depths')
```

####### grass.pygrass.gis.region.Region.east

```python
east = property(fget=_get_e, fset=_set_e, doc='Set and obtain east coordinate')
```

####### grass.pygrass.gis.region.Region.ewres

```python
ewres = property(fget=_get_ewres, fset=_set_ewres, doc='Set and obtain east-west resolution value')
```

####### grass.pygrass.gis.region.Region.from_rast

```python
from_rast(raster_name)
```

Set the region from the computational region
of a raster map layer.

:param raster_name: the name of raster
:type raster_name: str

:param mapset: the mapset of raster
:type mapset: str

call C function `Rast_get_cellhd`

Example ::

> > > reg = Region()
> > > reg.from_rast(test_raster_name)
> > > reg.get_bbox()
> > > Bbox(50.0, 0.0, 60.0, 0.0)
> > > reg.read()
> > > reg.get_bbox()
> > > Bbox(40.0, 0.0, 40.0, 0.0)

..

####### grass.pygrass.gis.region.Region.from_vect

```python
from_vect(vector_name)
```

Adjust bounding box of region using a vector

:param vector_name: the name of vector
:type vector_name: str

Example ::

> > > reg = Region()
> > > reg.from_vect(test_vector_name)
> > > reg.get_bbox()
> > > Bbox(6.0, 0.0, 14.0, 0.0)
> > > reg.read()
> > > reg.get_bbox()
> > > Bbox(40.0, 0.0, 40.0, 0.0)

..

####### grass.pygrass.gis.region.Region.get_bbox

```python
get_bbox()
```

Return a Bbox object with the extension of the region. ::

```
>>> reg = Region()
>>> reg.get_bbox()
Bbox(40.0, 0.0, 40.0, 0.0)
```

..

####### grass.pygrass.gis.region.Region.get_current

```python
get_current()
```

Get the current working region of this process
and store it into this Region object

Previous calls to set_current() affects values returned by this function.
Previous calls to read() affects values returned by this function
only if the current working region is not initialized.

Example:

> > > r = Region()
> > > r.north
> > > 40.0

> > > r.north = 30
> > > r.north
> > > 30.0
> > > r.get_current()
> > > r.north
> > > 40.0

####### grass.pygrass.gis.region.Region.items

```python
items()
```

Return a list of tuple with key and value.

####### grass.pygrass.gis.region.Region.keys

```python
keys()
```

Return a list of valid keys. ::

```
>>> reg = Region()
>>> reg.keys()  # doctest: +ELLIPSIS
['proj', 'zone', ..., 'cols', 'cells']
```

..

####### grass.pygrass.gis.region.Region.north

```python
north = property(fget=_get_n, fset=_set_n, doc='Set and obtain north coordinate')
```

####### grass.pygrass.gis.region.Region.nsres

```python
nsres = property(fget=_get_nsres, fset=_set_nsres, doc='Set and obtain north-south resolution value')
```

####### grass.pygrass.gis.region.Region.proj

```python
proj
```

Return a code for projection

####### grass.pygrass.gis.region.Region.read

```python
read(force_read=True)
```

Read the region into this region object

Reads the region as stored in the WIND file in the user's current
mapset into region.

3D values are set to defaults if not available in WIND file. An
error message is printed and exit() is called if there is a problem
reading the region.

<b>Note:</b> GRASS applications that read or write raster maps
should not use this routine since its use implies that the active
module region will not be used. Programs that read or write raster
map data (or vector data) can query the active module region using
Rast_window_rows() and Rast_window_cols().

:param force_read: If True the WIND file of the current mapset
is re-readed, otherwise the initial region
set at process start will be loaded from the internal
static variables.
:type force_read: boolean

####### grass.pygrass.gis.region.Region.read_default

```python
read_default()
```

Get the default region

Reads the default region for the location in this Region object.
3D values are set to defaults if not available in WIND file.

An error message is printed and exit() is called if there is a
problem reading the default region.

####### grass.pygrass.gis.region.Region.rows

```python
rows = property(fget=_get_rows, fset=_set_rows, doc='Set and obtain number of rows')
```

####### grass.pygrass.gis.region.Region.set_bbox

```python
set_bbox(bbox)
```

Set region extent from Bbox

:param bbox: a Bbox object to set the extent
:type bbox: Bbox object

::

```
>>> from grass.pygrass.vector.basic import Bbox
>>> b = Bbox(230963.640878, 212125.562878, 645837.437393, 628769.374393)
>>> reg = Region()
>>> reg.set_bbox(b)
>>> reg.get_bbox()
Bbox(230963.640878, 212125.562878, 645837.437393, 628769.374393)
>>> reg.get_current()
```

..

####### grass.pygrass.gis.region.Region.set_current

```python
set_current()
```

Set the current working region from this region object

This function adjusts the values before setting the region
so you don't have to call G_adjust_Cell_head().

<details class="attention" open>
<summary>Only the current process is affected.</summary>
The GRASS computational region is not affected.
</details>

Example::

> > > r = Region()
> > > r.north
> > > 40.0
> > > r.south
> > > 0.0

> > > r.north = 30
> > > r.south = 20
> > > r.set_current()
> > > r.north
> > > 30.0
> > > r.south
> > > 20.0
> > > r.get_current()
> > > r.north
> > > 30.0
> > > r.south
> > > 20.0

> > > r.read(force_read=False)
> > > r.north
> > > 40.0
> > > r.south
> > > 0.0

> > > r.read(force_read=True)
> > > r.north
> > > 40.0
> > > r.south
> > > 0.0

####### grass.pygrass.gis.region.Region.set_raster_region

```python
set_raster_region()
```

Set the computational region (window) for all raster maps in the current
process.

<details class="attention" open>
<summary>All raster objects must be closed or the</summary>
process will be terminated.
</details>

The Raster library C function Rast_set_window() is called.

####### grass.pygrass.gis.region.Region.south

```python
south = property(fget=_get_s, fset=_set_s, doc='Set and obtain south coordinate')
```

####### grass.pygrass.gis.region.Region.tbres

```python
tbres = property(fget=_get_tbres, fset=_set_tbres, doc='Set and obtain top-bottom 3D value')
```

####### grass.pygrass.gis.region.Region.top

```python
top = property(fget=_get_t, fset=_set_t, doc='Set and obtain top value')
```

####### grass.pygrass.gis.region.Region.west

```python
west = property(fget=_get_w, fset=_set_w, doc='Set and obtain west coordinate')
```

####### grass.pygrass.gis.region.Region.write

```python
write()
```

Writes the region from this region object

This function writes this region to the Region file (WIND)
in the users current mapset. This function should be
carefully used, since the user will ot notice if his region
was changed and would expect that only g.region will do this.

Example ::

> > > from copy import deepcopy
> > > r = Region()
> > > rn = deepcopy(r)
> > > r.north = 20
> > > r.south = 10

> > > r.write()
> > > r.read()
> > > r.north
> > > 20.0
> > > r.south
> > > 10.0

> > > rn.write()
> > > r.read()
> > > r.north
> > > 40.0
> > > r.south
> > > 0.0

> > > r.read_default()
> > > r.write()

..

####### grass.pygrass.gis.region.Region.zone

```python
zone
```

Return the zone of projection

####### grass.pygrass.gis.region.Region.zoom

```python
zoom(raster_name)
```

Shrink region until it meets non-NULL data from this raster map

Warning: This will change the user GRASS region settings

:param raster_name: the name of raster
:type raster_name: str

###### grass.pygrass.gis.region.mset

```python
mset = utils.get_mapset_vector(test_vector_name, mapset='')
```

###### grass.pygrass.gis.region.test_raster_name

```python
test_raster_name = 'Region_test_raster'
```

###### grass.pygrass.gis.region.test_vector_name

```python
test_vector_name = 'Region_test_vector'
```

##### grass.pygrass.gis.set_current_mapset

```python
set_current_mapset(mapset, location=None, gisdbase=None)
```

Set the current mapset as working area

:param mapset: Name of the mapset
:type value: str

:param location: Name of the location
:type location: str

:param gisdbase: Name of the gisdbase
:type gisdbase: str

##### grass.pygrass.gis.test_raster_name

```python
test_raster_name = 'Gis_test_raster'
```

##### grass.pygrass.gis.test_vector_name

```python
test_vector_name = 'Gis_test_vector'
```

#### grass.pygrass.messages

@package grass.pygrass.messages

@brief PyGRASS message interface

Fast and exit-safe interface to GRASS C-library message functions

(C) 2013-2024 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

@author Soeren Gebbert, Edouard Choinière

**Classes:**

- [**Messenger**](#grass.pygrass.messages.Messenger) – Fast and exit-safe interface to GRASS C-library message functions

**Functions:**

- [**get_msgr**](#grass.pygrass.messages.get_msgr) – Return a Messenger instance.
- [**message_server**](#grass.pygrass.messages.message_server) – The GRASS message server function designed to be a target for

##### grass.pygrass.messages.Messenger

```python
Messenger(raise_on_error=False)
```

Fast and exit-safe interface to GRASS C-library message functions

This class implements a fast and exit-safe interface to the GRASS
C-library message functions like: G_message(), G_warning(),
G_important_message(), G_verbose_message(), G_percent() and G_debug().

Note:

The C-library message functions a called via ctypes in a subprocess
using a pipe (multiprocessing.Pipe) to transfer the text messages.
Hence, the process that uses the Messenger interface will not be
exited, if a G_fatal_error() was invoked in the subprocess.
In this case the Messenger object will simply start a new subprocess
and restarts the pipeline.

Usage:

> > > msgr = Messenger()
> > > msgr.debug(0, "debug 0")
> > > msgr.verbose("verbose message")
> > > msgr.message("message")
> > > msgr.important("important message")
> > > msgr.percent(1, 1, 1)
> > > msgr.warning("Ohh")
> > > msgr.error("Ohh no")

> > > msgr = Messenger()
> > > msgr.fatal("Ohh no no no!")
> > > Traceback (most recent call last):
> > > File "__init__.py", line 239, in fatal
> > > sys.exit(1)
> > > SystemExit: 1

> > > msgr = Messenger(raise_on_error=True)
> > > msgr.fatal("Ohh no no no!")
> > > Traceback (most recent call last):
> > > File "__init__.py", line 241, in fatal
> > > raise FatalError(message)
> > > grass.exceptions.FatalError: Ohh no no no!

> > > msgr = Messenger(raise_on_error=True)
> > > msgr.set_raise_on_error(False)
> > > msgr.fatal("Ohh no no no!")
> > > Traceback (most recent call last):
> > > File "__init__.py", line 239, in fatal
> > > sys.exit(1)
> > > SystemExit: 1

> > > msgr = Messenger(raise_on_error=False)
> > > msgr.set_raise_on_error(True)
> > > msgr.fatal("Ohh no no no!")
> > > Traceback (most recent call last):
> > > File "__init__.py", line 241, in fatal
> > > raise FatalError(message)
> > > grass.exceptions.FatalError: Ohh no no no!

**Functions:**

- [**debug**](#grass.pygrass.messages.Messenger.debug) – Send a debug message to stderr
- [**error**](#grass.pygrass.messages.Messenger.error) – Send an error message to stderr
- [**fatal**](#grass.pygrass.messages.Messenger.fatal) – Send an error message to stderr, call sys.exit(1) or raise FatalError
- [**get_raise_on_error**](#grass.pygrass.messages.Messenger.get_raise_on_error) – Get the fatal error behavior
- [**important**](#grass.pygrass.messages.Messenger.important) – Send an important message to stderr
- [**message**](#grass.pygrass.messages.Messenger.message) – Send a message to stderr
- [**percent**](#grass.pygrass.messages.Messenger.percent) – Send a percentage to stderr
- [**set_raise_on_error**](#grass.pygrass.messages.Messenger.set_raise_on_error) – Set the fatal error behavior
- [**start_server**](#grass.pygrass.messages.Messenger.start_server) – Start the messenger server and open the pipe
- [**stop**](#grass.pygrass.messages.Messenger.stop) – Stop the messenger server and close the pipe
- [**test_fatal_error**](#grass.pygrass.messages.Messenger.test_fatal_error) – Force the messenger server to call G_fatal_error()
- [**verbose**](#grass.pygrass.messages.Messenger.verbose) – Send a verbose message to stderr
- [**warning**](#grass.pygrass.messages.Messenger.warning) – Send a warning message to stderr

**Attributes:**

- [**client_conn**](#grass.pygrass.messages.Messenger.client_conn) (<code>[Connection](#multiprocessing.connection.Connection)</code>) –
- [**lock**](#grass.pygrass.messages.Messenger.lock) –
- [**raise_on_error**](#grass.pygrass.messages.Messenger.raise_on_error) –
- [**server**](#grass.pygrass.messages.Messenger.server) (<code>[Process](#multiprocessing.Process)</code>) –
- [**server_conn**](#grass.pygrass.messages.Messenger.server_conn) (<code>[Connection](#multiprocessing.connection.Connection)</code>) –

###### grass.pygrass.messages.Messenger.client_conn

```python
client_conn: Connection
```

###### grass.pygrass.messages.Messenger.debug

```python
debug(level, message)
```

Send a debug message to stderr

:param message: the text of message

G_debug() will be called in the messenger server process

###### grass.pygrass.messages.Messenger.error

```python
error(message)
```

Send an error message to stderr

:param message: the text of message

G_important_message() with an additional "ERROR:" string at
the start will be called in the messenger server process

###### grass.pygrass.messages.Messenger.fatal

```python
fatal(message)
```

Send an error message to stderr, call sys.exit(1) or raise FatalError

:param message: the text of message

This function emulates the behavior of G_fatal_error(). It prints
an error message to stderr and calls sys.exit(1). If raise_on_error
is set True while creating the messenger object, a FatalError
exception will be raised instead of calling sys.exit(1).

###### grass.pygrass.messages.Messenger.get_raise_on_error

```python
get_raise_on_error()
```

Get the fatal error behavior

:returns: True if a FatalError exception will be raised or False if
sys.exit(1) will be called in case of invoking fatal()

###### grass.pygrass.messages.Messenger.important

```python
important(message)
```

Send an important message to stderr

:param message: the text of message

G_important_message() will be called in the messenger server process

###### grass.pygrass.messages.Messenger.lock

```python
lock = Lock()
```

###### grass.pygrass.messages.Messenger.message

```python
message(message)
```

Send a message to stderr

:param message: the text of message

G_message() will be called in the messenger server process

###### grass.pygrass.messages.Messenger.percent

```python
percent(n, d, s)
```

Send a percentage to stderr

:param n: The current element
:param d: Total number of elements
:param s: Increment size

G_percent() will be called in the messenger server process

###### grass.pygrass.messages.Messenger.raise_on_error

```python
raise_on_error = raise_on_error
```

###### grass.pygrass.messages.Messenger.server

```python
server: Process = Process(target=message_server, args=(self.lock, self.server_conn))
```

###### grass.pygrass.messages.Messenger.server_conn

```python
server_conn: Connection
```

###### grass.pygrass.messages.Messenger.set_raise_on_error

```python
set_raise_on_error(raise_on_error=True)
```

Set the fatal error behavior

:param raise_on_error: if True a FatalError exception will be
raised instead of calling sys.exit(1)

- If raise_on_error == True, a FatalError exception will be raised
  if fatal() is called
- If raise_on_error == False, sys.exit(1) will be invoked if
  fatal() is called

###### grass.pygrass.messages.Messenger.start_server

```python
start_server()
```

Start the messenger server and open the pipe

###### grass.pygrass.messages.Messenger.stop

```python
stop()
```

Stop the messenger server and close the pipe

###### grass.pygrass.messages.Messenger.test_fatal_error

```python
test_fatal_error(message)
```

Force the messenger server to call G_fatal_error()

###### grass.pygrass.messages.Messenger.verbose

```python
verbose(message)
```

Send a verbose message to stderr

:param message: the text of message

G_verbose_message() will be called in the messenger server process

###### grass.pygrass.messages.Messenger.warning

```python
warning(message)
```

Send a warning message to stderr

:param message: the text of message

G_warning() will be called in the messenger server process

##### grass.pygrass.messages.get_msgr

```python
get_msgr(instance=[None], *args, **kwargs)
```

Return a Messenger instance.

:returns: the Messenger instance.

> > > msgr0 = get_msgr()
> > > msgr1 = get_msgr()
> > > msgr2 = Messenger()
> > > msgr0 is msgr1
> > > True
> > > msgr0 is msgr2
> > > False

##### grass.pygrass.messages.message_server

```python
message_server(lock, conn)
```

The GRASS message server function designed to be a target for
multiprocessing.Process

:param lock: A multiprocessing.Lock
:param conn: A multiprocessing.connection.Connection object obtained from
multiprocessing.Pipe

This function will use the G\_\* message C-functions from grass.lib.gis
to provide an interface to the GRASS C-library messaging system.

The data that is sent through the pipe must provide an
identifier string to specify which C-function should be called.

The following identifiers are supported:

- "INFO" Prints an info message, see G_message() for details
- "IMPORTANT" Prints an important info message,
  see G_important_message() for details
- "VERBOSE" Prints a verbose message if the verbosity level is
  set accordingly, see G_verbose_message() for details
- "WARNING" Prints a warning message, see G_warning() for details
- "ERROR" Prints a message with a leading "ERROR: " string,
  see G_important_message() for details
- "PERCENT" Prints a percent value based on three integer values: n, d and s
  see G_percent() for details
- "STOP" Stops the server function and closes the pipe
- "FATAL" Calls G_fatal_error(), this functions is only for
  testing purpose

The data that is sent through the pipe must be a list of values:

- Messages: ["INFO|IMPORTANT|VERBOSE|WARNING|ERROR|FATAL", "MESSAGE"]
- Debug: ["DEBUG", level, "MESSAGE"]
- Percent: ["PERCENT", n, d, s]

#### grass.pygrass.modules

**Modules:**

- [**grid**](#grass.pygrass.modules.grid) –
- [**interface**](#grass.pygrass.modules.interface) – Created on Tue Apr 2 18:40:39 2013
- [**shortcuts**](#grass.pygrass.modules.shortcuts) –

**Classes:**

- [**Module**](#grass.pygrass.modules.Module) – This class is design to wrap/run/interact with the GRASS modules.
- [**MultiModule**](#grass.pygrass.modules.MultiModule) – This class is designed to run a list of modules in serial in the provided order
- [**ParallelModuleQueue**](#grass.pygrass.modules.ParallelModuleQueue) – This class is designed to run an arbitrary number of pygrass Module or

##### grass.pygrass.modules.Module

```python
Module(cmd, *args, **kargs)
```

This class is design to wrap/run/interact with the GRASS modules.

The class during the init phase read the XML description generate using
the `--interface-description` in order to understand which parameters
are required which optionals. ::

> > > from grass.pygrass.modules import Module
> > > from subprocess import PIPE
> > > import copy

> > > region = Module("g.region")
> > > region.flags.p = True # set flags
> > > region.flags.u = True
> > > region.flags["3"].value = True # set numeric flags
> > > region.get_bash()
> > > 'g.region format=plain -p -3 -u'
> > > new_region = copy.deepcopy(region)
> > > new_region.inputs.res = "10"
> > > new_region.get_bash()
> > > 'g.region res=10 format=plain -p -3 -u'

> > > neighbors = Module("r.neighbors")
> > > neighbors.inputs.input = "mapA"
> > > neighbors.outputs.output = "mapB"
> > > neighbors.inputs.size = 5
> > > neighbors.inputs.quantile = 0.5
> > > neighbors.get_bash()
> > > 'r.neighbors input=mapA size=5 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > new_neighbors1 = copy.deepcopy(neighbors)
> > > new_neighbors1.inputs.input = "mapD"
> > > new_neighbors1.inputs.size = 3
> > > new_neighbors1.inputs.quantile = 0.5
> > > new_neighbors1.get_bash()
> > > 'r.neighbors input=mapD size=3 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > new_neighbors2 = copy.deepcopy(neighbors)
> > > new_neighbors2(input="mapD", size=3, run\_=False)
> > > Module('r.neighbors')
> > > new_neighbors2.get_bash()
> > > 'r.neighbors input=mapD size=3 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > neighbors = Module("r.neighbors")
> > > neighbors.get_bash()
> > > 'r.neighbors size=3 method=average weighting_function=none nprocs=1 memory=300'

> > > new_neighbors3 = copy.deepcopy(neighbors)
> > > new_neighbors3(input="mapA", size=3, output="mapB", run\_=False)
> > > Module('r.neighbors')
> > > new_neighbors3.get_bash()
> > > 'r.neighbors input=mapA size=3 method=average weighting_function=none nprocs=1 memory=300 output=mapB'

> > > mapcalc = Module(
> > > ... "r.mapcalc", expression="test_a = 1", overwrite=True, run\_=False
> > > ... )
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > mapcalc.returncode
> > > 0

> > > mapcalc = Module(
> > > ... "r.mapcalc",
> > > ... expression="test_a = 1",
> > > ... overwrite=True,
> > > ... run\_=False,
> > > ... finish\_=False,
> > > ... )
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0

> > > colors = Module(
> > > ... "r.colors",
> > > ... map="test_a",
> > > ... rules="-",
> > > ... run\_=False,
> > > ... stdout\_=PIPE,
> > > ... stderr\_=PIPE,
> > > ... stdin\_="1 red",
> > > ... )
> > > colors.run()
> > > Module('r.colors')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0
> > > colors.inputs["stdin"].value
> > > '1 red'
> > > colors.outputs["stdout"].value
> > > ''
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors = Module(
> > > ... "r.colors", map="test_a", rules="-", run\_=False, finish\_=False, stdin\_=PIPE
> > > ... )
> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.returncode
> > > 0

> > > colors = Module(
> > > ... "r.colors",
> > > ... map="test_a",
> > > ... rules="-",
> > > ... run\_=False,
> > > ... finish\_=False,
> > > ... stdin\_=PIPE,
> > > ... stderr\_=PIPE,
> > > ... )
> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors.returncode
> > > 0

Run a second time

> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors.returncode
> > > 0

Run many times and change parameters for each run

> > > colors = Module("r.colors", map="test_a", color="ryb", run\_=False)
> > > colors.get_bash()
> > > 'r.colors map=test_a color=ryb offset=0.0 scale=1.0'
> > > colors.run()
> > > Module('r.colors')
> > > colors.update(color="gyr")
> > > colors.run()
> > > Module('r.colors')
> > > colors.update(color="ryg")
> > > colors.update(stderr\_=PIPE)
> > > colors.run()
> > > Module('r.colors')
> > > print(colors.outputs["stderr"].value.strip())
> > > Color table for raster map \<test_a> set to 'ryg'
> > > colors.update(color="byg")
> > > colors.update(stdout\_=PIPE)
> > > colors.run()
> > > Module('r.colors')
> > > print(colors.outputs["stderr"].value.strip())
> > > Color table for raster map \<test_a> set to 'byg'
> > > colors.get_bash()
> > > 'r.colors map=test_a color=byg offset=0.0 scale=1.0'

Often in the Module class you can find `*args` and `kwargs` annotation
in methods, like in the __call__ method.
Python allow developers to not specify all the arguments and
keyword arguments of a method or function. ::

```
def f(*args):
    for arg in args:
        print arg
```

therefore if we call the function like:

> > > f("grass", "gis", "modules") # doctest: +SKIP
> > > grass
> > > gis
> > > modules

or we can define a new list:

> > > words = ["grass", "gis", "modules"] # doctest: +SKIP
> > > f(\*words) # doctest: +SKIP
> > > grass
> > > gis
> > > modules

we can do the same with keyword arguments, rewrite the above function: ::

```
def f(*args, **kargs):
    for arg in args:
        print arg
    for key, value in kargs.items():
        print "%s = %r" % (key, value)
```

now we can use the new function, with:

> > > f("grass", "gis", "modules", os="linux", language="python")
> > > ... # doctest: +SKIP
> > > grass
> > > gis
> > > modules
> > > os = 'linux'
> > > language = 'python'

or, as before we can, define a dictionary and give the dictionary to
the function, like:

> > > keywords = {"os": "linux", "language": "python"} # doctest: +SKIP
> > > f(\*words, \*\*keywords) # doctest: +SKIP
> > > grass
> > > gis
> > > modules
> > > os = 'linux'
> > > language = 'python'

In the Module class we heavily use this language feature to pass arguments
and keyword arguments to the grass module.

**Functions:**

- [**check**](#grass.pygrass.modules.Module.check) – Check the correctness of the provide parameters
- [**get_bash**](#grass.pygrass.modules.Module.get_bash) – Return a BASH representation of the Module.
- [**get_dict**](#grass.pygrass.modules.Module.get_dict) – Return a dictionary that includes the name, all valid
- [**get_python**](#grass.pygrass.modules.Module.get_python) – Return a Python representation of the Module.
- [**make_cmd**](#grass.pygrass.modules.Module.make_cmd) – Create the command string that can be executed in a shell
- [**run**](#grass.pygrass.modules.Module.run) – Run the module
- [**update**](#grass.pygrass.modules.Module.update) – Update module parameters and selected object attributes.
- [**wait**](#grass.pygrass.modules.Module.wait) – Wait for the module to finish. Call this method if

**Attributes:**

- [**check\_**](#grass.pygrass.modules.Module.check_) –
- [**env\_**](#grass.pygrass.modules.Module.env_) –
- [**finish\_**](#grass.pygrass.modules.Module.finish_) –
- [**flags**](#grass.pygrass.modules.Module.flags) –
- [**inputs**](#grass.pygrass.modules.Module.inputs) –
- [**name**](#grass.pygrass.modules.Module.name) –
- [**outputs**](#grass.pygrass.modules.Module.outputs) –
- [**params_list**](#grass.pygrass.modules.Module.params_list) –
- [**required**](#grass.pygrass.modules.Module.required) –
- [**returncode**](#grass.pygrass.modules.Module.returncode) –
- [**run\_**](#grass.pygrass.modules.Module.run_) –
- [**start_time**](#grass.pygrass.modules.Module.start_time) –
- [**stderr\_**](#grass.pygrass.modules.Module.stderr_) –
- [**stdin**](#grass.pygrass.modules.Module.stdin) –
- [**stdin\_**](#grass.pygrass.modules.Module.stdin_) –
- [**stdout\_**](#grass.pygrass.modules.Module.stdout_) –
- [**time**](#grass.pygrass.modules.Module.time) –
- [**xml**](#grass.pygrass.modules.Module.xml) –

###### grass.pygrass.modules.Module.check

```python
check()
```

Check the correctness of the provide parameters

###### grass.pygrass.modules.Module.check\_

```python
check_ = True
```

###### grass.pygrass.modules.Module.env\_

```python
env_ = None
```

###### grass.pygrass.modules.Module.finish\_

```python
finish_ = True
```

###### grass.pygrass.modules.Module.flags

```python
flags = TypeDict(Flag)
```

###### grass.pygrass.modules.Module.get_bash

```python
get_bash()
```

Return a BASH representation of the Module.

###### grass.pygrass.modules.Module.get_dict

```python
get_dict()
```

Return a dictionary that includes the name, all valid
inputs, outputs and flags

###### grass.pygrass.modules.Module.get_python

```python
get_python()
```

Return a Python representation of the Module.

###### grass.pygrass.modules.Module.inputs

```python
inputs = TypeDict(Parameter)
```

###### grass.pygrass.modules.Module.make_cmd

```python
make_cmd()
```

Create the command string that can be executed in a shell

:returns: the command string

###### grass.pygrass.modules.Module.name

```python
name = cmd
```

###### grass.pygrass.modules.Module.outputs

```python
outputs = TypeDict(Parameter)
```

###### grass.pygrass.modules.Module.params_list

```python
params_list = [Parameter(p) for p in tree.findall('parameter')]
```

###### grass.pygrass.modules.Module.required

```python
required = []
```

###### grass.pygrass.modules.Module.returncode

```python
returncode = None
```

###### grass.pygrass.modules.Module.run

```python
run()
```

Run the module
This function will wait for the process to terminate in case
finish\_==True and sets up stdout and stderr. If finish\_==False this
function will return after starting the process. Use wait() to wait for
the started process

:return: A reference to this object

###### grass.pygrass.modules.Module.run\_

```python
run_ = True
```

###### grass.pygrass.modules.Module.start_time

```python
start_time = None
```

###### grass.pygrass.modules.Module.stderr\_

```python
stderr_ = None
```

###### grass.pygrass.modules.Module.stdin

```python
stdin = None
```

###### grass.pygrass.modules.Module.stdin\_

```python
stdin_ = None
```

###### grass.pygrass.modules.Module.stdout\_

```python
stdout_ = None
```

###### grass.pygrass.modules.Module.time

```python
time = None
```

###### grass.pygrass.modules.Module.update

```python
update(*args, **kargs)
```

Update module parameters and selected object attributes.

Valid parameters are all the module parameters
and additional parameters, namely: run\_, stdin\_, stdout\_, stderr\_,
env\_, and finish\_.

###### grass.pygrass.modules.Module.wait

```python
wait()
```

Wait for the module to finish. Call this method if
the run() call was performed with self.false\_ = False.

:return: A reference to this object

###### grass.pygrass.modules.Module.xml

```python
xml = get_cmd_xml.communicate()[0]
```

##### grass.pygrass.modules.MultiModule

```python
MultiModule(module_list, sync=True, set_temp_region=False)
```

This class is designed to run a list of modules in serial in the provided order
within a temporary region environment.

Module can be run in serial synchronously or asynchronously.

- Synchronously: When calling run() all modules will run in serial order
  until they are finished, The run() method will return until all
  modules finished. The modules objects can be accessed by calling
  get_modules() to check their return values.

- Asynchronously: When calling run() all modules will run in serial order in a
  background process. Method run() will return after starting the
  modules without waiting for them to finish. The user must call
  the wait() method to wait for the modules to finish.
  Asynchronously called module can be optionally run in a temporary
  region environment, hence invoking g.region will not alter the
  current region or the region of other MultiModule runs.

  ```
              Note:

                  Modules run in asynchronous mode can only be accessed via the
                  wait() method. The wait() method will return all finished
                  module objects as list.
  ```

Objects of this class can be passed to the ParallelModuleQueue to run serial stacks
of modules in parallel. This is meaningful if region settings must be applied
to each parallel module run.

> > > from grass.pygrass.modules import Module
> > > from grass.pygrass.modules import MultiModule
> > > from multiprocessing import Process
> > > import copy

Synchronous module run

> > > region_1 = Module("g.region", run\_=False)
> > > region_1.flags.p = True
> > > region_2 = copy.deepcopy(region_1)
> > > region_2.flags.p = True
> > > mm = MultiModule(module_list=[region_1, region_2])
> > > mm.run()
> > > m_list = mm.get_modules()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0

Asynchronous module run, setting finish = False

> > > region_1 = Module("g.region", run\_=False)
> > > region_1.flags.p = True
> > > region_2 = copy.deepcopy(region_1)
> > > region_2.flags.p = True
> > > region_3 = copy.deepcopy(region_1)
> > > region_3.flags.p = True
> > > region_4 = copy.deepcopy(region_1)
> > > region_4.flags.p = True
> > > region_5 = copy.deepcopy(region_1)
> > > region_5.flags.p = True
> > > mm = MultiModule(
> > > ... module_list=[region_1, region_2, region_3, region_4, region_5], sync=False
> > > ... )
> > > t = mm.run()
> > > isinstance(t, Process)
> > > True
> > > m_list = mm.wait()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0
> > > m_list[2].returncode
> > > 0
> > > m_list[3].returncode
> > > 0
> > > m_list[4].returncode
> > > 0

Asynchronous module run, setting finish = False and using temporary region

> > > mm = MultiModule(
> > > ... module_list=[region_1, region_2, region_3, region_4, region_5],
> > > ... sync=False,
> > > ... set_temp_region=True,
> > > ... )
> > > str(mm)
> > > 'g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p'
> > > t = mm.run()
> > > isinstance(t, Process)
> > > True
> > > m_list = mm.wait()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0
> > > m_list[2].returncode
> > > 0
> > > m_list[3].returncode
> > > 0
> > > m_list[4].returncode
> > > 0

**Functions:**

- [**get_modules**](#grass.pygrass.modules.MultiModule.get_modules) – Return the list of modules that have been run in synchronous mode
- [**run**](#grass.pygrass.modules.MultiModule.run) – Start the modules in the list. If self.finished\_ is set True
- [**wait**](#grass.pygrass.modules.MultiModule.wait) – Wait for all processes to finish. Call this method

**Attributes:**

- [**finish\_**](#grass.pygrass.modules.MultiModule.finish_) –
- [**module_list**](#grass.pygrass.modules.MultiModule.module_list) –
- [**p**](#grass.pygrass.modules.MultiModule.p) –
- [**q**](#grass.pygrass.modules.MultiModule.q) –
- [**set_temp_region**](#grass.pygrass.modules.MultiModule.set_temp_region) –

Constructor of the multi module class

:param module_list: A list of pre-configured Module objects that should be run
:param sync: If set True the run() method will wait for all processes to finish
-> synchronously run.
If set False, the run() method will return after starting the
processes -> asynchronously run. The wait() method must be called
to finish the modules.
:param set_temp_region: Set a temporary region in which the modules should be
run, hence region settings in the process list will not
affect the current computation region.

```
                    Note:

                        This flag is only available in asynchronous mode!
```

:return:

###### grass.pygrass.modules.MultiModule.finish\_

```python
finish_ = sync
```

###### grass.pygrass.modules.MultiModule.get_modules

```python
get_modules()
```

Return the list of modules that have been run in synchronous mode

Note: Asynchronously run module can only be accessed via the wait() method.

:return: The list of modules

###### grass.pygrass.modules.MultiModule.module_list

```python
module_list = module_list
```

###### grass.pygrass.modules.MultiModule.p

```python
p = None
```

###### grass.pygrass.modules.MultiModule.q

```python
q = Queue()
```

###### grass.pygrass.modules.MultiModule.run

```python
run()
```

Start the modules in the list. If self.finished\_ is set True
this method will return after all processes finished.

If self.finish\_ is set False, this method will return
after the process list was started for execution.
In a background process, the processes in the list will
be run one after the another.

:return: None in case of self.finish\_ is True,
otherwise a multiprocessing.Process object that invokes the modules

###### grass.pygrass.modules.MultiModule.set_temp_region

```python
set_temp_region = set_temp_region
```

###### grass.pygrass.modules.MultiModule.wait

```python
wait()
```

Wait for all processes to finish. Call this method
in asynchronous mode, hence if finished was set False.

:return: The process list with finished processes to check their return states

##### grass.pygrass.modules.ParallelModuleQueue

```python
ParallelModuleQueue(nprocs=1)
```

This class is designed to run an arbitrary number of pygrass Module or
MultiModule processes in parallel.

Objects of type grass.pygrass.modules.Module or
grass.pygrass.modules.MultiModule can be put into the
queue using put() method. When the queue is full with the maximum
number of parallel processes it will wait for all processes to finish,
sets the stdout and stderr of the Module object and removes it
from the queue when its finished.

To finish the queue before the maximum number of parallel
processes was reached call wait() .

This class will raise a GrassError in case a Module process exits
with a return code other than 0.

Processes that were run asynchronously with the MultiModule class
will not raise a GrassError in case of failure. This must be manually checked
by accessing finished modules by calling get_finished_modules().

Usage:

Check with a queue size of 3 and 5 processes

> > > import copy
> > > from grass.pygrass.modules import Module, MultiModule, ParallelModuleQueue
> > > mapcalc_list = []

Setting run\_ to False is important, otherwise a parallel processing is not possible

> > > mapcalc = Module("r.mapcalc", overwrite=True, run\_=False)
> > > queue = ParallelModuleQueue(nprocs=3)
> > > for i in range(5):
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... mapcalc_list.append(new_mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... queue.put(m)
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 8 and 5 processes

> > > queue = ParallelModuleQueue(nprocs=8)
> > > mapcalc_list = []
> > > for i in range(5):
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... mapcalc_list.append(new_mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... queue.put(m)
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 8
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check MultiModule approach with three by two processes running in a background process

> > > gregion = Module("g.region", flags="p", run\_=False)
> > > queue = ParallelModuleQueue(nprocs=3)
> > > proc_list = []
> > > for i in range(3):
> > > ... new_gregion = copy.deepcopy(gregion)
> > > ... proc_list.append(new_gregion)
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... proc_list.append(new_mapcalc)
> > > ... mm = MultiModule(
> > > ... module_list=[new_gregion, new_mapcalc], sync=False, set_temp_region=True
> > > ... )
> > > ... queue.put(mm)
> > > queue.wait()
> > > proc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for proc in proc_list:
> > > ... print(proc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 8 and 4 processes

> > > queue = ParallelModuleQueue(nprocs=8)
> > > mapcalc_list = []
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_1 =1")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_2 =2")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 2
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_3 =3")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 3
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_4 =4")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 4
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 8
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 3 and 4 processes

> > > queue = ParallelModuleQueue(nprocs=3)
> > > mapcalc_list = []
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_1 =1")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_2 =2")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 2
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_3 =3")
> > > queue.put(
> > > ... m
> > > ... ) # Now it will wait until all procs finish and set the counter back to 0
> > > queue.get_num_run_procs()
> > > 0
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0

**Functions:**

- [**get**](#grass.pygrass.modules.ParallelModuleQueue.get) – Get a Module object or list of Module objects from the queue
- [**get_finished_modules**](#grass.pygrass.modules.ParallelModuleQueue.get_finished_modules) – Return all finished processes that were run by this queue
- [**get_max_num_procs**](#grass.pygrass.modules.ParallelModuleQueue.get_max_num_procs) – Return the maximum number of parallel Module processes
- [**get_num_run_procs**](#grass.pygrass.modules.ParallelModuleQueue.get_num_run_procs) – Get the number of Module processes that are in the queue running
- [**put**](#grass.pygrass.modules.ParallelModuleQueue.put) – Put the next Module or MultiModule object in the queue
- [**set_max_num_procs**](#grass.pygrass.modules.ParallelModuleQueue.set_max_num_procs) – Set the maximum number of Module processes that should run
- [**wait**](#grass.pygrass.modules.ParallelModuleQueue.wait) – Wait for all Module processes that are in the list to finish

Constructor

:param nprocs: The maximum number of Module processes that
can be run in parallel, default is 1, if None
then use all the available CPUs.
:type nprocs: int

###### grass.pygrass.modules.ParallelModuleQueue.get

```python
get(num)
```

Get a Module object or list of Module objects from the queue

:param num: the number of the object in queue
:type num: int
:returns: the Module object or list of Module objects or None if num is not in
the queue

###### grass.pygrass.modules.ParallelModuleQueue.get_finished_modules

```python
get_finished_modules()
```

Return all finished processes that were run by this queue

:return: A list of Module objects

###### grass.pygrass.modules.ParallelModuleQueue.get_max_num_procs

```python
get_max_num_procs()
```

Return the maximum number of parallel Module processes

:returns: the maximum number of parallel Module processes

###### grass.pygrass.modules.ParallelModuleQueue.get_num_run_procs

```python
get_num_run_procs()
```

Get the number of Module processes that are in the queue running
or finished

:returns: the number of Module processes running/finished in the queue

###### grass.pygrass.modules.ParallelModuleQueue.put

```python
put(module)
```

Put the next Module or MultiModule object in the queue

To run the Module objects in parallel the run\_ and finish\_ options
of the Module must be set to False.

:param module: a preconfigured Module or MultiModule object that were configured
with run\_ and finish\_ set to False,
:type module: Module or MultiModule object

###### grass.pygrass.modules.ParallelModuleQueue.set_max_num_procs

```python
set_max_num_procs(nprocs)
```

Set the maximum number of Module processes that should run
in parallel

:param nprocs: The maximum number of Module processes that can be
run in parallel
:type nprocs: int

###### grass.pygrass.modules.ParallelModuleQueue.wait

```python
wait()
```

Wait for all Module processes that are in the list to finish
and set the modules stdout and stderr output options

:return: A list of modules that were run

##### grass.pygrass.modules.grid

**Modules:**

- [**grid**](#grass.pygrass.modules.grid.grid) –
- [**patch**](#grass.pygrass.modules.grid.patch) – Created on Tue Apr 2 18:57:42 2013
- [**split**](#grass.pygrass.modules.grid.split) – Created on Tue Apr 2 19:00:15 2013

**Classes:**

- [**GridModule**](#grass.pygrass.modules.grid.GridModule) – Run GRASS raster commands in a multiprocessing mode.

###### grass.pygrass.modules.grid.GridModule

```python
GridModule(cmd, width=None, height=None, overlap=0, processes=None, split=False, debug=False, region=None, move=None, log=False, start_row=0, start_col=0, out_prefix='', mapset_prefix=None, patch_backend=None, *args, **kargs)
```

Run GRASS raster commands in a multiprocessing mode.

:param cmd: raster GRASS command, only command staring with r.\* are valid.
:type cmd: str
:param width: width of the tile, in pixel
:type width: int
:param height: height of the tile, in pixel.
:type height: int
:param overlap: overlap between tiles, in pixel.
:type overlap: int
:param processes: number of threads, default value is equal to the number
of processors available.
:param split: if True use r.tile to split all the inputs.
:type split: bool
:param mapset_prefix: if specified created mapsets start with this prefix
:type mapset_prefix: str
:param patch_backend: "r.patch", "RasterRow", or None for for default
:type patch_backend: None or str
:param run\_: if False only instantiate the object
:type run\_: bool
:param args: give all the parameters to the command
:param kargs: give all the parameters to the command

When patch_backend is None, the RasterRow method is used for patching the result.
When patch_backend is "r.patch", r.patch is used with nprocs=processes.
r.patch can only be used when overlap is 0.

> > > grd = GridModule(
> > > ... "r.slope.aspect",
> > > ... width=500,
> > > ... height=500,
> > > ... overlap=2,
> > > ... processes=None,
> > > ... split=False,
> > > ... elevation="elevation",
> > > ... slope="slope",
> > > ... aspect="aspect",
> > > ... overwrite=True,
> > > ... )
> > > grd.run()

Temporary mapsets created start with a generated prefix which is unique for each
process (includes PID and node name). If more instances of this class are used in
parallel from one process with the same module, a custom *mapset_prefix* needs to
be provided.

**Functions:**

- [**clean_location**](#grass.pygrass.modules.grid.GridModule.clean_location) – Remove all created mapsets.
- [**define_mapset_inputs**](#grass.pygrass.modules.grid.GridModule.define_mapset_inputs) – Add the mapset information to the input maps
- [**estimate_tile_size**](#grass.pygrass.modules.grid.GridModule.estimate_tile_size) – Estimates tile width and height based on number of processes.
- [**get_works**](#grass.pygrass.modules.grid.GridModule.get_works) – Return a list of tuples with the parameters for cmd_exe function
- [**patch**](#grass.pygrass.modules.grid.GridModule.patch) – Patch the final results.
- [**rm_tiles**](#grass.pygrass.modules.grid.GridModule.rm_tiles) – Remove all the tiles.
- [**run**](#grass.pygrass.modules.grid.GridModule.run) – Run the GRASS command
- [**split**](#grass.pygrass.modules.grid.GridModule.split) – Split all the raster inputs using r.tile

**Attributes:**

- [**bboxes**](#grass.pygrass.modules.grid.GridModule.bboxes) –
- [**debug**](#grass.pygrass.modules.grid.GridModule.debug) –
- [**gisrc_dst**](#grass.pygrass.modules.grid.GridModule.gisrc_dst) –
- [**gisrc_src**](#grass.pygrass.modules.grid.GridModule.gisrc_src) –
- [**height**](#grass.pygrass.modules.grid.GridModule.height) –
- [**inlist**](#grass.pygrass.modules.grid.GridModule.inlist) –
- [**log**](#grass.pygrass.modules.grid.GridModule.log) –
- [**mapset_prefix**](#grass.pygrass.modules.grid.GridModule.mapset_prefix) –
- [**module**](#grass.pygrass.modules.grid.GridModule.module) –
- [**move**](#grass.pygrass.modules.grid.GridModule.move) –
- [**mset**](#grass.pygrass.modules.grid.GridModule.mset) –
- [**msetstr**](#grass.pygrass.modules.grid.GridModule.msetstr) –
- [**n_mset**](#grass.pygrass.modules.grid.GridModule.n_mset) –
- [**out_prefix**](#grass.pygrass.modules.grid.GridModule.out_prefix) –
- [**overlap**](#grass.pygrass.modules.grid.GridModule.overlap) –
- [**patch_backend**](#grass.pygrass.modules.grid.GridModule.patch_backend) –
- [**processes**](#grass.pygrass.modules.grid.GridModule.processes) –
- [**region**](#grass.pygrass.modules.grid.GridModule.region) –
- [**start_col**](#grass.pygrass.modules.grid.GridModule.start_col) –
- [**start_row**](#grass.pygrass.modules.grid.GridModule.start_row) –
- [**width**](#grass.pygrass.modules.grid.GridModule.width) –

####### grass.pygrass.modules.grid.GridModule.bboxes

```python
bboxes = split_region_in_overlapping_tiles(region=region, width=self.width, height=self.height, overlap=overlap)
```

####### grass.pygrass.modules.grid.GridModule.clean_location

```python
clean_location(location=None)
```

Remove all created mapsets.

:param location: a Location instance where we are running the analysis
:type location: Location object

####### grass.pygrass.modules.grid.GridModule.debug

```python
debug = debug
```

####### grass.pygrass.modules.grid.GridModule.define_mapset_inputs

```python
define_mapset_inputs()
```

Add the mapset information to the input maps

####### grass.pygrass.modules.grid.GridModule.estimate_tile_size

```python
estimate_tile_size()
```

Estimates tile width and height based on number of processes.

Keeps width and height if provided by user. If one dimension
is provided the other is computed as the minimum number of tiles
to keep all requested processes working (initially).
If no dimensions are provided, tiling is 1 column x N rows
which speeds up patching.

####### grass.pygrass.modules.grid.GridModule.get_works

```python
get_works()
```

Return a list of tuples with the parameters for cmd_exe function

####### grass.pygrass.modules.grid.GridModule.gisrc_dst

```python
gisrc_dst = write_gisrc(self.n_mset.gisdbase, self.n_mset.location, self.n_mset.name)
```

####### grass.pygrass.modules.grid.GridModule.gisrc_src

```python
gisrc_src = os.environ['GISRC']
```

####### grass.pygrass.modules.grid.GridModule.height

```python
height = height
```

####### grass.pygrass.modules.grid.GridModule.inlist

```python
inlist = None
```

####### grass.pygrass.modules.grid.GridModule.log

```python
log = log
```

####### grass.pygrass.modules.grid.GridModule.mapset_prefix

```python
mapset_prefix = mapset_prefix
```

####### grass.pygrass.modules.grid.GridModule.module

```python
module = Module(cmd, *args, **kargs)
```

####### grass.pygrass.modules.grid.GridModule.move

```python
move = move
```

####### grass.pygrass.modules.grid.GridModule.mset

```python
mset = Mapset()
```

####### grass.pygrass.modules.grid.GridModule.msetstr

```python
msetstr = self.mapset_prefix + '_%03d_%03d'
```

####### grass.pygrass.modules.grid.GridModule.n_mset

```python
n_mset = copy_mapset(self.mset, self.move)
```

####### grass.pygrass.modules.grid.GridModule.out_prefix

```python
out_prefix = out_prefix
```

####### grass.pygrass.modules.grid.GridModule.overlap

```python
overlap = overlap
```

####### grass.pygrass.modules.grid.GridModule.patch

```python
patch()
```

Patch the final results.

####### grass.pygrass.modules.grid.GridModule.patch_backend

```python
patch_backend = 'RasterRow'
```

####### grass.pygrass.modules.grid.GridModule.processes

```python
processes = processes
```

####### grass.pygrass.modules.grid.GridModule.region

```python
region = region or Region()
```

####### grass.pygrass.modules.grid.GridModule.rm_tiles

```python
rm_tiles()
```

Remove all the tiles.

####### grass.pygrass.modules.grid.GridModule.run

```python
run(patch=True, clean=True)
```

Run the GRASS command

:param patch: set False if you does not want to patch the results
:type patch: bool
:param clean: set False if you does not want to remove all the stuff
created by GridModule
:type clean: bool

####### grass.pygrass.modules.grid.GridModule.split

```python
split()
```

Split all the raster inputs using r.tile

####### grass.pygrass.modules.grid.GridModule.start_col

```python
start_col = start_col
```

####### grass.pygrass.modules.grid.GridModule.start_row

```python
start_row = start_row
```

####### grass.pygrass.modules.grid.GridModule.width

```python
width = width
```

###### grass.pygrass.modules.grid.grid

**Classes:**

- [**GridModule**](#grass.pygrass.modules.grid.grid.GridModule) – Run GRASS raster commands in a multiprocessing mode.

**Functions:**

- [**cmd_exe**](#grass.pygrass.modules.grid.grid.cmd_exe) – Create a mapset, and execute a cmd inside.
- [**copy_groups**](#grass.pygrass.modules.grid.grid.copy_groups) – Copy group from one mapset to another, crop the raster to the region
- [**copy_mapset**](#grass.pygrass.modules.grid.grid.copy_mapset) – Copy mapset to another place without copying raster and vector data.
- [**copy_rasters**](#grass.pygrass.modules.grid.grid.copy_rasters) – Copy rasters from one mapset to another, crop the raster to the region.
- [**copy_special_mapset_files**](#grass.pygrass.modules.grid.grid.copy_special_mapset_files) – Copy all the special GRASS files that are contained in
- [**copy_vectors**](#grass.pygrass.modules.grid.grid.copy_vectors) – Copy vectors from one mapset to another, crop the raster to the region.
- [**get_cmd**](#grass.pygrass.modules.grid.grid.get_cmd) – Transform a cmd dictionary to a list of parameters. It is useful to
- [**get_mapset**](#grass.pygrass.modules.grid.grid.get_mapset) – Get mapset from a GISRC source to a GISRC destination.
- [**read_gisrc**](#grass.pygrass.modules.grid.grid.read_gisrc) – Read a GISRC file and return a tuple with the mapset, location
- [**select**](#grass.pygrass.modules.grid.grid.select) – Select only a certain type of parameters.
- [**set_region**](#grass.pygrass.modules.grid.grid.set_region) – Set a region into two different mapsets.

####### grass.pygrass.modules.grid.grid.GridModule

```python
GridModule(cmd, width=None, height=None, overlap=0, processes=None, split=False, debug=False, region=None, move=None, log=False, start_row=0, start_col=0, out_prefix='', mapset_prefix=None, patch_backend=None, *args, **kargs)
```

Run GRASS raster commands in a multiprocessing mode.

:param cmd: raster GRASS command, only command staring with r.\* are valid.
:type cmd: str
:param width: width of the tile, in pixel
:type width: int
:param height: height of the tile, in pixel.
:type height: int
:param overlap: overlap between tiles, in pixel.
:type overlap: int
:param processes: number of threads, default value is equal to the number
of processors available.
:param split: if True use r.tile to split all the inputs.
:type split: bool
:param mapset_prefix: if specified created mapsets start with this prefix
:type mapset_prefix: str
:param patch_backend: "r.patch", "RasterRow", or None for for default
:type patch_backend: None or str
:param run\_: if False only instantiate the object
:type run\_: bool
:param args: give all the parameters to the command
:param kargs: give all the parameters to the command

When patch_backend is None, the RasterRow method is used for patching the result.
When patch_backend is "r.patch", r.patch is used with nprocs=processes.
r.patch can only be used when overlap is 0.

> > > grd = GridModule(
> > > ... "r.slope.aspect",
> > > ... width=500,
> > > ... height=500,
> > > ... overlap=2,
> > > ... processes=None,
> > > ... split=False,
> > > ... elevation="elevation",
> > > ... slope="slope",
> > > ... aspect="aspect",
> > > ... overwrite=True,
> > > ... )
> > > grd.run()

Temporary mapsets created start with a generated prefix which is unique for each
process (includes PID and node name). If more instances of this class are used in
parallel from one process with the same module, a custom *mapset_prefix* needs to
be provided.

**Functions:**

- [**clean_location**](#grass.pygrass.modules.grid.grid.GridModule.clean_location) – Remove all created mapsets.
- [**define_mapset_inputs**](#grass.pygrass.modules.grid.grid.GridModule.define_mapset_inputs) – Add the mapset information to the input maps
- [**estimate_tile_size**](#grass.pygrass.modules.grid.grid.GridModule.estimate_tile_size) – Estimates tile width and height based on number of processes.
- [**get_works**](#grass.pygrass.modules.grid.grid.GridModule.get_works) – Return a list of tuples with the parameters for cmd_exe function
- [**patch**](#grass.pygrass.modules.grid.grid.GridModule.patch) – Patch the final results.
- [**rm_tiles**](#grass.pygrass.modules.grid.grid.GridModule.rm_tiles) – Remove all the tiles.
- [**run**](#grass.pygrass.modules.grid.grid.GridModule.run) – Run the GRASS command
- [**split**](#grass.pygrass.modules.grid.grid.GridModule.split) – Split all the raster inputs using r.tile

**Attributes:**

- [**bboxes**](#grass.pygrass.modules.grid.grid.GridModule.bboxes) –
- [**debug**](#grass.pygrass.modules.grid.grid.GridModule.debug) –
- [**gisrc_dst**](#grass.pygrass.modules.grid.grid.GridModule.gisrc_dst) –
- [**gisrc_src**](#grass.pygrass.modules.grid.grid.GridModule.gisrc_src) –
- [**height**](#grass.pygrass.modules.grid.grid.GridModule.height) –
- [**inlist**](#grass.pygrass.modules.grid.grid.GridModule.inlist) –
- [**log**](#grass.pygrass.modules.grid.grid.GridModule.log) –
- [**mapset_prefix**](#grass.pygrass.modules.grid.grid.GridModule.mapset_prefix) –
- [**module**](#grass.pygrass.modules.grid.grid.GridModule.module) –
- [**move**](#grass.pygrass.modules.grid.grid.GridModule.move) –
- [**mset**](#grass.pygrass.modules.grid.grid.GridModule.mset) –
- [**msetstr**](#grass.pygrass.modules.grid.grid.GridModule.msetstr) –
- [**n_mset**](#grass.pygrass.modules.grid.grid.GridModule.n_mset) –
- [**out_prefix**](#grass.pygrass.modules.grid.grid.GridModule.out_prefix) –
- [**overlap**](#grass.pygrass.modules.grid.grid.GridModule.overlap) –
- [**patch_backend**](#grass.pygrass.modules.grid.grid.GridModule.patch_backend) –
- [**processes**](#grass.pygrass.modules.grid.grid.GridModule.processes) –
- [**region**](#grass.pygrass.modules.grid.grid.GridModule.region) –
- [**start_col**](#grass.pygrass.modules.grid.grid.GridModule.start_col) –
- [**start_row**](#grass.pygrass.modules.grid.grid.GridModule.start_row) –
- [**width**](#grass.pygrass.modules.grid.grid.GridModule.width) –

######## grass.pygrass.modules.grid.grid.GridModule.bboxes

```python
bboxes = split_region_in_overlapping_tiles(region=region, width=self.width, height=self.height, overlap=overlap)
```

######## grass.pygrass.modules.grid.grid.GridModule.clean_location

```python
clean_location(location=None)
```

Remove all created mapsets.

:param location: a Location instance where we are running the analysis
:type location: Location object

######## grass.pygrass.modules.grid.grid.GridModule.debug

```python
debug = debug
```

######## grass.pygrass.modules.grid.grid.GridModule.define_mapset_inputs

```python
define_mapset_inputs()
```

Add the mapset information to the input maps

######## grass.pygrass.modules.grid.grid.GridModule.estimate_tile_size

```python
estimate_tile_size()
```

Estimates tile width and height based on number of processes.

Keeps width and height if provided by user. If one dimension
is provided the other is computed as the minimum number of tiles
to keep all requested processes working (initially).
If no dimensions are provided, tiling is 1 column x N rows
which speeds up patching.

######## grass.pygrass.modules.grid.grid.GridModule.get_works

```python
get_works()
```

Return a list of tuples with the parameters for cmd_exe function

######## grass.pygrass.modules.grid.grid.GridModule.gisrc_dst

```python
gisrc_dst = write_gisrc(self.n_mset.gisdbase, self.n_mset.location, self.n_mset.name)
```

######## grass.pygrass.modules.grid.grid.GridModule.gisrc_src

```python
gisrc_src = os.environ['GISRC']
```

######## grass.pygrass.modules.grid.grid.GridModule.height

```python
height = height
```

######## grass.pygrass.modules.grid.grid.GridModule.inlist

```python
inlist = None
```

######## grass.pygrass.modules.grid.grid.GridModule.log

```python
log = log
```

######## grass.pygrass.modules.grid.grid.GridModule.mapset_prefix

```python
mapset_prefix = mapset_prefix
```

######## grass.pygrass.modules.grid.grid.GridModule.module

```python
module = Module(cmd, *args, **kargs)
```

######## grass.pygrass.modules.grid.grid.GridModule.move

```python
move = move
```

######## grass.pygrass.modules.grid.grid.GridModule.mset

```python
mset = Mapset()
```

######## grass.pygrass.modules.grid.grid.GridModule.msetstr

```python
msetstr = self.mapset_prefix + '_%03d_%03d'
```

######## grass.pygrass.modules.grid.grid.GridModule.n_mset

```python
n_mset = copy_mapset(self.mset, self.move)
```

######## grass.pygrass.modules.grid.grid.GridModule.out_prefix

```python
out_prefix = out_prefix
```

######## grass.pygrass.modules.grid.grid.GridModule.overlap

```python
overlap = overlap
```

######## grass.pygrass.modules.grid.grid.GridModule.patch

```python
patch()
```

Patch the final results.

######## grass.pygrass.modules.grid.grid.GridModule.patch_backend

```python
patch_backend = 'RasterRow'
```

######## grass.pygrass.modules.grid.grid.GridModule.processes

```python
processes = processes
```

######## grass.pygrass.modules.grid.grid.GridModule.region

```python
region = region or Region()
```

######## grass.pygrass.modules.grid.grid.GridModule.rm_tiles

```python
rm_tiles()
```

Remove all the tiles.

######## grass.pygrass.modules.grid.grid.GridModule.run

```python
run(patch=True, clean=True)
```

Run the GRASS command

:param patch: set False if you does not want to patch the results
:type patch: bool
:param clean: set False if you does not want to remove all the stuff
created by GridModule
:type clean: bool

######## grass.pygrass.modules.grid.grid.GridModule.split

```python
split()
```

Split all the raster inputs using r.tile

######## grass.pygrass.modules.grid.grid.GridModule.start_col

```python
start_col = start_col
```

######## grass.pygrass.modules.grid.grid.GridModule.start_row

```python
start_row = start_row
```

######## grass.pygrass.modules.grid.grid.GridModule.width

```python
width = width
```

####### grass.pygrass.modules.grid.grid.cmd_exe

```python
cmd_exe(args)
```

Create a mapset, and execute a cmd inside.

:param args: is a tuple that contains several information see below
:type args: tuple
:returns: None

The puple has to contain:

- bbox (dict): a dict with the region parameters (n, s, e, w, etc.)
  that we want to set before to apply the command.
- mapnames (dict): a dictionary to substitute the input if the domain has
  been split in several tiles.
- gisrc_src (str): path of the GISRC file from where we want to copy the
  groups.
- gisrc_dst (str): path of the GISRC file where the groups will be created.
- cmd (dict): a dictionary with all the parameter of a GRASS module.
- groups (list): a list of strings with the groups that we want to copy in
  the mapset.

####### grass.pygrass.modules.grid.grid.copy_groups

```python
copy_groups(groups, gisrc_src, gisrc_dst, region=None)
```

Copy group from one mapset to another, crop the raster to the region

:param groups: a list of strings with the group that must be copied
from a master to another.
:type groups: list of strings
:param gisrc_src: path of the GISRC file from where we want to copy the groups
:type gisrc_src: str
:param gisrc_dst: path of the GISRC file where the groups will be created
:type gisrc_dst: str
:param region: a region like object or a dictionary with the region
parameters that will be used to crop the rasters of the groups
:type region: Region object or dictionary
:returns: None

####### grass.pygrass.modules.grid.grid.copy_mapset

```python
copy_mapset(mapset, path)
```

Copy mapset to another place without copying raster and vector data.

:param mapset: a Mapset instance to copy
:type mapset: Mapset object
:param path: path where the new mapset must be copied
:type path: str
:returns: the instance of the new Mapset.

> > > from grass.script.core import gisenv
> > > mname = gisenv()["MAPSET"]
> > > mset = Mapset()
> > > mset.name == mname
> > > True
> > > import tempfile as tmp
> > > import os
> > > path = os.path.join(tmp.gettempdir(), "my_loc", "my_mset")
> > > copy_mapset(mset, path) # doctest: +ELLIPSIS
> > > Mapset(...)
> > > sorted(os.listdir(path)) # doctest: +ELLIPSIS
> > > [...'PERMANENT'...]
> > > sorted(os.listdir(os.path.join(path, "PERMANENT")))
> > > ['DEFAULT_WIND', 'PROJ_INFO', 'PROJ_UNITS', 'VAR', 'WIND']
> > > sorted(os.listdir(os.path.join(path, mname))) # doctest: +ELLIPSIS
> > > [...'WIND'...]
> > > import shutil
> > > shutil.rmtree(path)

####### grass.pygrass.modules.grid.grid.copy_rasters

```python
copy_rasters(rasters, gisrc_src, gisrc_dst, region=None)
```

Copy rasters from one mapset to another, crop the raster to the region.

:param rasters: a list of strings with the raster map that must be copied
from a master to another.
:type rasters: list
:param gisrc_src: path of the GISRC file from where we want to copy the groups
:type gisrc_src: str
:param gisrc_dst: path of the GISRC file where the groups will be created
:type gisrc_dst: str
:param region: a region like object or a dictionary with the region
parameters that will be used to crop the rasters of the groups
:type region: Region object or dictionary
:returns: None

####### grass.pygrass.modules.grid.grid.copy_special_mapset_files

```python
copy_special_mapset_files(path_src, path_dst)
```

Copy all the special GRASS files that are contained in
a mapset to another mapset

:param path_src: the path to the original mapset
:type path_src: str
:param path_dst: the path to the new mapset
:type path_dst: str

####### grass.pygrass.modules.grid.grid.copy_vectors

```python
copy_vectors(vectors, gisrc_src, gisrc_dst)
```

Copy vectors from one mapset to another, crop the raster to the region.

:param vectors: a list of strings with the vector map that must be copied
from a master to another.
:type vectors: list
:param gisrc_src: path of the GISRC file from where we want to copy the groups
:type gisrc_src: str
:param gisrc_dst: path of the GISRC file where the groups will be created
:type gisrc_dst: str
:returns: None

####### grass.pygrass.modules.grid.grid.get_cmd

```python
get_cmd(cmdd)
```

Transform a cmd dictionary to a list of parameters. It is useful to
pickle a Module class and cnvert into a string that can be used with
`Popen(get_cmd(cmdd), shell=True)`.

:param cmdd: a module dictionary with all the parameters
:type cmdd: dict

> > > slp = Module(
> > > ... "r.slope.aspect",
> > > ... elevation="ele",
> > > ... slope="slp",
> > > ... aspect="asp",
> > > ... overwrite=True,
> > > ... run\_=False,
> > > ... )
> > > get_cmd(slp.get_dict()) # doctest: +ELLIPSIS
> > > ['r.slope.aspect', 'elevation=ele', 'format=degrees', ..., '--o']

####### grass.pygrass.modules.grid.grid.get_mapset

```python
get_mapset(gisrc_src, gisrc_dst)
```

Get mapset from a GISRC source to a GISRC destination.

:param gisrc_src: path to the GISRC source
:type gisrc_src: str
:param gisrc_dst: path to the GISRC destination
:type gisrc_dst: str
:returns: a tuple with Mapset(src), Mapset(dst)

####### grass.pygrass.modules.grid.grid.read_gisrc

```python
read_gisrc(gisrc)
```

Read a GISRC file and return a tuple with the mapset, location
and gisdbase.

:param gisrc: the path to GISRC file
:type gisrc: str
:returns: a tuple with the mapset, location and gisdbase

> > > import os
> > > from grass.script.core import gisenv
> > > genv = gisenv()
> > > (
> > > ... read_gisrc(os.environ["GISRC"])
> > > ... == (genv["MAPSET"], genv["LOCATION_NAME"], genv["GISDBASE"])
> > > ... )
> > > True

####### grass.pygrass.modules.grid.grid.select

```python
select(parms, ptype)
```

Select only a certain type of parameters.

:param parms: a DictType parameter with inputs or outputs of a Module class
:type parms: DictType parameters
:param ptype: String define the type of parameter that we want to select,
valid ptype are: 'raster', 'vector', 'group'
:type ptype: str
:returns: An iterator with the value of the parameter.

> > > slp = Module(
> > > ... "r.slope.aspect", elevation="ele", slope="slp", aspect="asp", run\_=False
> > > ... )
> > > for rast in select(slp.outputs, "raster"):
> > > ... print(rast)
> > > slp
> > > asp

####### grass.pygrass.modules.grid.grid.set_region

```python
set_region(region, gisrc_src, gisrc_dst, env)
```

Set a region into two different mapsets.

:param region: a region like object or a dictionary with the region
parameters that will be used to crop the rasters of the groups
:type region: Region object or dictionary
:param gisrc_src: path of the GISRC file from where we want to copy the groups
:type gisrc_src: str
:param gisrc_dst: path of the GISRC file where the groups will be created
:type gisrc_dst: str
:param env:
:type env:
:returns: None

###### grass.pygrass.modules.grid.patch

Created on Tue Apr 2 18:57:42 2013

@author: pietro

**Functions:**

- [**get_start_end_index**](#grass.pygrass.modules.grid.patch.get_start_end_index) – Convert a Bounding Box to a list of the index of
- [**rpatch_map**](#grass.pygrass.modules.grid.patch.rpatch_map) – Patch raster using a bounding box list to trim the raster.
- [**rpatch_map_r_patch_backend**](#grass.pygrass.modules.grid.patch.rpatch_map_r_patch_backend) – Patch raster using a r.patch. Only use with overlap=0.
- [**rpatch_row**](#grass.pygrass.modules.grid.patch.rpatch_row) – Patch a row of bound boxes.

####### grass.pygrass.modules.grid.patch.get_start_end_index

```python
get_start_end_index(bbox_list)
```

Convert a Bounding Box to a list of the index of
column start, end, row start and end
:param bbox_list: a list of BBox object to convert
:type bbox_list: list of BBox object

.. deprecated:: 8.3

####### grass.pygrass.modules.grid.patch.rpatch_map

```python
rpatch_map(raster, mapset, mset_str, bbox_list, overwrite=False, start_row=0, start_col=0, prefix='')
```

Patch raster using a bounding box list to trim the raster.

:param raster: the name of output raster
:type raster: str
:param mapset: the name of mapset to use
:type mapset: str
:param mset_str:
:type mset_str: str
:param bbox_list: a list of BBox object to convert
:type bbox_list: list of BBox object
:param overwrite: overwrite existing raster
:type overwrite: bool
:param start_row: the starting row of original raster
:type start_row: int
:param start_col: the starting column of original raster
:type start_col: int
:param prefix: the prefix of output raster
:type prefix: str

####### grass.pygrass.modules.grid.patch.rpatch_map_r_patch_backend

```python
rpatch_map_r_patch_backend(raster, mset_str, bbox_list, overwrite=False, start_row=0, start_col=0, prefix='', processes=1)
```

Patch raster using a r.patch. Only use with overlap=0.
Will be faster than rpatch_map, since r.patch is parallelized.

:param raster: the name of output raster
:type raster: str
:param mset_str:
:type mset_str: str
:param bbox_list: a list of BBox object to convert
:type bbox_list: list of BBox object
:param overwrite: overwrite existing raster
:type overwrite: bool
:param start_row: the starting row of original raster
:type start_row: int
:param start_col: the starting column of original raster
:type start_col: int
:param prefix: the prefix of output raster
:type prefix: str
:param processes: number of parallel process for r.patch
:type processes: int

####### grass.pygrass.modules.grid.patch.rpatch_row

```python
rpatch_row(rast, rasts, bboxes)
```

Patch a row of bound boxes.

:param rast: a Raster object to write
:type rast: Raster object
:param rasts: a list of Raster object to read
:type rasts: list of Raster object
:param bboxes: a list of BBox object
:type bboxes: list of BBox object

###### grass.pygrass.modules.grid.split

Created on Tue Apr 2 19:00:15 2013

@author: pietro

**Functions:**

- [**get_bbox**](#grass.pygrass.modules.grid.split.get_bbox) – Return a Bbox
- [**get_overlap_region_tiles**](#grass.pygrass.modules.grid.split.get_overlap_region_tiles) – Get the Bbox of the overlapped region.
- [**get_tile_start_end_row_col**](#grass.pygrass.modules.grid.split.get_tile_start_end_row_col) – Return a tile's starting and ending row and col
- [**split_region_in_overlapping_tiles**](#grass.pygrass.modules.grid.split.split_region_in_overlapping_tiles) – Split a region into a list of overlapping tiles defined as (N, S, E, W).
- [**split_region_tiles**](#grass.pygrass.modules.grid.split.split_region_tiles) – Split a region into a list of tiles defined as (start_row, end_row, start_col,

####### grass.pygrass.modules.grid.split.get_bbox

```python
get_bbox(reg, row, col, width, height, overlap)
```

Return a Bbox

:param reg: a Region object to split
:type reg: Region object
:param row: the number of row
:type row: int
:param col: the number of row
:type col: int
:param width: the width of tiles
:type width: int
:param height: the width of tiles
:type height: int
:param overlap: the value of overlap between tiles
:type overlap: int

####### grass.pygrass.modules.grid.split.get_overlap_region_tiles

```python
get_overlap_region_tiles(region=None, width=100, height=100, overlap=0)
```

Get the Bbox of the overlapped region.

:param region: a Region object to split
:type region: Region object
:param width: the width of tiles
:type width: int
:param height: the width of tiles
:type height: int
:param overlap: the value of overlap between tiles
:type overlap: int

####### grass.pygrass.modules.grid.split.get_tile_start_end_row_col

```python
get_tile_start_end_row_col(reg, row, col, width, height)
```

Return a tile's starting and ending row and col

:param reg: a Region object to split
:type reg: Region object
:param row: the number of tiles in a row
:type row: int
:param col: the number of tiles in a col
:type col: int
:param width: the width of tiles
:type width: int
:param height: the width of tiles
:type height: int

####### grass.pygrass.modules.grid.split.split_region_in_overlapping_tiles

```python
split_region_in_overlapping_tiles(region=None, width=100, height=100, overlap=0)
```

Split a region into a list of overlapping tiles defined as (N, S, E, W).

:param region: a Region object to split
:type region: Region object
:param width: the width of tiles
:type width: int
:param height: the width of tiles
:type height: int
:param overlap: the value of overlap between tiles
:type overlap: int

> > > reg = Region()
> > > reg.north = 1350
> > > reg.south = 0
> > > reg.nsres = 1
> > > reg.east = 1500
> > > reg.west = 0
> > > reg.ewres = 1
> > > reg.cols
> > > 1500
> > > reg.rows
> > > 1350
> > > split_region_in_overlapping_tiles(
> > > ... region=reg, width=1000, height=700, overlap=0
> > > ... ) # doctest: +NORMALIZE_WHITESPACE
> > > \[[Bbox(1350.0, 650.0, 1000.0, 0.0), Bbox(1350.0, 650.0, 1500.0, 1000.0)],
> > > [Bbox(650.0, 0.0, 1000.0, 0.0), Bbox(650.0, 0.0, 1500.0, 1000.0)]\]
> > > split_region_in_overlapping_tiles(
> > > ... region=reg, width=1000, height=700, overlap=10
> > > ... ) # doctest: +NORMALIZE_WHITESPACE
> > > \[[Bbox(1350.0, 640.0, 1010.0, 0.0), Bbox(1350.0, 640.0, 1500.0, 990.0)],
> > > [Bbox(660.0, 0.0, 1010.0, 0.0), Bbox(660.0, 0.0, 1500.0, 990.0)]\]

####### grass.pygrass.modules.grid.split.split_region_tiles

```python
split_region_tiles(region=None, width=100, height=100)
```

Split a region into a list of tiles defined as (start_row, end_row, start_col,
end_col).

:param region: a Region object to split
:type region: Region object
:param width: the width of tiles
:type width: int
:param height: the width of tiles
:type height: int

##### grass.pygrass.modules.interface

Created on Tue Apr 2 18:40:39 2013

@author: pietro

**Modules:**

- [**docstring**](#grass.pygrass.modules.interface.docstring) –
- [**env**](#grass.pygrass.modules.interface.env) – Created on Thu May 28 17:41:32 2015
- [**flag**](#grass.pygrass.modules.interface.flag) –
- [**module**](#grass.pygrass.modules.interface.module) –
- [**parameter**](#grass.pygrass.modules.interface.parameter) – Created on Tue Apr 2 18:31:47 2013
- [**read**](#grass.pygrass.modules.interface.read) – Created on Tue Apr 2 18:30:34 2013
- [**typedict**](#grass.pygrass.modules.interface.typedict) – Created on Tue Apr 2 18:37:02 2013

**Classes:**

- [**Module**](#grass.pygrass.modules.interface.Module) – This class is design to wrap/run/interact with the GRASS modules.
- [**MultiModule**](#grass.pygrass.modules.interface.MultiModule) – This class is designed to run a list of modules in serial in the provided order
- [**ParallelModuleQueue**](#grass.pygrass.modules.interface.ParallelModuleQueue) – This class is designed to run an arbitrary number of pygrass Module or

###### grass.pygrass.modules.interface.Module

```python
Module(cmd, *args, **kargs)
```

This class is design to wrap/run/interact with the GRASS modules.

The class during the init phase read the XML description generate using
the `--interface-description` in order to understand which parameters
are required which optionals. ::

> > > from grass.pygrass.modules import Module
> > > from subprocess import PIPE
> > > import copy

> > > region = Module("g.region")
> > > region.flags.p = True # set flags
> > > region.flags.u = True
> > > region.flags["3"].value = True # set numeric flags
> > > region.get_bash()
> > > 'g.region format=plain -p -3 -u'
> > > new_region = copy.deepcopy(region)
> > > new_region.inputs.res = "10"
> > > new_region.get_bash()
> > > 'g.region res=10 format=plain -p -3 -u'

> > > neighbors = Module("r.neighbors")
> > > neighbors.inputs.input = "mapA"
> > > neighbors.outputs.output = "mapB"
> > > neighbors.inputs.size = 5
> > > neighbors.inputs.quantile = 0.5
> > > neighbors.get_bash()
> > > 'r.neighbors input=mapA size=5 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > new_neighbors1 = copy.deepcopy(neighbors)
> > > new_neighbors1.inputs.input = "mapD"
> > > new_neighbors1.inputs.size = 3
> > > new_neighbors1.inputs.quantile = 0.5
> > > new_neighbors1.get_bash()
> > > 'r.neighbors input=mapD size=3 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > new_neighbors2 = copy.deepcopy(neighbors)
> > > new_neighbors2(input="mapD", size=3, run\_=False)
> > > Module('r.neighbors')
> > > new_neighbors2.get_bash()
> > > 'r.neighbors input=mapD size=3 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > neighbors = Module("r.neighbors")
> > > neighbors.get_bash()
> > > 'r.neighbors size=3 method=average weighting_function=none nprocs=1 memory=300'

> > > new_neighbors3 = copy.deepcopy(neighbors)
> > > new_neighbors3(input="mapA", size=3, output="mapB", run\_=False)
> > > Module('r.neighbors')
> > > new_neighbors3.get_bash()
> > > 'r.neighbors input=mapA size=3 method=average weighting_function=none nprocs=1 memory=300 output=mapB'

> > > mapcalc = Module(
> > > ... "r.mapcalc", expression="test_a = 1", overwrite=True, run\_=False
> > > ... )
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > mapcalc.returncode
> > > 0

> > > mapcalc = Module(
> > > ... "r.mapcalc",
> > > ... expression="test_a = 1",
> > > ... overwrite=True,
> > > ... run\_=False,
> > > ... finish\_=False,
> > > ... )
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0

> > > colors = Module(
> > > ... "r.colors",
> > > ... map="test_a",
> > > ... rules="-",
> > > ... run\_=False,
> > > ... stdout\_=PIPE,
> > > ... stderr\_=PIPE,
> > > ... stdin\_="1 red",
> > > ... )
> > > colors.run()
> > > Module('r.colors')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0
> > > colors.inputs["stdin"].value
> > > '1 red'
> > > colors.outputs["stdout"].value
> > > ''
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors = Module(
> > > ... "r.colors", map="test_a", rules="-", run\_=False, finish\_=False, stdin\_=PIPE
> > > ... )
> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.returncode
> > > 0

> > > colors = Module(
> > > ... "r.colors",
> > > ... map="test_a",
> > > ... rules="-",
> > > ... run\_=False,
> > > ... finish\_=False,
> > > ... stdin\_=PIPE,
> > > ... stderr\_=PIPE,
> > > ... )
> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors.returncode
> > > 0

Run a second time

> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors.returncode
> > > 0

Run many times and change parameters for each run

> > > colors = Module("r.colors", map="test_a", color="ryb", run\_=False)
> > > colors.get_bash()
> > > 'r.colors map=test_a color=ryb offset=0.0 scale=1.0'
> > > colors.run()
> > > Module('r.colors')
> > > colors.update(color="gyr")
> > > colors.run()
> > > Module('r.colors')
> > > colors.update(color="ryg")
> > > colors.update(stderr\_=PIPE)
> > > colors.run()
> > > Module('r.colors')
> > > print(colors.outputs["stderr"].value.strip())
> > > Color table for raster map \<test_a> set to 'ryg'
> > > colors.update(color="byg")
> > > colors.update(stdout\_=PIPE)
> > > colors.run()
> > > Module('r.colors')
> > > print(colors.outputs["stderr"].value.strip())
> > > Color table for raster map \<test_a> set to 'byg'
> > > colors.get_bash()
> > > 'r.colors map=test_a color=byg offset=0.0 scale=1.0'

Often in the Module class you can find `*args` and `kwargs` annotation
in methods, like in the __call__ method.
Python allow developers to not specify all the arguments and
keyword arguments of a method or function. ::

```
def f(*args):
    for arg in args:
        print arg
```

therefore if we call the function like:

> > > f("grass", "gis", "modules") # doctest: +SKIP
> > > grass
> > > gis
> > > modules

or we can define a new list:

> > > words = ["grass", "gis", "modules"] # doctest: +SKIP
> > > f(\*words) # doctest: +SKIP
> > > grass
> > > gis
> > > modules

we can do the same with keyword arguments, rewrite the above function: ::

```
def f(*args, **kargs):
    for arg in args:
        print arg
    for key, value in kargs.items():
        print "%s = %r" % (key, value)
```

now we can use the new function, with:

> > > f("grass", "gis", "modules", os="linux", language="python")
> > > ... # doctest: +SKIP
> > > grass
> > > gis
> > > modules
> > > os = 'linux'
> > > language = 'python'

or, as before we can, define a dictionary and give the dictionary to
the function, like:

> > > keywords = {"os": "linux", "language": "python"} # doctest: +SKIP
> > > f(\*words, \*\*keywords) # doctest: +SKIP
> > > grass
> > > gis
> > > modules
> > > os = 'linux'
> > > language = 'python'

In the Module class we heavily use this language feature to pass arguments
and keyword arguments to the grass module.

**Functions:**

- [**check**](#grass.pygrass.modules.interface.Module.check) – Check the correctness of the provide parameters
- [**get_bash**](#grass.pygrass.modules.interface.Module.get_bash) – Return a BASH representation of the Module.
- [**get_dict**](#grass.pygrass.modules.interface.Module.get_dict) – Return a dictionary that includes the name, all valid
- [**get_python**](#grass.pygrass.modules.interface.Module.get_python) – Return a Python representation of the Module.
- [**make_cmd**](#grass.pygrass.modules.interface.Module.make_cmd) – Create the command string that can be executed in a shell
- [**run**](#grass.pygrass.modules.interface.Module.run) – Run the module
- [**update**](#grass.pygrass.modules.interface.Module.update) – Update module parameters and selected object attributes.
- [**wait**](#grass.pygrass.modules.interface.Module.wait) – Wait for the module to finish. Call this method if

**Attributes:**

- [**check\_**](#grass.pygrass.modules.interface.Module.check_) –
- [**env\_**](#grass.pygrass.modules.interface.Module.env_) –
- [**finish\_**](#grass.pygrass.modules.interface.Module.finish_) –
- [**flags**](#grass.pygrass.modules.interface.Module.flags) –
- [**inputs**](#grass.pygrass.modules.interface.Module.inputs) –
- [**name**](#grass.pygrass.modules.interface.Module.name) –
- [**outputs**](#grass.pygrass.modules.interface.Module.outputs) –
- [**params_list**](#grass.pygrass.modules.interface.Module.params_list) –
- [**required**](#grass.pygrass.modules.interface.Module.required) –
- [**returncode**](#grass.pygrass.modules.interface.Module.returncode) –
- [**run\_**](#grass.pygrass.modules.interface.Module.run_) –
- [**start_time**](#grass.pygrass.modules.interface.Module.start_time) –
- [**stderr\_**](#grass.pygrass.modules.interface.Module.stderr_) –
- [**stdin**](#grass.pygrass.modules.interface.Module.stdin) –
- [**stdin\_**](#grass.pygrass.modules.interface.Module.stdin_) –
- [**stdout\_**](#grass.pygrass.modules.interface.Module.stdout_) –
- [**time**](#grass.pygrass.modules.interface.Module.time) –
- [**xml**](#grass.pygrass.modules.interface.Module.xml) –

####### grass.pygrass.modules.interface.Module.check

```python
check()
```

Check the correctness of the provide parameters

####### grass.pygrass.modules.interface.Module.check\_

```python
check_ = True
```

####### grass.pygrass.modules.interface.Module.env\_

```python
env_ = None
```

####### grass.pygrass.modules.interface.Module.finish\_

```python
finish_ = True
```

####### grass.pygrass.modules.interface.Module.flags

```python
flags = TypeDict(Flag)
```

####### grass.pygrass.modules.interface.Module.get_bash

```python
get_bash()
```

Return a BASH representation of the Module.

####### grass.pygrass.modules.interface.Module.get_dict

```python
get_dict()
```

Return a dictionary that includes the name, all valid
inputs, outputs and flags

####### grass.pygrass.modules.interface.Module.get_python

```python
get_python()
```

Return a Python representation of the Module.

####### grass.pygrass.modules.interface.Module.inputs

```python
inputs = TypeDict(Parameter)
```

####### grass.pygrass.modules.interface.Module.make_cmd

```python
make_cmd()
```

Create the command string that can be executed in a shell

:returns: the command string

####### grass.pygrass.modules.interface.Module.name

```python
name = cmd
```

####### grass.pygrass.modules.interface.Module.outputs

```python
outputs = TypeDict(Parameter)
```

####### grass.pygrass.modules.interface.Module.params_list

```python
params_list = [Parameter(p) for p in tree.findall('parameter')]
```

####### grass.pygrass.modules.interface.Module.required

```python
required = []
```

####### grass.pygrass.modules.interface.Module.returncode

```python
returncode = None
```

####### grass.pygrass.modules.interface.Module.run

```python
run()
```

Run the module
This function will wait for the process to terminate in case
finish\_==True and sets up stdout and stderr. If finish\_==False this
function will return after starting the process. Use wait() to wait for
the started process

:return: A reference to this object

####### grass.pygrass.modules.interface.Module.run\_

```python
run_ = True
```

####### grass.pygrass.modules.interface.Module.start_time

```python
start_time = None
```

####### grass.pygrass.modules.interface.Module.stderr\_

```python
stderr_ = None
```

####### grass.pygrass.modules.interface.Module.stdin

```python
stdin = None
```

####### grass.pygrass.modules.interface.Module.stdin\_

```python
stdin_ = None
```

####### grass.pygrass.modules.interface.Module.stdout\_

```python
stdout_ = None
```

####### grass.pygrass.modules.interface.Module.time

```python
time = None
```

####### grass.pygrass.modules.interface.Module.update

```python
update(*args, **kargs)
```

Update module parameters and selected object attributes.

Valid parameters are all the module parameters
and additional parameters, namely: run\_, stdin\_, stdout\_, stderr\_,
env\_, and finish\_.

####### grass.pygrass.modules.interface.Module.wait

```python
wait()
```

Wait for the module to finish. Call this method if
the run() call was performed with self.false\_ = False.

:return: A reference to this object

####### grass.pygrass.modules.interface.Module.xml

```python
xml = get_cmd_xml.communicate()[0]
```

###### grass.pygrass.modules.interface.MultiModule

```python
MultiModule(module_list, sync=True, set_temp_region=False)
```

This class is designed to run a list of modules in serial in the provided order
within a temporary region environment.

Module can be run in serial synchronously or asynchronously.

- Synchronously: When calling run() all modules will run in serial order
  until they are finished, The run() method will return until all
  modules finished. The modules objects can be accessed by calling
  get_modules() to check their return values.

- Asynchronously: When calling run() all modules will run in serial order in a
  background process. Method run() will return after starting the
  modules without waiting for them to finish. The user must call
  the wait() method to wait for the modules to finish.
  Asynchronously called module can be optionally run in a temporary
  region environment, hence invoking g.region will not alter the
  current region or the region of other MultiModule runs.

  ```
              Note:

                  Modules run in asynchronous mode can only be accessed via the
                  wait() method. The wait() method will return all finished
                  module objects as list.
  ```

Objects of this class can be passed to the ParallelModuleQueue to run serial stacks
of modules in parallel. This is meaningful if region settings must be applied
to each parallel module run.

> > > from grass.pygrass.modules import Module
> > > from grass.pygrass.modules import MultiModule
> > > from multiprocessing import Process
> > > import copy

Synchronous module run

> > > region_1 = Module("g.region", run\_=False)
> > > region_1.flags.p = True
> > > region_2 = copy.deepcopy(region_1)
> > > region_2.flags.p = True
> > > mm = MultiModule(module_list=[region_1, region_2])
> > > mm.run()
> > > m_list = mm.get_modules()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0

Asynchronous module run, setting finish = False

> > > region_1 = Module("g.region", run\_=False)
> > > region_1.flags.p = True
> > > region_2 = copy.deepcopy(region_1)
> > > region_2.flags.p = True
> > > region_3 = copy.deepcopy(region_1)
> > > region_3.flags.p = True
> > > region_4 = copy.deepcopy(region_1)
> > > region_4.flags.p = True
> > > region_5 = copy.deepcopy(region_1)
> > > region_5.flags.p = True
> > > mm = MultiModule(
> > > ... module_list=[region_1, region_2, region_3, region_4, region_5], sync=False
> > > ... )
> > > t = mm.run()
> > > isinstance(t, Process)
> > > True
> > > m_list = mm.wait()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0
> > > m_list[2].returncode
> > > 0
> > > m_list[3].returncode
> > > 0
> > > m_list[4].returncode
> > > 0

Asynchronous module run, setting finish = False and using temporary region

> > > mm = MultiModule(
> > > ... module_list=[region_1, region_2, region_3, region_4, region_5],
> > > ... sync=False,
> > > ... set_temp_region=True,
> > > ... )
> > > str(mm)
> > > 'g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p'
> > > t = mm.run()
> > > isinstance(t, Process)
> > > True
> > > m_list = mm.wait()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0
> > > m_list[2].returncode
> > > 0
> > > m_list[3].returncode
> > > 0
> > > m_list[4].returncode
> > > 0

**Functions:**

- [**get_modules**](#grass.pygrass.modules.interface.MultiModule.get_modules) – Return the list of modules that have been run in synchronous mode
- [**run**](#grass.pygrass.modules.interface.MultiModule.run) – Start the modules in the list. If self.finished\_ is set True
- [**wait**](#grass.pygrass.modules.interface.MultiModule.wait) – Wait for all processes to finish. Call this method

**Attributes:**

- [**finish\_**](#grass.pygrass.modules.interface.MultiModule.finish_) –
- [**module_list**](#grass.pygrass.modules.interface.MultiModule.module_list) –
- [**p**](#grass.pygrass.modules.interface.MultiModule.p) –
- [**q**](#grass.pygrass.modules.interface.MultiModule.q) –
- [**set_temp_region**](#grass.pygrass.modules.interface.MultiModule.set_temp_region) –

Constructor of the multi module class

:param module_list: A list of pre-configured Module objects that should be run
:param sync: If set True the run() method will wait for all processes to finish
-> synchronously run.
If set False, the run() method will return after starting the
processes -> asynchronously run. The wait() method must be called
to finish the modules.
:param set_temp_region: Set a temporary region in which the modules should be
run, hence region settings in the process list will not
affect the current computation region.

```
                    Note:

                        This flag is only available in asynchronous mode!
```

:return:

####### grass.pygrass.modules.interface.MultiModule.finish\_

```python
finish_ = sync
```

####### grass.pygrass.modules.interface.MultiModule.get_modules

```python
get_modules()
```

Return the list of modules that have been run in synchronous mode

Note: Asynchronously run module can only be accessed via the wait() method.

:return: The list of modules

####### grass.pygrass.modules.interface.MultiModule.module_list

```python
module_list = module_list
```

####### grass.pygrass.modules.interface.MultiModule.p

```python
p = None
```

####### grass.pygrass.modules.interface.MultiModule.q

```python
q = Queue()
```

####### grass.pygrass.modules.interface.MultiModule.run

```python
run()
```

Start the modules in the list. If self.finished\_ is set True
this method will return after all processes finished.

If self.finish\_ is set False, this method will return
after the process list was started for execution.
In a background process, the processes in the list will
be run one after the another.

:return: None in case of self.finish\_ is True,
otherwise a multiprocessing.Process object that invokes the modules

####### grass.pygrass.modules.interface.MultiModule.set_temp_region

```python
set_temp_region = set_temp_region
```

####### grass.pygrass.modules.interface.MultiModule.wait

```python
wait()
```

Wait for all processes to finish. Call this method
in asynchronous mode, hence if finished was set False.

:return: The process list with finished processes to check their return states

###### grass.pygrass.modules.interface.ParallelModuleQueue

```python
ParallelModuleQueue(nprocs=1)
```

This class is designed to run an arbitrary number of pygrass Module or
MultiModule processes in parallel.

Objects of type grass.pygrass.modules.Module or
grass.pygrass.modules.MultiModule can be put into the
queue using put() method. When the queue is full with the maximum
number of parallel processes it will wait for all processes to finish,
sets the stdout and stderr of the Module object and removes it
from the queue when its finished.

To finish the queue before the maximum number of parallel
processes was reached call wait() .

This class will raise a GrassError in case a Module process exits
with a return code other than 0.

Processes that were run asynchronously with the MultiModule class
will not raise a GrassError in case of failure. This must be manually checked
by accessing finished modules by calling get_finished_modules().

Usage:

Check with a queue size of 3 and 5 processes

> > > import copy
> > > from grass.pygrass.modules import Module, MultiModule, ParallelModuleQueue
> > > mapcalc_list = []

Setting run\_ to False is important, otherwise a parallel processing is not possible

> > > mapcalc = Module("r.mapcalc", overwrite=True, run\_=False)
> > > queue = ParallelModuleQueue(nprocs=3)
> > > for i in range(5):
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... mapcalc_list.append(new_mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... queue.put(m)
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 8 and 5 processes

> > > queue = ParallelModuleQueue(nprocs=8)
> > > mapcalc_list = []
> > > for i in range(5):
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... mapcalc_list.append(new_mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... queue.put(m)
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 8
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check MultiModule approach with three by two processes running in a background process

> > > gregion = Module("g.region", flags="p", run\_=False)
> > > queue = ParallelModuleQueue(nprocs=3)
> > > proc_list = []
> > > for i in range(3):
> > > ... new_gregion = copy.deepcopy(gregion)
> > > ... proc_list.append(new_gregion)
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... proc_list.append(new_mapcalc)
> > > ... mm = MultiModule(
> > > ... module_list=[new_gregion, new_mapcalc], sync=False, set_temp_region=True
> > > ... )
> > > ... queue.put(mm)
> > > queue.wait()
> > > proc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for proc in proc_list:
> > > ... print(proc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 8 and 4 processes

> > > queue = ParallelModuleQueue(nprocs=8)
> > > mapcalc_list = []
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_1 =1")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_2 =2")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 2
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_3 =3")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 3
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_4 =4")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 4
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 8
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 3 and 4 processes

> > > queue = ParallelModuleQueue(nprocs=3)
> > > mapcalc_list = []
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_1 =1")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_2 =2")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 2
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_3 =3")
> > > queue.put(
> > > ... m
> > > ... ) # Now it will wait until all procs finish and set the counter back to 0
> > > queue.get_num_run_procs()
> > > 0
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0

**Functions:**

- [**get**](#grass.pygrass.modules.interface.ParallelModuleQueue.get) – Get a Module object or list of Module objects from the queue
- [**get_finished_modules**](#grass.pygrass.modules.interface.ParallelModuleQueue.get_finished_modules) – Return all finished processes that were run by this queue
- [**get_max_num_procs**](#grass.pygrass.modules.interface.ParallelModuleQueue.get_max_num_procs) – Return the maximum number of parallel Module processes
- [**get_num_run_procs**](#grass.pygrass.modules.interface.ParallelModuleQueue.get_num_run_procs) – Get the number of Module processes that are in the queue running
- [**put**](#grass.pygrass.modules.interface.ParallelModuleQueue.put) – Put the next Module or MultiModule object in the queue
- [**set_max_num_procs**](#grass.pygrass.modules.interface.ParallelModuleQueue.set_max_num_procs) – Set the maximum number of Module processes that should run
- [**wait**](#grass.pygrass.modules.interface.ParallelModuleQueue.wait) – Wait for all Module processes that are in the list to finish

Constructor

:param nprocs: The maximum number of Module processes that
can be run in parallel, default is 1, if None
then use all the available CPUs.
:type nprocs: int

####### grass.pygrass.modules.interface.ParallelModuleQueue.get

```python
get(num)
```

Get a Module object or list of Module objects from the queue

:param num: the number of the object in queue
:type num: int
:returns: the Module object or list of Module objects or None if num is not in
the queue

####### grass.pygrass.modules.interface.ParallelModuleQueue.get_finished_modules

```python
get_finished_modules()
```

Return all finished processes that were run by this queue

:return: A list of Module objects

####### grass.pygrass.modules.interface.ParallelModuleQueue.get_max_num_procs

```python
get_max_num_procs()
```

Return the maximum number of parallel Module processes

:returns: the maximum number of parallel Module processes

####### grass.pygrass.modules.interface.ParallelModuleQueue.get_num_run_procs

```python
get_num_run_procs()
```

Get the number of Module processes that are in the queue running
or finished

:returns: the number of Module processes running/finished in the queue

####### grass.pygrass.modules.interface.ParallelModuleQueue.put

```python
put(module)
```

Put the next Module or MultiModule object in the queue

To run the Module objects in parallel the run\_ and finish\_ options
of the Module must be set to False.

:param module: a preconfigured Module or MultiModule object that were configured
with run\_ and finish\_ set to False,
:type module: Module or MultiModule object

####### grass.pygrass.modules.interface.ParallelModuleQueue.set_max_num_procs

```python
set_max_num_procs(nprocs)
```

Set the maximum number of Module processes that should run
in parallel

:param nprocs: The maximum number of Module processes that can be
run in parallel
:type nprocs: int

####### grass.pygrass.modules.interface.ParallelModuleQueue.wait

```python
wait()
```

Wait for all Module processes that are in the list to finish
and set the modules stdout and stderr output options

:return: A list of modules that were run

###### grass.pygrass.modules.interface.docstring

**Classes:**

- [**DocstringProperty**](#grass.pygrass.modules.interface.docstring.DocstringProperty) – Property for the `__doc__` attribute.

**Functions:**

- [**docstring_property**](#grass.pygrass.modules.interface.docstring.docstring_property) – Property attribute for docstrings.

####### grass.pygrass.modules.interface.docstring.DocstringProperty

```python
DocstringProperty(class_doc, fget)
```

Property for the `__doc__` attribute.

Different than `property` in the following two ways:

- When the attribute is accessed from the main class, it returns the value
  of `class_doc`, *not* the property itself. This is necessary so Sphinx
  and other documentation tools can access the class docstring.

- Only supports getting the attribute; setting and deleting raise an
  `AttributeError`.

**Attributes:**

- [**class_doc**](#grass.pygrass.modules.interface.docstring.DocstringProperty.class_doc) –
- [**fget**](#grass.pygrass.modules.interface.docstring.DocstringProperty.fget) –

######## grass.pygrass.modules.interface.docstring.DocstringProperty.class_doc

```python
class_doc = class_doc
```

######## grass.pygrass.modules.interface.docstring.DocstringProperty.fget

```python
fget = fget
```

####### grass.pygrass.modules.interface.docstring.docstring_property

```python
docstring_property(class_doc)
```

Property attribute for docstrings.
Took from: https://gist.github.com/bfroehle/4041015

> > > class A(object):
> > > ... '''Main docstring'''
> > > ...
> > > ... def __init__(self, x):
> > > ... self.x = x
> > > ...
> > > ... @docstring_property(__doc__)
> > > ... def __doc__(self):
> > > ... return "My value of x is %s." % self.x

> > > A.__doc__
> > > 'Main docstring'

> > > a = A(10)
> > > a.__doc__
> > > 'My value of x is 10.'

###### grass.pygrass.modules.interface.env

Created on Thu May 28 17:41:32 2015

@author: pietro

**Functions:**

- [**G_debug**](#grass.pygrass.modules.interface.env.G_debug) – Print or write a debug message, this is a pure python implementation
- [**get_debug_level**](#grass.pygrass.modules.interface.env.get_debug_level) – Return the debug level
- [**get_env**](#grass.pygrass.modules.interface.env.get_env) – Parse the GISRC file and return the GRASS variables

####### grass.pygrass.modules.interface.env.G_debug

```python
G_debug(level, *msg)
```

Print or write a debug message, this is a pure python implementation
of the G_debug function in the C API.

####### grass.pygrass.modules.interface.env.get_debug_level

```python
get_debug_level()
```

Return the debug level

####### grass.pygrass.modules.interface.env.get_env

```python
get_env()
```

Parse the GISRC file and return the GRASS variables

###### grass.pygrass.modules.interface.flag

**Classes:**

- [**Flag**](#grass.pygrass.modules.interface.flag.Flag) – The Flag object store all information about a flag of module.

####### grass.pygrass.modules.interface.flag.Flag

```python
Flag(xflag=None, diz=None)
```

The Flag object store all information about a flag of module.

It is possible to set flags of command using this object.

> > > flag = Flag(diz=dict(name="a", description="Flag description", default=True))
> > > flag.name
> > > 'a'
> > > flag.special
> > > False
> > > flag.description
> > > 'Flag description'
> > > flag = Flag(diz=dict(name="overwrite"))
> > > flag.name
> > > 'overwrite'
> > > flag.special
> > > True

**Functions:**

- [**get_bash**](#grass.pygrass.modules.interface.flag.Flag.get_bash) – Return the BASH representation of a flag.
- [**get_python**](#grass.pygrass.modules.interface.flag.Flag.get_python) – Return the python representation of a flag.

**Attributes:**

- [**default**](#grass.pygrass.modules.interface.flag.Flag.default) –
- [**description**](#grass.pygrass.modules.interface.flag.Flag.description) –
- [**guisection**](#grass.pygrass.modules.interface.flag.Flag.guisection) –
- [**name**](#grass.pygrass.modules.interface.flag.Flag.name) –
- [**special**](#grass.pygrass.modules.interface.flag.Flag.special) –
- [**suppress_required**](#grass.pygrass.modules.interface.flag.Flag.suppress_required) –
- [**value**](#grass.pygrass.modules.interface.flag.Flag.value) –

######## grass.pygrass.modules.interface.flag.Flag.default

```python
default = diz.get('default', None)
```

######## grass.pygrass.modules.interface.flag.Flag.description

```python
description = diz.get('description', None)
```

######## grass.pygrass.modules.interface.flag.Flag.get_bash

```python
get_bash()
```

Return the BASH representation of a flag.

> > > flag = Flag(
> > > ... diz=dict(name="a", description="Flag description", default=True)
> > > ... )
> > > flag.get_bash()
> > > ''
> > > flag.value = True
> > > flag.get_bash()
> > > '-a'
> > > flag = Flag(diz=dict(name="overwrite"))
> > > flag.get_bash()
> > > ''
> > > flag.value = True
> > > flag.get_bash()
> > > '--o'

######## grass.pygrass.modules.interface.flag.Flag.get_python

```python
get_python()
```

Return the python representation of a flag.

> > > flag = Flag(
> > > ... diz=dict(name="a", description="Flag description", default=True)
> > > ... )
> > > flag.get_python()
> > > ''
> > > flag.value = True
> > > flag.get_python()
> > > 'a'
> > > flag = Flag(diz=dict(name="overwrite"))
> > > flag.get_python()
> > > ''
> > > flag.value = True
> > > flag.get_python()
> > > 'overwrite=True'

######## grass.pygrass.modules.interface.flag.Flag.guisection

```python
guisection = diz.get('guisection', None)
```

######## grass.pygrass.modules.interface.flag.Flag.name

```python
name = diz['name']
```

######## grass.pygrass.modules.interface.flag.Flag.special

```python
special = self.name in {'verbose', 'overwrite', 'quiet', 'run'}
```

######## grass.pygrass.modules.interface.flag.Flag.suppress_required

```python
suppress_required = 'suppress_required' in diz
```

######## grass.pygrass.modules.interface.flag.Flag.value

```python
value = False
```

###### grass.pygrass.modules.interface.module

**Classes:**

- [**Module**](#grass.pygrass.modules.interface.module.Module) – This class is design to wrap/run/interact with the GRASS modules.
- [**MultiModule**](#grass.pygrass.modules.interface.module.MultiModule) – This class is designed to run a list of modules in serial in the provided order
- [**ParallelModuleQueue**](#grass.pygrass.modules.interface.module.ParallelModuleQueue) – This class is designed to run an arbitrary number of pygrass Module or

**Functions:**

- [**run_modules**](#grass.pygrass.modules.interface.module.run_modules) – Run the modules
- [**run_modules_in_temp_region**](#grass.pygrass.modules.interface.module.run_modules_in_temp_region) – Run the modules in a temporary region environment

####### grass.pygrass.modules.interface.module.Module

```python
Module(cmd, *args, **kargs)
```

This class is design to wrap/run/interact with the GRASS modules.

The class during the init phase read the XML description generate using
the `--interface-description` in order to understand which parameters
are required which optionals. ::

> > > from grass.pygrass.modules import Module
> > > from subprocess import PIPE
> > > import copy

> > > region = Module("g.region")
> > > region.flags.p = True # set flags
> > > region.flags.u = True
> > > region.flags["3"].value = True # set numeric flags
> > > region.get_bash()
> > > 'g.region format=plain -p -3 -u'
> > > new_region = copy.deepcopy(region)
> > > new_region.inputs.res = "10"
> > > new_region.get_bash()
> > > 'g.region res=10 format=plain -p -3 -u'

> > > neighbors = Module("r.neighbors")
> > > neighbors.inputs.input = "mapA"
> > > neighbors.outputs.output = "mapB"
> > > neighbors.inputs.size = 5
> > > neighbors.inputs.quantile = 0.5
> > > neighbors.get_bash()
> > > 'r.neighbors input=mapA size=5 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > new_neighbors1 = copy.deepcopy(neighbors)
> > > new_neighbors1.inputs.input = "mapD"
> > > new_neighbors1.inputs.size = 3
> > > new_neighbors1.inputs.quantile = 0.5
> > > new_neighbors1.get_bash()
> > > 'r.neighbors input=mapD size=3 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > new_neighbors2 = copy.deepcopy(neighbors)
> > > new_neighbors2(input="mapD", size=3, run\_=False)
> > > Module('r.neighbors')
> > > new_neighbors2.get_bash()
> > > 'r.neighbors input=mapD size=3 method=average weighting_function=none quantile=0.5 nprocs=1 memory=300 output=mapB'

> > > neighbors = Module("r.neighbors")
> > > neighbors.get_bash()
> > > 'r.neighbors size=3 method=average weighting_function=none nprocs=1 memory=300'

> > > new_neighbors3 = copy.deepcopy(neighbors)
> > > new_neighbors3(input="mapA", size=3, output="mapB", run\_=False)
> > > Module('r.neighbors')
> > > new_neighbors3.get_bash()
> > > 'r.neighbors input=mapA size=3 method=average weighting_function=none nprocs=1 memory=300 output=mapB'

> > > mapcalc = Module(
> > > ... "r.mapcalc", expression="test_a = 1", overwrite=True, run\_=False
> > > ... )
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > mapcalc.returncode
> > > 0

> > > mapcalc = Module(
> > > ... "r.mapcalc",
> > > ... expression="test_a = 1",
> > > ... overwrite=True,
> > > ... run\_=False,
> > > ... finish\_=False,
> > > ... )
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0
> > > mapcalc.run()
> > > Module('r.mapcalc')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0

> > > colors = Module(
> > > ... "r.colors",
> > > ... map="test_a",
> > > ... rules="-",
> > > ... run\_=False,
> > > ... stdout\_=PIPE,
> > > ... stderr\_=PIPE,
> > > ... stdin\_="1 red",
> > > ... )
> > > colors.run()
> > > Module('r.colors')
> > > p = mapcalc.wait()
> > > p.returncode
> > > 0
> > > colors.inputs["stdin"].value
> > > '1 red'
> > > colors.outputs["stdout"].value
> > > ''
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors = Module(
> > > ... "r.colors", map="test_a", rules="-", run\_=False, finish\_=False, stdin\_=PIPE
> > > ... )
> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.returncode
> > > 0

> > > colors = Module(
> > > ... "r.colors",
> > > ... map="test_a",
> > > ... rules="-",
> > > ... run\_=False,
> > > ... finish\_=False,
> > > ... stdin\_=PIPE,
> > > ... stderr\_=PIPE,
> > > ... )
> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors.returncode
> > > 0

Run a second time

> > > colors.inputs["stdin"].value = "1 red"
> > > colors.run()
> > > Module('r.colors')
> > > colors.wait()
> > > Module('r.colors')
> > > colors.outputs["stderr"].value.strip()
> > > "Color table for raster map \<test_a> set to 'rules'"

> > > colors.returncode
> > > 0

Run many times and change parameters for each run

> > > colors = Module("r.colors", map="test_a", color="ryb", run\_=False)
> > > colors.get_bash()
> > > 'r.colors map=test_a color=ryb offset=0.0 scale=1.0'
> > > colors.run()
> > > Module('r.colors')
> > > colors.update(color="gyr")
> > > colors.run()
> > > Module('r.colors')
> > > colors.update(color="ryg")
> > > colors.update(stderr\_=PIPE)
> > > colors.run()
> > > Module('r.colors')
> > > print(colors.outputs["stderr"].value.strip())
> > > Color table for raster map \<test_a> set to 'ryg'
> > > colors.update(color="byg")
> > > colors.update(stdout\_=PIPE)
> > > colors.run()
> > > Module('r.colors')
> > > print(colors.outputs["stderr"].value.strip())
> > > Color table for raster map \<test_a> set to 'byg'
> > > colors.get_bash()
> > > 'r.colors map=test_a color=byg offset=0.0 scale=1.0'

Often in the Module class you can find `*args` and `kwargs` annotation
in methods, like in the __call__ method.
Python allow developers to not specify all the arguments and
keyword arguments of a method or function. ::

```
def f(*args):
    for arg in args:
        print arg
```

therefore if we call the function like:

> > > f("grass", "gis", "modules") # doctest: +SKIP
> > > grass
> > > gis
> > > modules

or we can define a new list:

> > > words = ["grass", "gis", "modules"] # doctest: +SKIP
> > > f(\*words) # doctest: +SKIP
> > > grass
> > > gis
> > > modules

we can do the same with keyword arguments, rewrite the above function: ::

```
def f(*args, **kargs):
    for arg in args:
        print arg
    for key, value in kargs.items():
        print "%s = %r" % (key, value)
```

now we can use the new function, with:

> > > f("grass", "gis", "modules", os="linux", language="python")
> > > ... # doctest: +SKIP
> > > grass
> > > gis
> > > modules
> > > os = 'linux'
> > > language = 'python'

or, as before we can, define a dictionary and give the dictionary to
the function, like:

> > > keywords = {"os": "linux", "language": "python"} # doctest: +SKIP
> > > f(\*words, \*\*keywords) # doctest: +SKIP
> > > grass
> > > gis
> > > modules
> > > os = 'linux'
> > > language = 'python'

In the Module class we heavily use this language feature to pass arguments
and keyword arguments to the grass module.

**Functions:**

- [**check**](#grass.pygrass.modules.interface.module.Module.check) – Check the correctness of the provide parameters
- [**get_bash**](#grass.pygrass.modules.interface.module.Module.get_bash) – Return a BASH representation of the Module.
- [**get_dict**](#grass.pygrass.modules.interface.module.Module.get_dict) – Return a dictionary that includes the name, all valid
- [**get_python**](#grass.pygrass.modules.interface.module.Module.get_python) – Return a Python representation of the Module.
- [**make_cmd**](#grass.pygrass.modules.interface.module.Module.make_cmd) – Create the command string that can be executed in a shell
- [**run**](#grass.pygrass.modules.interface.module.Module.run) – Run the module
- [**update**](#grass.pygrass.modules.interface.module.Module.update) – Update module parameters and selected object attributes.
- [**wait**](#grass.pygrass.modules.interface.module.Module.wait) – Wait for the module to finish. Call this method if

**Attributes:**

- [**check\_**](#grass.pygrass.modules.interface.module.Module.check_) –
- [**env\_**](#grass.pygrass.modules.interface.module.Module.env_) –
- [**finish\_**](#grass.pygrass.modules.interface.module.Module.finish_) –
- [**flags**](#grass.pygrass.modules.interface.module.Module.flags) –
- [**inputs**](#grass.pygrass.modules.interface.module.Module.inputs) –
- [**name**](#grass.pygrass.modules.interface.module.Module.name) –
- [**outputs**](#grass.pygrass.modules.interface.module.Module.outputs) –
- [**params_list**](#grass.pygrass.modules.interface.module.Module.params_list) –
- [**required**](#grass.pygrass.modules.interface.module.Module.required) –
- [**returncode**](#grass.pygrass.modules.interface.module.Module.returncode) –
- [**run\_**](#grass.pygrass.modules.interface.module.Module.run_) –
- [**start_time**](#grass.pygrass.modules.interface.module.Module.start_time) –
- [**stderr\_**](#grass.pygrass.modules.interface.module.Module.stderr_) –
- [**stdin**](#grass.pygrass.modules.interface.module.Module.stdin) –
- [**stdin\_**](#grass.pygrass.modules.interface.module.Module.stdin_) –
- [**stdout\_**](#grass.pygrass.modules.interface.module.Module.stdout_) –
- [**time**](#grass.pygrass.modules.interface.module.Module.time) –
- [**xml**](#grass.pygrass.modules.interface.module.Module.xml) –

######## grass.pygrass.modules.interface.module.Module.check

```python
check()
```

Check the correctness of the provide parameters

######## grass.pygrass.modules.interface.module.Module.check\_

```python
check_ = True
```

######## grass.pygrass.modules.interface.module.Module.env\_

```python
env_ = None
```

######## grass.pygrass.modules.interface.module.Module.finish\_

```python
finish_ = True
```

######## grass.pygrass.modules.interface.module.Module.flags

```python
flags = TypeDict(Flag)
```

######## grass.pygrass.modules.interface.module.Module.get_bash

```python
get_bash()
```

Return a BASH representation of the Module.

######## grass.pygrass.modules.interface.module.Module.get_dict

```python
get_dict()
```

Return a dictionary that includes the name, all valid
inputs, outputs and flags

######## grass.pygrass.modules.interface.module.Module.get_python

```python
get_python()
```

Return a Python representation of the Module.

######## grass.pygrass.modules.interface.module.Module.inputs

```python
inputs = TypeDict(Parameter)
```

######## grass.pygrass.modules.interface.module.Module.make_cmd

```python
make_cmd()
```

Create the command string that can be executed in a shell

:returns: the command string

######## grass.pygrass.modules.interface.module.Module.name

```python
name = cmd
```

######## grass.pygrass.modules.interface.module.Module.outputs

```python
outputs = TypeDict(Parameter)
```

######## grass.pygrass.modules.interface.module.Module.params_list

```python
params_list = [Parameter(p) for p in tree.findall('parameter')]
```

######## grass.pygrass.modules.interface.module.Module.required

```python
required = []
```

######## grass.pygrass.modules.interface.module.Module.returncode

```python
returncode = None
```

######## grass.pygrass.modules.interface.module.Module.run

```python
run()
```

Run the module
This function will wait for the process to terminate in case
finish\_==True and sets up stdout and stderr. If finish\_==False this
function will return after starting the process. Use wait() to wait for
the started process

:return: A reference to this object

######## grass.pygrass.modules.interface.module.Module.run\_

```python
run_ = True
```

######## grass.pygrass.modules.interface.module.Module.start_time

```python
start_time = None
```

######## grass.pygrass.modules.interface.module.Module.stderr\_

```python
stderr_ = None
```

######## grass.pygrass.modules.interface.module.Module.stdin

```python
stdin = None
```

######## grass.pygrass.modules.interface.module.Module.stdin\_

```python
stdin_ = None
```

######## grass.pygrass.modules.interface.module.Module.stdout\_

```python
stdout_ = None
```

######## grass.pygrass.modules.interface.module.Module.time

```python
time = None
```

######## grass.pygrass.modules.interface.module.Module.update

```python
update(*args, **kargs)
```

Update module parameters and selected object attributes.

Valid parameters are all the module parameters
and additional parameters, namely: run\_, stdin\_, stdout\_, stderr\_,
env\_, and finish\_.

######## grass.pygrass.modules.interface.module.Module.wait

```python
wait()
```

Wait for the module to finish. Call this method if
the run() call was performed with self.false\_ = False.

:return: A reference to this object

######## grass.pygrass.modules.interface.module.Module.xml

```python
xml = get_cmd_xml.communicate()[0]
```

####### grass.pygrass.modules.interface.module.MultiModule

```python
MultiModule(module_list, sync=True, set_temp_region=False)
```

This class is designed to run a list of modules in serial in the provided order
within a temporary region environment.

Module can be run in serial synchronously or asynchronously.

- Synchronously: When calling run() all modules will run in serial order
  until they are finished, The run() method will return until all
  modules finished. The modules objects can be accessed by calling
  get_modules() to check their return values.

- Asynchronously: When calling run() all modules will run in serial order in a
  background process. Method run() will return after starting the
  modules without waiting for them to finish. The user must call
  the wait() method to wait for the modules to finish.
  Asynchronously called module can be optionally run in a temporary
  region environment, hence invoking g.region will not alter the
  current region or the region of other MultiModule runs.

  ```
              Note:

                  Modules run in asynchronous mode can only be accessed via the
                  wait() method. The wait() method will return all finished
                  module objects as list.
  ```

Objects of this class can be passed to the ParallelModuleQueue to run serial stacks
of modules in parallel. This is meaningful if region settings must be applied
to each parallel module run.

> > > from grass.pygrass.modules import Module
> > > from grass.pygrass.modules import MultiModule
> > > from multiprocessing import Process
> > > import copy

Synchronous module run

> > > region_1 = Module("g.region", run\_=False)
> > > region_1.flags.p = True
> > > region_2 = copy.deepcopy(region_1)
> > > region_2.flags.p = True
> > > mm = MultiModule(module_list=[region_1, region_2])
> > > mm.run()
> > > m_list = mm.get_modules()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0

Asynchronous module run, setting finish = False

> > > region_1 = Module("g.region", run\_=False)
> > > region_1.flags.p = True
> > > region_2 = copy.deepcopy(region_1)
> > > region_2.flags.p = True
> > > region_3 = copy.deepcopy(region_1)
> > > region_3.flags.p = True
> > > region_4 = copy.deepcopy(region_1)
> > > region_4.flags.p = True
> > > region_5 = copy.deepcopy(region_1)
> > > region_5.flags.p = True
> > > mm = MultiModule(
> > > ... module_list=[region_1, region_2, region_3, region_4, region_5], sync=False
> > > ... )
> > > t = mm.run()
> > > isinstance(t, Process)
> > > True
> > > m_list = mm.wait()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0
> > > m_list[2].returncode
> > > 0
> > > m_list[3].returncode
> > > 0
> > > m_list[4].returncode
> > > 0

Asynchronous module run, setting finish = False and using temporary region

> > > mm = MultiModule(
> > > ... module_list=[region_1, region_2, region_3, region_4, region_5],
> > > ... sync=False,
> > > ... set_temp_region=True,
> > > ... )
> > > str(mm)
> > > 'g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p ; g.region format=plain -p'
> > > t = mm.run()
> > > isinstance(t, Process)
> > > True
> > > m_list = mm.wait()
> > > m_list[0].returncode
> > > 0
> > > m_list[1].returncode
> > > 0
> > > m_list[2].returncode
> > > 0
> > > m_list[3].returncode
> > > 0
> > > m_list[4].returncode
> > > 0

**Functions:**

- [**get_modules**](#grass.pygrass.modules.interface.module.MultiModule.get_modules) – Return the list of modules that have been run in synchronous mode
- [**run**](#grass.pygrass.modules.interface.module.MultiModule.run) – Start the modules in the list. If self.finished\_ is set True
- [**wait**](#grass.pygrass.modules.interface.module.MultiModule.wait) – Wait for all processes to finish. Call this method

**Attributes:**

- [**finish\_**](#grass.pygrass.modules.interface.module.MultiModule.finish_) –
- [**module_list**](#grass.pygrass.modules.interface.module.MultiModule.module_list) –
- [**p**](#grass.pygrass.modules.interface.module.MultiModule.p) –
- [**q**](#grass.pygrass.modules.interface.module.MultiModule.q) –
- [**set_temp_region**](#grass.pygrass.modules.interface.module.MultiModule.set_temp_region) –

Constructor of the multi module class

:param module_list: A list of pre-configured Module objects that should be run
:param sync: If set True the run() method will wait for all processes to finish
-> synchronously run.
If set False, the run() method will return after starting the
processes -> asynchronously run. The wait() method must be called
to finish the modules.
:param set_temp_region: Set a temporary region in which the modules should be
run, hence region settings in the process list will not
affect the current computation region.

```
                    Note:

                        This flag is only available in asynchronous mode!
```

:return:

######## grass.pygrass.modules.interface.module.MultiModule.finish\_

```python
finish_ = sync
```

######## grass.pygrass.modules.interface.module.MultiModule.get_modules

```python
get_modules()
```

Return the list of modules that have been run in synchronous mode

Note: Asynchronously run module can only be accessed via the wait() method.

:return: The list of modules

######## grass.pygrass.modules.interface.module.MultiModule.module_list

```python
module_list = module_list
```

######## grass.pygrass.modules.interface.module.MultiModule.p

```python
p = None
```

######## grass.pygrass.modules.interface.module.MultiModule.q

```python
q = Queue()
```

######## grass.pygrass.modules.interface.module.MultiModule.run

```python
run()
```

Start the modules in the list. If self.finished\_ is set True
this method will return after all processes finished.

If self.finish\_ is set False, this method will return
after the process list was started for execution.
In a background process, the processes in the list will
be run one after the another.

:return: None in case of self.finish\_ is True,
otherwise a multiprocessing.Process object that invokes the modules

######## grass.pygrass.modules.interface.module.MultiModule.set_temp_region

```python
set_temp_region = set_temp_region
```

######## grass.pygrass.modules.interface.module.MultiModule.wait

```python
wait()
```

Wait for all processes to finish. Call this method
in asynchronous mode, hence if finished was set False.

:return: The process list with finished processes to check their return states

####### grass.pygrass.modules.interface.module.ParallelModuleQueue

```python
ParallelModuleQueue(nprocs=1)
```

This class is designed to run an arbitrary number of pygrass Module or
MultiModule processes in parallel.

Objects of type grass.pygrass.modules.Module or
grass.pygrass.modules.MultiModule can be put into the
queue using put() method. When the queue is full with the maximum
number of parallel processes it will wait for all processes to finish,
sets the stdout and stderr of the Module object and removes it
from the queue when its finished.

To finish the queue before the maximum number of parallel
processes was reached call wait() .

This class will raise a GrassError in case a Module process exits
with a return code other than 0.

Processes that were run asynchronously with the MultiModule class
will not raise a GrassError in case of failure. This must be manually checked
by accessing finished modules by calling get_finished_modules().

Usage:

Check with a queue size of 3 and 5 processes

> > > import copy
> > > from grass.pygrass.modules import Module, MultiModule, ParallelModuleQueue
> > > mapcalc_list = []

Setting run\_ to False is important, otherwise a parallel processing is not possible

> > > mapcalc = Module("r.mapcalc", overwrite=True, run\_=False)
> > > queue = ParallelModuleQueue(nprocs=3)
> > > for i in range(5):
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... mapcalc_list.append(new_mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... queue.put(m)
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 8 and 5 processes

> > > queue = ParallelModuleQueue(nprocs=8)
> > > mapcalc_list = []
> > > for i in range(5):
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... mapcalc_list.append(new_mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... queue.put(m)
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 8
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check MultiModule approach with three by two processes running in a background process

> > > gregion = Module("g.region", flags="p", run\_=False)
> > > queue = ParallelModuleQueue(nprocs=3)
> > > proc_list = []
> > > for i in range(3):
> > > ... new_gregion = copy.deepcopy(gregion)
> > > ... proc_list.append(new_gregion)
> > > ... new_mapcalc = copy.deepcopy(mapcalc)
> > > ... m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > ... proc_list.append(new_mapcalc)
> > > ... mm = MultiModule(
> > > ... module_list=[new_gregion, new_mapcalc], sync=False, set_temp_region=True
> > > ... )
> > > ... queue.put(mm)
> > > queue.wait()
> > > proc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for proc in proc_list:
> > > ... print(proc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 8 and 4 processes

> > > queue = ParallelModuleQueue(nprocs=8)
> > > mapcalc_list = []
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_1 =1")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_2 =2")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 2
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_3 =3")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 3
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_4 =4")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 4
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 8
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0

Check with a queue size of 3 and 4 processes

> > > queue = ParallelModuleQueue(nprocs=3)
> > > mapcalc_list = []
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_1 =1")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_2 =2")
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 2
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass_3 =3")
> > > queue.put(
> > > ... m
> > > ... ) # Now it will wait until all procs finish and set the counter back to 0
> > > queue.get_num_run_procs()
> > > 0
> > > new_mapcalc = copy.deepcopy(mapcalc)
> > > mapcalc_list.append(new_mapcalc)
> > > m = new_mapcalc(expression="test_pygrass\_%i = %i" % (i, i))
> > > queue.put(m)
> > > queue.get_num_run_procs()
> > > 1
> > > queue.wait()
> > > mapcalc_list = queue.get_finished_modules()
> > > queue.get_num_run_procs()
> > > 0
> > > queue.get_max_num_procs()
> > > 3
> > > for mapcalc in mapcalc_list:
> > > ... print(mapcalc.returncode)
> > > 0
> > > 0
> > > 0
> > > 0

**Functions:**

- [**get**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.get) – Get a Module object or list of Module objects from the queue
- [**get_finished_modules**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.get_finished_modules) – Return all finished processes that were run by this queue
- [**get_max_num_procs**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.get_max_num_procs) – Return the maximum number of parallel Module processes
- [**get_num_run_procs**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.get_num_run_procs) – Get the number of Module processes that are in the queue running
- [**put**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.put) – Put the next Module or MultiModule object in the queue
- [**set_max_num_procs**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.set_max_num_procs) – Set the maximum number of Module processes that should run
- [**wait**](#grass.pygrass.modules.interface.module.ParallelModuleQueue.wait) – Wait for all Module processes that are in the list to finish

Constructor

:param nprocs: The maximum number of Module processes that
can be run in parallel, default is 1, if None
then use all the available CPUs.
:type nprocs: int

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.get

```python
get(num)
```

Get a Module object or list of Module objects from the queue

:param num: the number of the object in queue
:type num: int
:returns: the Module object or list of Module objects or None if num is not in
the queue

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.get_finished_modules

```python
get_finished_modules()
```

Return all finished processes that were run by this queue

:return: A list of Module objects

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.get_max_num_procs

```python
get_max_num_procs()
```

Return the maximum number of parallel Module processes

:returns: the maximum number of parallel Module processes

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.get_num_run_procs

```python
get_num_run_procs()
```

Get the number of Module processes that are in the queue running
or finished

:returns: the number of Module processes running/finished in the queue

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.put

```python
put(module)
```

Put the next Module or MultiModule object in the queue

To run the Module objects in parallel the run\_ and finish\_ options
of the Module must be set to False.

:param module: a preconfigured Module or MultiModule object that were configured
with run\_ and finish\_ set to False,
:type module: Module or MultiModule object

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.set_max_num_procs

```python
set_max_num_procs(nprocs)
```

Set the maximum number of Module processes that should run
in parallel

:param nprocs: The maximum number of Module processes that can be
run in parallel
:type nprocs: int

######## grass.pygrass.modules.interface.module.ParallelModuleQueue.wait

```python
wait()
```

Wait for all Module processes that are in the list to finish
and set the modules stdout and stderr output options

:return: A list of modules that were run

####### grass.pygrass.modules.interface.module.run_modules

```python
run_modules(module_list, q)
```

Run the modules

This function is the argument for multiprocessing.Process class
in the MultiModule asynchronous execution.

:param module_list: The list of modules to run in serial
:param q: The process queue to put the finished process list

####### grass.pygrass.modules.interface.module.run_modules_in_temp_region

```python
run_modules_in_temp_region(module_list, q)
```

Run the modules in a temporary region environment

This function is the argument for multiprocessing.Process class
in the MultiModule asynchronous execution.

:param module_list: The list of modules to run in serial
:param q: The process queue to put the finished process list

###### grass.pygrass.modules.interface.parameter

Created on Tue Apr 2 18:31:47 2013

@author: pietro

**Classes:**

- [**Parameter**](#grass.pygrass.modules.interface.parameter.Parameter) – The Parameter object store all information about a parameter of a

####### grass.pygrass.modules.interface.parameter.Parameter

```python
Parameter(xparameter=None, diz=None)
```

The Parameter object store all information about a parameter of a
GRASS GIS module. ::

```
>>> param = Parameter(
...     diz=dict(
...         name="int_number",
...         required="yes",
...         multiple="no",
...         type="integer",
...         values=[2, 4, 6, 8],
...     )
... )
>>> param.value = 2
>>> param.value
2
>>> param.value = 3
Traceback (most recent call last):
   ...
ValueError: The parameter <int_number>, must be one of the following values: [2, 4, 6, 8] not '3'
```

...

**Functions:**

- [**get_bash**](#grass.pygrass.modules.interface.parameter.Parameter.get_bash) – Return the BASH representation of the parameter. ::
- [**get_python**](#grass.pygrass.modules.interface.parameter.Parameter.get_python) – Return a string with the Python representation of the parameter. ::

**Attributes:**

- [**default**](#grass.pygrass.modules.interface.parameter.Parameter.default) –
- [**description**](#grass.pygrass.modules.interface.parameter.Parameter.description) –
- [**guisection**](#grass.pygrass.modules.interface.parameter.Parameter.guisection) –
- [**input**](#grass.pygrass.modules.interface.parameter.Parameter.input) –
- [**isrange**](#grass.pygrass.modules.interface.parameter.Parameter.isrange) –
- [**max**](#grass.pygrass.modules.interface.parameter.Parameter.max) –
- [**min**](#grass.pygrass.modules.interface.parameter.Parameter.min) –
- [**multiple**](#grass.pygrass.modules.interface.parameter.Parameter.multiple) –
- [**name**](#grass.pygrass.modules.interface.parameter.Parameter.name) –
- [**rawvalue**](#grass.pygrass.modules.interface.parameter.Parameter.rawvalue) – Parameter value as insert by user without transformation
- [**required**](#grass.pygrass.modules.interface.parameter.Parameter.required) –
- [**type**](#grass.pygrass.modules.interface.parameter.Parameter.type) –
- [**typedesc**](#grass.pygrass.modules.interface.parameter.Parameter.typedesc) –
- [**value**](#grass.pygrass.modules.interface.parameter.Parameter.value) –
- [**values**](#grass.pygrass.modules.interface.parameter.Parameter.values) –

######## grass.pygrass.modules.interface.parameter.Parameter.default

```python
default = [self.type(v) for v in diz['default'].split(',')]
```

######## grass.pygrass.modules.interface.parameter.Parameter.description

```python
description = diz.get('description', None)
```

######## grass.pygrass.modules.interface.parameter.Parameter.get_bash

```python
get_bash()
```

Return the BASH representation of the parameter. ::

```
>>> param = Parameter(
...     diz=dict(
...         name="int_number",
...         required="yes",
...         multiple="no",
...         type="integer",
...         values=[2, 4, 6, 8],
...         default=8,
...     )
... )
>>> param.get_bash()
'int_number=8'
```

..

######## grass.pygrass.modules.interface.parameter.Parameter.get_python

```python
get_python()
```

Return a string with the Python representation of the parameter. ::

```
>>> param = Parameter(
...     diz=dict(
...         name="int_number",
...         required="yes",
...         multiple="no",
...         type="integer",
...         values=[2, 4, 6, 8],
...         default=8,
...     )
... )
>>> param.get_python()
'int_number=8'
```

..

######## grass.pygrass.modules.interface.parameter.Parameter.guisection

```python
guisection = diz.get('guisection', None)
```

######## grass.pygrass.modules.interface.parameter.Parameter.input

```python
input = diz['gisprompt']['age'] != 'new'
```

######## grass.pygrass.modules.interface.parameter.Parameter.isrange

```python
isrange = diz['values'][0]
```

######## grass.pygrass.modules.interface.parameter.Parameter.max

```python
max = None
```

######## grass.pygrass.modules.interface.parameter.Parameter.min

```python
min = None
```

######## grass.pygrass.modules.interface.parameter.Parameter.multiple

```python
multiple = diz['multiple'] == 'yes'
```

######## grass.pygrass.modules.interface.parameter.Parameter.name

```python
name = diz['name']
```

######## grass.pygrass.modules.interface.parameter.Parameter.rawvalue

```python
rawvalue
```

Parameter value as insert by user without transformation

######## grass.pygrass.modules.interface.parameter.Parameter.required

```python
required = diz['required'] == 'yes'
```

######## grass.pygrass.modules.interface.parameter.Parameter.type

```python
type = GETTYPE[diz['type']]
```

######## grass.pygrass.modules.interface.parameter.Parameter.typedesc

```python
typedesc = diz['type']
```

######## grass.pygrass.modules.interface.parameter.Parameter.value

```python
value = property(fget=_get_value, fset=_set_value, doc='Parameter value transformed and validated.')
```

######## grass.pygrass.modules.interface.parameter.Parameter.values

```python
values = None
```

###### grass.pygrass.modules.interface.read

Created on Tue Apr 2 18:30:34 2013

@author: pietro

**Functions:**

- [**do_nothing**](#grass.pygrass.modules.interface.read.do_nothing) –
- [**element2dict**](#grass.pygrass.modules.interface.read.element2dict) –
- [**get_None**](#grass.pygrass.modules.interface.read.get_None) –
- [**get_dict**](#grass.pygrass.modules.interface.read.get_dict) –
- [**get_values**](#grass.pygrass.modules.interface.read.get_values) –
- [**read_keydesc**](#grass.pygrass.modules.interface.read.read_keydesc) –
- [**read_text**](#grass.pygrass.modules.interface.read.read_text) –

**Attributes:**

- [**DOC**](#grass.pygrass.modules.interface.read.DOC) –
- [**GETFROMTAG**](#grass.pygrass.modules.interface.read.GETFROMTAG) –
- [**GETTYPE**](#grass.pygrass.modules.interface.read.GETTYPE) –

####### grass.pygrass.modules.interface.read.DOC

```python
DOC = {'head': '{cmd_name}({cmd_params})\n\nParameters\n----------\n\n', 'param': '{name}: {default}{required}{multi}{ptype}\n    {description}{values}{keydescvalues}', 'flag_head': '\nFlags\n------\n', 'flag': '{name}: {default}, {suppress}\n    {description}', 'foot': '\nSpecial Parameters\n------------------\n\nThe Module class have some optional parameters which are distinct using a final\nunderscore.\n\nrun_: True, optional\n    If True execute the module.\nfinish_: True, optional\n    If True wait until the end of the module execution, and store the module\n    outputs into stdout, stderr attributes of the class.\nstdin_: PIPE, optional\n    Set the standard input.\nenv_: dictionary, optional\n    Set the environment variables.\n'}
```

####### grass.pygrass.modules.interface.read.GETFROMTAG

```python
GETFROMTAG = {'description': read_text, 'keydesc': read_keydesc, 'gisprompt': get_dict, 'default': read_text, 'values': get_values, 'value': get_None, 'guisection': read_text, 'label': read_text, 'suppress_required': get_None, 'keywords': read_text, 'guidependency': read_text, 'rules': get_None}
```

####### grass.pygrass.modules.interface.read.GETTYPE

```python
GETTYPE = {'string': str, 'integer': int, 'float': float, 'double': float, 'file': str, 'all': do_nothing}
```

####### grass.pygrass.modules.interface.read.do_nothing

```python
do_nothing(p)
```

####### grass.pygrass.modules.interface.read.element2dict

```python
element2dict(xparameter)
```

####### grass.pygrass.modules.interface.read.get_None

```python
get_None(p)
```

####### grass.pygrass.modules.interface.read.get_dict

```python
get_dict(p)
```

####### grass.pygrass.modules.interface.read.get_values

```python
get_values(p)
```

####### grass.pygrass.modules.interface.read.read_keydesc

```python
read_keydesc(par)
```

####### grass.pygrass.modules.interface.read.read_text

```python
read_text(p)
```

###### grass.pygrass.modules.interface.typedict

Created on Tue Apr 2 18:37:02 2013

@author: pietro

**Classes:**

- [**TypeDict**](#grass.pygrass.modules.interface.typedict.TypeDict) –

####### grass.pygrass.modules.interface.typedict.TypeDict

```python
TypeDict(dict_type, *args, **kargs)
```

Bases: <code>[OrderedDict](#collections.OrderedDict)</code>

**Functions:**

- [**used**](#grass.pygrass.modules.interface.typedict.TypeDict.used) –

######## grass.pygrass.modules.interface.typedict.TypeDict.used

```python
used()
```

##### grass.pygrass.modules.shortcuts

**Classes:**

- [**MetaModule**](#grass.pygrass.modules.shortcuts.MetaModule) – Example how to use MetaModule

**Attributes:**

- [**database**](#grass.pygrass.modules.shortcuts.database) –
- [**display**](#grass.pygrass.modules.shortcuts.display) –
- [**general**](#grass.pygrass.modules.shortcuts.general) –
- [**imagery**](#grass.pygrass.modules.shortcuts.imagery) –
- [**miscellaneous**](#grass.pygrass.modules.shortcuts.miscellaneous) –
- [**postscript**](#grass.pygrass.modules.shortcuts.postscript) –
- [**raster**](#grass.pygrass.modules.shortcuts.raster) –
- [**raster3d**](#grass.pygrass.modules.shortcuts.raster3d) –
- [**temporal**](#grass.pygrass.modules.shortcuts.temporal) –
- [**vector**](#grass.pygrass.modules.shortcuts.vector) –

###### grass.pygrass.modules.shortcuts.MetaModule

```python
MetaModule(prefix, cls=None)
```

Example how to use MetaModule

> > > g = MetaModule("g")
> > > g_list = g.list
> > > g_list.name
> > > 'g.list'
> > > g_list.required
> > > ['type']
> > > g_list.inputs.type = "raster"
> > > g_list.inputs.mapset = "PERMANENT"
> > > g_list.stdout\_ = -1
> > > g_list.run()
> > > Module('g.list')
> > > g_list.outputs.stdout # doctest: +ELLIPSIS
> > > '...basin...elevation...'

> > > r = MetaModule("r")
> > > what = r.what
> > > what.description
> > > 'Queries raster maps on their category values and category labels.'
> > > what.inputs.map = "elevation"
> > > what.inputs.coordinates = [640000, 220500] # doctest: +SKIP
> > > what.run() # doctest: +SKIP
> > > v = MetaModule("v")
> > > v.import # doctest: +ELLIPSIS
> > > Traceback (most recent call last):
> > > File ".../doctest.py", line 1315, in \__run
> > > compileflags, 1) in test.globs
> > > File "\<doctest grass.pygrass.modules.shortcuts.MetaModule[16]>", line 1
> > > v.import
> > > ^
> > > SyntaxError: invalid syntax
> > > v.import_
> > > Module('v.import')

**Attributes:**

- [**cls**](#grass.pygrass.modules.shortcuts.MetaModule.cls) –
- [**prefix**](#grass.pygrass.modules.shortcuts.MetaModule.prefix) –

####### grass.pygrass.modules.shortcuts.MetaModule.cls

```python
cls = cls or Module
```

####### grass.pygrass.modules.shortcuts.MetaModule.prefix

```python
prefix = prefix
```

###### grass.pygrass.modules.shortcuts.database

```python
database = MetaModule('db')
```

###### grass.pygrass.modules.shortcuts.display

```python
display = MetaModule('d')
```

###### grass.pygrass.modules.shortcuts.general

```python
general = MetaModule('g')
```

###### grass.pygrass.modules.shortcuts.imagery

```python
imagery = MetaModule('i')
```

###### grass.pygrass.modules.shortcuts.miscellaneous

```python
miscellaneous = MetaModule('m')
```

###### grass.pygrass.modules.shortcuts.postscript

```python
postscript = MetaModule('ps')
```

###### grass.pygrass.modules.shortcuts.raster

```python
raster = MetaModule('r')
```

###### grass.pygrass.modules.shortcuts.raster3d

```python
raster3d = MetaModule('r3')
```

###### grass.pygrass.modules.shortcuts.temporal

```python
temporal = MetaModule('t')
```

###### grass.pygrass.modules.shortcuts.vector

```python
vector = MetaModule('v')
```

#### grass.pygrass.raster

**Modules:**

- [**abstract**](#grass.pygrass.raster.abstract) – Created on Fri Aug 17 16:05:25 2012
- [**buffer**](#grass.pygrass.raster.buffer) –
- [**category**](#grass.pygrass.raster.category) – Created on Thu Jun 28 17:44:14 2012
- [**history**](#grass.pygrass.raster.history) – Created on Thu Jun 28 17:44:45 2012
- [**raster_type**](#grass.pygrass.raster.raster_type) – Created on Wed Jun 13 19:42:22 2012
- [**rowio**](#grass.pygrass.raster.rowio) – Created on Mon Jun 18 13:22:38 2012
- [**segment**](#grass.pygrass.raster.segment) – Created on Mon Jun 11 18:02:27 2012

**Classes:**

- [**RasterRow**](#grass.pygrass.raster.RasterRow) – Raster_row_access": Inherits: "Raster_abstract_base" and implements
- [**RasterRowIO**](#grass.pygrass.raster.RasterRowIO) – Raster_row_cache_access": The same as "Raster_row_access" but uses
- [**RasterSegment**](#grass.pygrass.raster.RasterSegment) – Raster_segment_access": Inherits "Raster_abstract_base" and uses the

**Functions:**

- [**numpy2raster**](#grass.pygrass.raster.numpy2raster) – Save a numpy array to a raster map
- [**random_map**](#grass.pygrass.raster.random_map) –
- [**random_map_only_columns**](#grass.pygrass.raster.random_map_only_columns) –
- [**raster2numpy**](#grass.pygrass.raster.raster2numpy) – Return a numpy array from a raster map
- [**raster2numpy_img**](#grass.pygrass.raster.raster2numpy_img) – Convert a raster map layer into a string with

**Attributes:**

- [**WARN_OVERWRITE**](#grass.pygrass.raster.WARN_OVERWRITE) –
- [**cats**](#grass.pygrass.raster.cats) –
- [**mset**](#grass.pygrass.raster.mset) –
- [**test_raster_name**](#grass.pygrass.raster.test_raster_name) –

##### grass.pygrass.raster.RasterRow

Bases: <code>[RasterAbstractBase](#grass.pygrass.raster.abstract.RasterAbstractBase)</code>

Raster_row_access": Inherits: "Raster_abstract_base" and implements
the default row access of the Rast library.

```
* Implements row access using row id
* The get_row() method must accept a Row object as argument that will
  be used for value storage, so no new buffer will be allocated
* Implements sequential writing of rows
* Implements indexed value read only access using the [row][col]
  operator
* Implements the [row] read method that returns a new Row object
* Writing is limited using the put_row() method which accepts a
  Row as argument
* No mathematical operation like __add__ and stuff for the Raster
  object (only for rows), since r.mapcalc is more sophisticated and
  faster
* Raises IndexError if [row] is out of range

Examples:

>>> elev = RasterRow(test_raster_name)
>>> elev.exist()
True
>>> elev.is_open()
False
>>> elev.open()
>>> elev.is_open()
True
>>> elev.has_cats()
True
>>> elev.mode
'r'
>>> elev.mtype
'CELL'
>>> elev.num_cats()
16
>>> elev.info.range
(11, 44)
>>> elev.info.cols
4
>>> elev.info.rows
4

Editing the history

>>> elev.hist.read()
>>> elev.hist.title = "A test map"
>>> elev.hist.write()
>>> elev.hist.title
'A test map'
>>> elev.hist.keyword
'This is a test map'

>>> attrs = list(elev.hist)
>>> attrs[0]
('name', 'Raster_test_map')
>>> attrs[2]
('mtype', '')

Each Raster map have an attribute call ``cats`` that allow user
to interact with the raster categories.

>>> elev.cats  # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
[('A', 11, None),
 ('B', 12, None),
...
 ('P', 44, None)]

>>> elev.cats.labels()  # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
['A', 'B', 'C', 'D', 'E',
 'F', 'G', 'H', 'I', 'J',
 'K', 'L', 'M', 'n', 'O', 'P']
>>> elev.cats[0]
('A', 11, None)
>>> elev.cats[2]
('C', 13, None)
>>> elev.cats[0] = ("AA", 11)
>>> elev.cats[1] = ("BB", 12)
>>> elev.cats.write()
>>> elev.cats.read()
>>> elev.cats[0]
('AA', 11, None)
>>> elev.cats[1]
('BB', 12, None)

Open a raster map using the *with statement*:

>>> with RasterRow(test_raster_name) as elev:
...     for row in elev:
...         row
Buffer([11, 21, 31, 41], dtype=int32)
Buffer([12, 22, 32, 42], dtype=int32)
Buffer([13, 23, 33, 43], dtype=int32)
Buffer([14, 24, 34, 44], dtype=int32)

>>> elev.is_open()
False
```

**Functions:**

- [**close**](#grass.pygrass.raster.RasterRow.close) – Close the map
- [**copy_cats**](#grass.pygrass.raster.RasterRow.copy_cats) – Copy categories from another raster map object
- [**exist**](#grass.pygrass.raster.RasterRow.exist) – Return True if the map already exist, and
- [**fullname**](#grass.pygrass.raster.RasterRow.fullname) – Return the full name of a raster map: name@mapset
- [**get_cat**](#grass.pygrass.raster.RasterRow.get_cat) – Return a category given an index or a label
- [**get_cats**](#grass.pygrass.raster.RasterRow.get_cats) – Return a category object
- [**get_row**](#grass.pygrass.raster.RasterRow.get_row) – Private method that return the row using the read mode
- [**get_value**](#grass.pygrass.raster.RasterRow.get_value) – This method returns the pixel value of a given pair of coordinates:
- [**has_cats**](#grass.pygrass.raster.RasterRow.has_cats) – Return True if the raster map has categories
- [**is_open**](#grass.pygrass.raster.RasterRow.is_open) – Return True if the map is open False otherwise.
- [**name_mapset**](#grass.pygrass.raster.RasterRow.name_mapset) – Return the full name of the Raster.
- [**num_cats**](#grass.pygrass.raster.RasterRow.num_cats) – Return the number of categories
- [**open**](#grass.pygrass.raster.RasterRow.open) – Open the raster if exist or created a new one.
- [**put_row**](#grass.pygrass.raster.RasterRow.put_row) – Private method to write the row sequentially.
- [**read_cats**](#grass.pygrass.raster.RasterRow.read_cats) – Read category from the raster map file
- [**read_cats_rules**](#grass.pygrass.raster.RasterRow.read_cats_rules) – Read category from the raster map file
- [**remove**](#grass.pygrass.raster.RasterRow.remove) – Remove the map
- [**rename**](#grass.pygrass.raster.RasterRow.rename) – Rename the map
- [**set_cat**](#grass.pygrass.raster.RasterRow.set_cat) – Set or update a category
- [**set_cats**](#grass.pygrass.raster.RasterRow.set_cats) – The internal categories are copied from this object.
- [**set_region**](#grass.pygrass.raster.RasterRow.set_region) – Set the computational region that can be different from the
- [**set_region_from_rast**](#grass.pygrass.raster.RasterRow.set_region_from_rast) – Set the computational region from a map,
- [**sort_cats**](#grass.pygrass.raster.RasterRow.sort_cats) – Sort categories order by range
- [**write_cats**](#grass.pygrass.raster.RasterRow.write_cats) – Write category to the raster map file
- [**write_cats_rules**](#grass.pygrass.raster.RasterRow.write_cats_rules) – Write category to the raster map file

**Attributes:**

- [**cats**](#grass.pygrass.raster.RasterRow.cats) –
- [**cats_title**](#grass.pygrass.raster.RasterRow.cats_title) –
- [**hist**](#grass.pygrass.raster.RasterRow.hist) –
- [**info**](#grass.pygrass.raster.RasterRow.info) –
- [**mapset**](#grass.pygrass.raster.RasterRow.mapset) –
- [**mode**](#grass.pygrass.raster.RasterRow.mode) –
- [**mtype**](#grass.pygrass.raster.RasterRow.mtype) –
- [**name**](#grass.pygrass.raster.RasterRow.name) –
- [**overwrite**](#grass.pygrass.raster.RasterRow.overwrite) –

###### grass.pygrass.raster.RasterRow.cats

```python
cats = Category(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterRow.cats_title

```python
cats_title = property(fget=_get_cats_title, fset=_set_cats_title)
```

###### grass.pygrass.raster.RasterRow.close

```python
close()
```

Close the map

###### grass.pygrass.raster.RasterRow.copy_cats

```python
copy_cats(raster)
```

Copy categories from another raster map object

###### grass.pygrass.raster.RasterRow.exist

```python
exist()
```

Return True if the map already exist, and
set the mapset if were not set.

call the C function `G_find_raster`.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.exist()
> > > True

###### grass.pygrass.raster.RasterRow.fullname

```python
fullname()
```

Return the full name of a raster map: name@mapset

###### grass.pygrass.raster.RasterRow.get_cat

```python
get_cat(label)
```

Return a category given an index or a label

###### grass.pygrass.raster.RasterRow.get_cats

```python
get_cats()
```

Return a category object

###### grass.pygrass.raster.RasterRow.get_row

```python
get_row(row, row_buffer=None)
```

Private method that return the row using the read mode
call the `Rast_get_row` C function.

:param row: the number of row to obtain
:type row: int
:param row_buffer: Buffer object instance with the right dim and type
:type row_buffer: Buffer

> > > elev = RasterRow(test_raster_name)
> > > elev.open()
> > > elev[0]
> > > Buffer([11, 21, 31, 41], dtype=int32)
> > > elev.get_row(0)
> > > Buffer([11, 21, 31, 41], dtype=int32)

###### grass.pygrass.raster.RasterRow.get_value

```python
get_value(point, region=None)
```

This method returns the pixel value of a given pair of coordinates:

:param point: pair of coordinates in tuple object or class object with coords()
method

###### grass.pygrass.raster.RasterRow.has_cats

```python
has_cats()
```

Return True if the raster map has categories

###### grass.pygrass.raster.RasterRow.hist

```python
hist = History(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterRow.info

```python
info = Info(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterRow.is_open

```python
is_open()
```

Return True if the map is open False otherwise.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.is_open()
> > > False

###### grass.pygrass.raster.RasterRow.mapset

```python
mapset = mapset
```

###### grass.pygrass.raster.RasterRow.mode

```python
mode = property(fget=_get_mode, fset=_set_mode)
```

###### grass.pygrass.raster.RasterRow.mtype

```python
mtype = property(fget=_get_mtype, fset=_set_mtype)
```

###### grass.pygrass.raster.RasterRow.name

```python
name = property(fget=_get_name, fset=_set_name)
```

###### grass.pygrass.raster.RasterRow.name_mapset

```python
name_mapset(name=None, mapset=None)
```

Return the full name of the Raster.

> > > ele = RasterAbstractBase(test_raster_name)
> > > name = ele.name_mapset().split("@")
> > > name
> > > ['abstract_test_map']

###### grass.pygrass.raster.RasterRow.num_cats

```python
num_cats()
```

Return the number of categories

###### grass.pygrass.raster.RasterRow.open

```python
open(mode=None, mtype=None, overwrite=None)
```

Open the raster if exist or created a new one.

:param str mode: Specify if the map will be open with read or write mode
('r', 'w')
:param str type: If a new map is open, specify the type of the map(`CELL`,
`FCELL`, `DCELL`)
:param bool overwrite: Use this flag to set the overwrite mode of existing
raster maps

if the map already exist, automatically check the type and set:

```
* self.mtype
```

Set all the privite, attributes:

```
* self._fd;
* self._gtype
* self._rows and self._cols
```

###### grass.pygrass.raster.RasterRow.overwrite

```python
overwrite = property(fget=_get_overwrite, fset=_set_overwrite)
```

###### grass.pygrass.raster.RasterRow.put_row

```python
put_row(row)
```

Private method to write the row sequentially.

:param row: a Row object to insert into raster
:type row: Buffer object

###### grass.pygrass.raster.RasterRow.read_cats

```python
read_cats()
```

Read category from the raster map file

###### grass.pygrass.raster.RasterRow.read_cats_rules

```python
read_cats_rules(filename, sep=':')
```

Read category from the raster map file

###### grass.pygrass.raster.RasterRow.remove

```python
remove()
```

Remove the map

###### grass.pygrass.raster.RasterRow.rename

```python
rename(newname)
```

Rename the map

###### grass.pygrass.raster.RasterRow.set_cat

```python
set_cat(label, min_cat, max_cat=None, index=None)
```

Set or update a category

###### grass.pygrass.raster.RasterRow.set_cats

```python
set_cats(category)
```

The internal categories are copied from this object.

###### grass.pygrass.raster.RasterRow.set_region

```python
set_region(region)
```

Set the computational region that can be different from the
current region settings. This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

###### grass.pygrass.raster.RasterRow.set_region_from_rast

```python
set_region_from_rast(rastname='', mapset='')
```

Set the computational region from a map,
if rastername and mapset is not specify, use itself.
This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

call C function `Rast_get_cellhd`, `Rast_set_window`

###### grass.pygrass.raster.RasterRow.sort_cats

```python
sort_cats()
```

Sort categories order by range

###### grass.pygrass.raster.RasterRow.write_cats

```python
write_cats()
```

Write category to the raster map file

###### grass.pygrass.raster.RasterRow.write_cats_rules

```python
write_cats_rules(filename, sep=':')
```

Write category to the raster map file

##### grass.pygrass.raster.RasterRowIO

```python
RasterRowIO(name, *args, **kargs)
```

Bases: <code>[RasterRow](#grass.pygrass.raster.RasterRow)</code>

Raster_row_cache_access": The same as "Raster_row_access" but uses
the ROWIO library for cached row access

**Functions:**

- [**close**](#grass.pygrass.raster.RasterRowIO.close) – Function to close the raster
- [**copy_cats**](#grass.pygrass.raster.RasterRowIO.copy_cats) – Copy categories from another raster map object
- [**exist**](#grass.pygrass.raster.RasterRowIO.exist) – Return True if the map already exist, and
- [**fullname**](#grass.pygrass.raster.RasterRowIO.fullname) – Return the full name of a raster map: name@mapset
- [**get_cat**](#grass.pygrass.raster.RasterRowIO.get_cat) – Return a category given an index or a label
- [**get_cats**](#grass.pygrass.raster.RasterRowIO.get_cats) – Return a category object
- [**get_row**](#grass.pygrass.raster.RasterRowIO.get_row) – This method returns the row using:
- [**get_value**](#grass.pygrass.raster.RasterRowIO.get_value) – This method returns the pixel value of a given pair of coordinates:
- [**has_cats**](#grass.pygrass.raster.RasterRowIO.has_cats) – Return True if the raster map has categories
- [**is_open**](#grass.pygrass.raster.RasterRowIO.is_open) – Return True if the map is open False otherwise.
- [**name_mapset**](#grass.pygrass.raster.RasterRowIO.name_mapset) – Return the full name of the Raster.
- [**num_cats**](#grass.pygrass.raster.RasterRowIO.num_cats) – Return the number of categories
- [**open**](#grass.pygrass.raster.RasterRowIO.open) – Open the raster if exist or created a new one.
- [**put_row**](#grass.pygrass.raster.RasterRowIO.put_row) – Private method to write the row sequentially.
- [**read_cats**](#grass.pygrass.raster.RasterRowIO.read_cats) – Read category from the raster map file
- [**read_cats_rules**](#grass.pygrass.raster.RasterRowIO.read_cats_rules) – Read category from the raster map file
- [**remove**](#grass.pygrass.raster.RasterRowIO.remove) – Remove the map
- [**rename**](#grass.pygrass.raster.RasterRowIO.rename) – Rename the map
- [**set_cat**](#grass.pygrass.raster.RasterRowIO.set_cat) – Set or update a category
- [**set_cats**](#grass.pygrass.raster.RasterRowIO.set_cats) – The internal categories are copied from this object.
- [**set_region**](#grass.pygrass.raster.RasterRowIO.set_region) – Set the computational region that can be different from the
- [**set_region_from_rast**](#grass.pygrass.raster.RasterRowIO.set_region_from_rast) – Set the computational region from a map,
- [**sort_cats**](#grass.pygrass.raster.RasterRowIO.sort_cats) – Sort categories order by range
- [**write_cats**](#grass.pygrass.raster.RasterRowIO.write_cats) – Write category to the raster map file
- [**write_cats_rules**](#grass.pygrass.raster.RasterRowIO.write_cats_rules) – Write category to the raster map file

**Attributes:**

- [**cats**](#grass.pygrass.raster.RasterRowIO.cats) –
- [**cats_title**](#grass.pygrass.raster.RasterRowIO.cats_title) –
- [**hist**](#grass.pygrass.raster.RasterRowIO.hist) –
- [**info**](#grass.pygrass.raster.RasterRowIO.info) –
- [**mapset**](#grass.pygrass.raster.RasterRowIO.mapset) –
- [**mode**](#grass.pygrass.raster.RasterRowIO.mode) –
- [**mtype**](#grass.pygrass.raster.RasterRowIO.mtype) –
- [**name**](#grass.pygrass.raster.RasterRowIO.name) –
- [**overwrite**](#grass.pygrass.raster.RasterRowIO.overwrite) –
- [**rowio**](#grass.pygrass.raster.RasterRowIO.rowio) –

###### grass.pygrass.raster.RasterRowIO.cats

```python
cats = Category(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterRowIO.cats_title

```python
cats_title = property(fget=_get_cats_title, fset=_set_cats_title)
```

###### grass.pygrass.raster.RasterRowIO.close

```python
close()
```

Function to close the raster

###### grass.pygrass.raster.RasterRowIO.copy_cats

```python
copy_cats(raster)
```

Copy categories from another raster map object

###### grass.pygrass.raster.RasterRowIO.exist

```python
exist()
```

Return True if the map already exist, and
set the mapset if were not set.

call the C function `G_find_raster`.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.exist()
> > > True

###### grass.pygrass.raster.RasterRowIO.fullname

```python
fullname()
```

Return the full name of a raster map: name@mapset

###### grass.pygrass.raster.RasterRowIO.get_cat

```python
get_cat(label)
```

Return a category given an index or a label

###### grass.pygrass.raster.RasterRowIO.get_cats

```python
get_cats()
```

Return a category object

###### grass.pygrass.raster.RasterRowIO.get_row

```python
get_row(row, row_buffer=None)
```

This method returns the row using:

```
* the read mode and
* `rowcache` method
```

:param row: the number of row to obtain
:type row: int
:param row_buffer: Specify the Buffer object that will be instantiate
:type row_buffer: Buffer object

```
>>> elev = RasterRowIO(test_raster_name)
>>> elev.open("r")
>>> for row in elev:
...     row
Buffer([11, 21, 31, 41], dtype=int32)
Buffer([12, 22, 32, 42], dtype=int32)
Buffer([13, 23, 33, 43], dtype=int32)
Buffer([14, 24, 34, 44], dtype=int32)

>>> elev.close()
```

###### grass.pygrass.raster.RasterRowIO.get_value

```python
get_value(point, region=None)
```

This method returns the pixel value of a given pair of coordinates:

:param point: pair of coordinates in tuple object or class object with coords()
method

###### grass.pygrass.raster.RasterRowIO.has_cats

```python
has_cats()
```

Return True if the raster map has categories

###### grass.pygrass.raster.RasterRowIO.hist

```python
hist = History(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterRowIO.info

```python
info = Info(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterRowIO.is_open

```python
is_open()
```

Return True if the map is open False otherwise.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.is_open()
> > > False

###### grass.pygrass.raster.RasterRowIO.mapset

```python
mapset = mapset
```

###### grass.pygrass.raster.RasterRowIO.mode

```python
mode = property(fget=_get_mode, fset=_set_mode)
```

###### grass.pygrass.raster.RasterRowIO.mtype

```python
mtype = property(fget=_get_mtype, fset=_set_mtype)
```

###### grass.pygrass.raster.RasterRowIO.name

```python
name = property(fget=_get_name, fset=_set_name)
```

###### grass.pygrass.raster.RasterRowIO.name_mapset

```python
name_mapset(name=None, mapset=None)
```

Return the full name of the Raster.

> > > ele = RasterAbstractBase(test_raster_name)
> > > name = ele.name_mapset().split("@")
> > > name
> > > ['abstract_test_map']

###### grass.pygrass.raster.RasterRowIO.num_cats

```python
num_cats()
```

Return the number of categories

###### grass.pygrass.raster.RasterRowIO.open

```python
open(mode=None, mtype=None, overwrite=False)
```

Open the raster if exist or created a new one.

:param mode: specify if the map will be open with read or write mode
('r', 'w')
:type mode: str
:param type: if a new map is open, specify the type of the map(`CELL`,
`FCELL`, `DCELL`)
:type type: str
:param overwrite: use this flag to set the overwrite mode of existing
raster maps
:type overwrite: bool

###### grass.pygrass.raster.RasterRowIO.overwrite

```python
overwrite = property(fget=_get_overwrite, fset=_set_overwrite)
```

###### grass.pygrass.raster.RasterRowIO.put_row

```python
put_row(row)
```

Private method to write the row sequentially.

:param row: a Row object to insert into raster
:type row: Buffer object

###### grass.pygrass.raster.RasterRowIO.read_cats

```python
read_cats()
```

Read category from the raster map file

###### grass.pygrass.raster.RasterRowIO.read_cats_rules

```python
read_cats_rules(filename, sep=':')
```

Read category from the raster map file

###### grass.pygrass.raster.RasterRowIO.remove

```python
remove()
```

Remove the map

###### grass.pygrass.raster.RasterRowIO.rename

```python
rename(newname)
```

Rename the map

###### grass.pygrass.raster.RasterRowIO.rowio

```python
rowio = RowIO()
```

###### grass.pygrass.raster.RasterRowIO.set_cat

```python
set_cat(label, min_cat, max_cat=None, index=None)
```

Set or update a category

###### grass.pygrass.raster.RasterRowIO.set_cats

```python
set_cats(category)
```

The internal categories are copied from this object.

###### grass.pygrass.raster.RasterRowIO.set_region

```python
set_region(region)
```

Set the computational region that can be different from the
current region settings. This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

###### grass.pygrass.raster.RasterRowIO.set_region_from_rast

```python
set_region_from_rast(rastname='', mapset='')
```

Set the computational region from a map,
if rastername and mapset is not specify, use itself.
This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

call C function `Rast_get_cellhd`, `Rast_set_window`

###### grass.pygrass.raster.RasterRowIO.sort_cats

```python
sort_cats()
```

Sort categories order by range

###### grass.pygrass.raster.RasterRowIO.write_cats

```python
write_cats()
```

Write category to the raster map file

###### grass.pygrass.raster.RasterRowIO.write_cats_rules

```python
write_cats_rules(filename, sep=':')
```

Write category to the raster map file

##### grass.pygrass.raster.RasterSegment

```python
RasterSegment(name, srows=64, scols=64, maxmem=100, *args, **kargs)
```

Bases: <code>[RasterAbstractBase](#grass.pygrass.raster.abstract.RasterAbstractBase)</code>

Raster_segment_access": Inherits "Raster_abstract_base" and uses the
segment library for cached randomly reading and writing access.

```
* Implements the [row][col] operator for read and write access using
  Segment_get() and Segment_put() functions internally
* Implements row read and write access with the [row] operator using
  Segment_get_row() Segment_put_row() internally
* Implements the get_row() and put_row() method  using
  Segment_get_row() Segment_put_row() internally
* Implements the flush_segment() method
* Implements the copying of raster maps to segments and vice verse
* Overwrites the open and close methods
* No mathematical operation like __add__ and stuff for the Raster
  object (only for rows), since r.mapcalc is more sophisticated and
  faster
```

**Functions:**

- [**close**](#grass.pygrass.raster.RasterSegment.close) – Close the map, copy the segment files to the map.
- [**copy_cats**](#grass.pygrass.raster.RasterSegment.copy_cats) – Copy categories from another raster map object
- [**exist**](#grass.pygrass.raster.RasterSegment.exist) – Return True if the map already exist, and
- [**fullname**](#grass.pygrass.raster.RasterSegment.fullname) – Return the full name of a raster map: name@mapset
- [**get**](#grass.pygrass.raster.RasterSegment.get) – Return the map value using the `segment.get` method
- [**get_cat**](#grass.pygrass.raster.RasterSegment.get_cat) – Return a category given an index or a label
- [**get_cats**](#grass.pygrass.raster.RasterSegment.get_cats) – Return a category object
- [**get_row**](#grass.pygrass.raster.RasterSegment.get_row) – Return the row using the `segment.get_row` method
- [**get_value**](#grass.pygrass.raster.RasterSegment.get_value) – This method returns the pixel value of a given pair of coordinates:
- [**has_cats**](#grass.pygrass.raster.RasterSegment.has_cats) – Return True if the raster map has categories
- [**is_open**](#grass.pygrass.raster.RasterSegment.is_open) – Return True if the map is open False otherwise.
- [**map2segment**](#grass.pygrass.raster.RasterSegment.map2segment) – Transform an existing map to segment file.
- [**name_mapset**](#grass.pygrass.raster.RasterSegment.name_mapset) – Return the full name of the Raster.
- [**num_cats**](#grass.pygrass.raster.RasterSegment.num_cats) – Return the number of categories
- [**open**](#grass.pygrass.raster.RasterSegment.open) – Open the map, if the map already exist: determine the map type
- [**put**](#grass.pygrass.raster.RasterSegment.put) – Write the value to the map using the `segment.put` method
- [**put_row**](#grass.pygrass.raster.RasterSegment.put_row) – Write the row using the `segment.put_row` method
- [**read_cats**](#grass.pygrass.raster.RasterSegment.read_cats) – Read category from the raster map file
- [**read_cats_rules**](#grass.pygrass.raster.RasterSegment.read_cats_rules) – Read category from the raster map file
- [**remove**](#grass.pygrass.raster.RasterSegment.remove) – Remove the map
- [**rename**](#grass.pygrass.raster.RasterSegment.rename) – Rename the map
- [**segment2map**](#grass.pygrass.raster.RasterSegment.segment2map) – Transform the segment file to a map.
- [**set_cat**](#grass.pygrass.raster.RasterSegment.set_cat) – Set or update a category
- [**set_cats**](#grass.pygrass.raster.RasterSegment.set_cats) – The internal categories are copied from this object.
- [**set_region**](#grass.pygrass.raster.RasterSegment.set_region) – Set the computational region that can be different from the
- [**set_region_from_rast**](#grass.pygrass.raster.RasterSegment.set_region_from_rast) – Set the computational region from a map,
- [**sort_cats**](#grass.pygrass.raster.RasterSegment.sort_cats) – Sort categories order by range
- [**write_cats**](#grass.pygrass.raster.RasterSegment.write_cats) – Write category to the raster map file
- [**write_cats_rules**](#grass.pygrass.raster.RasterSegment.write_cats_rules) – Write category to the raster map file

**Attributes:**

- [**cats**](#grass.pygrass.raster.RasterSegment.cats) –
- [**cats_title**](#grass.pygrass.raster.RasterSegment.cats_title) –
- [**hist**](#grass.pygrass.raster.RasterSegment.hist) –
- [**info**](#grass.pygrass.raster.RasterSegment.info) –
- [**mapset**](#grass.pygrass.raster.RasterSegment.mapset) –
- [**mode**](#grass.pygrass.raster.RasterSegment.mode) –
- [**mtype**](#grass.pygrass.raster.RasterSegment.mtype) –
- [**name**](#grass.pygrass.raster.RasterSegment.name) –
- [**overwrite**](#grass.pygrass.raster.RasterSegment.overwrite) –
- [**segment**](#grass.pygrass.raster.RasterSegment.segment) –

###### grass.pygrass.raster.RasterSegment.cats

```python
cats = Category(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterSegment.cats_title

```python
cats_title = property(fget=_get_cats_title, fset=_set_cats_title)
```

###### grass.pygrass.raster.RasterSegment.close

```python
close(rm_temp_files=True)
```

Close the map, copy the segment files to the map.

:param rm_temp_files: if True all the segments file will be removed
:type rm_temp_files: bool

###### grass.pygrass.raster.RasterSegment.copy_cats

```python
copy_cats(raster)
```

Copy categories from another raster map object

###### grass.pygrass.raster.RasterSegment.exist

```python
exist()
```

Return True if the map already exist, and
set the mapset if were not set.

call the C function `G_find_raster`.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.exist()
> > > True

###### grass.pygrass.raster.RasterSegment.fullname

```python
fullname()
```

Return the full name of a raster map: name@mapset

###### grass.pygrass.raster.RasterSegment.get

```python
get(row, col)
```

Return the map value using the `segment.get` method

:param row: Specify the row number
:type row: int
:param col: Specify the column number
:type col: int

```
>>> elev = RasterSegment(test_raster_name)
>>> elev.open("r")
>>> for i in range(4):
...     elev.get(i, i)
11
22
33
44
>>> elev.close()


>>> with RasterSegment(test_raster_name) as elev:
...     elev.get(0, 0)
...     elev.get(1, 1)
...     elev.get(2, 2)
...     elev.get(3, 3)
11
22
33
44
```

###### grass.pygrass.raster.RasterSegment.get_cat

```python
get_cat(label)
```

Return a category given an index or a label

###### grass.pygrass.raster.RasterSegment.get_cats

```python
get_cats()
```

Return a category object

###### grass.pygrass.raster.RasterSegment.get_row

```python
get_row(row, row_buffer=None)
```

Return the row using the `segment.get_row` method

:param row: specify the row number
:type row: int
:param row_buffer: specify the Buffer object that will be instantiate
:type row_buffer: Buffer object

```
>>> elev = RasterRowIO(test_raster_name)
>>> elev.open("r")
>>> for row in elev:
...     row
Buffer([11, 21, 31, 41], dtype=int32)
Buffer([12, 22, 32, 42], dtype=int32)
Buffer([13, 23, 33, 43], dtype=int32)
Buffer([14, 24, 34, 44], dtype=int32)

>>> elev.close()


>>> with RasterSegment(test_raster_name) as elev:
...     for row in elev:
...         row
Buffer([11, 21, 31, 41], dtype=int32)
Buffer([12, 22, 32, 42], dtype=int32)
Buffer([13, 23, 33, 43], dtype=int32)
Buffer([14, 24, 34, 44], dtype=int32)
```

###### grass.pygrass.raster.RasterSegment.get_value

```python
get_value(point, region=None)
```

This method returns the pixel value of a given pair of coordinates:

:param point: pair of coordinates in tuple object or class object with coords()
method

###### grass.pygrass.raster.RasterSegment.has_cats

```python
has_cats()
```

Return True if the raster map has categories

###### grass.pygrass.raster.RasterSegment.hist

```python
hist = History(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterSegment.info

```python
info = Info(self.name, self.mapset)
```

###### grass.pygrass.raster.RasterSegment.is_open

```python
is_open()
```

Return True if the map is open False otherwise.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.is_open()
> > > False

###### grass.pygrass.raster.RasterSegment.map2segment

```python
map2segment()
```

Transform an existing map to segment file.

###### grass.pygrass.raster.RasterSegment.mapset

```python
mapset = mapset
```

###### grass.pygrass.raster.RasterSegment.mode

```python
mode = property(fget=_get_mode, fset=_set_mode, doc='Set or obtain the opening mode of raster')
```

###### grass.pygrass.raster.RasterSegment.mtype

```python
mtype = property(fget=_get_mtype, fset=_set_mtype)
```

###### grass.pygrass.raster.RasterSegment.name

```python
name = property(fget=_get_name, fset=_set_name)
```

###### grass.pygrass.raster.RasterSegment.name_mapset

```python
name_mapset(name=None, mapset=None)
```

Return the full name of the Raster.

> > > ele = RasterAbstractBase(test_raster_name)
> > > name = ele.name_mapset().split("@")
> > > name
> > > ['abstract_test_map']

###### grass.pygrass.raster.RasterSegment.num_cats

```python
num_cats()
```

Return the number of categories

###### grass.pygrass.raster.RasterSegment.open

```python
open(mode=None, mtype=None, overwrite=None)
```

Open the map, if the map already exist: determine the map type
and copy the map to the segment files;
else, open a new segment map.

:param mode: specify if the map will be open with read, write or
read/write mode ('r', 'w', 'rw')
:type mode: str
:param mtype: specify the map type, valid only for new maps: CELL,
FCELL, DCELL
:type mtype: str
:param overwrite: use this flag to set the overwrite mode of existing
raster maps
:type overwrite: bool

###### grass.pygrass.raster.RasterSegment.overwrite

```python
overwrite = property(fget=_get_overwrite, fset=_set_overwrite)
```

###### grass.pygrass.raster.RasterSegment.put

```python
put(row, col, val)
```

Write the value to the map using the `segment.put` method

:param row: Specify the row number
:type row: int
:param col: Specify the column number
:type col: int
:param val: Specify the value that will be write to the map cell
:type val: value

```
>>> map_a = RasterSegment(test_raster_name)
>>> map_b = RasterSegment(test_raster_name + "_segment")
>>> map_a.open("r")
>>> map_b.open("w", mtype="FCELL", overwrite=True)
>>> for row in range(map_a.info.rows):
...     for col in range(map_a.info.cols):
...         value = map_a.get(row, col)
...         map_b.put(row, col, value + 100)
>>> map_a.close()
>>> map_b.close()

>>> map_b = RasterSegment(test_raster_name + "_segment")
>>> map_b.open("r")
>>> for row in map_b:
...     row
Buffer([111., 121., 131., 141.], dtype=float32)
Buffer([112., 122., 132., 142.], dtype=float32)
Buffer([113., 123., 133., 143.], dtype=float32)
Buffer([114., 124., 134., 144.], dtype=float32)
>>> map_b.close()
```

###### grass.pygrass.raster.RasterSegment.put_row

```python
put_row(row, row_buffer)
```

Write the row using the `segment.put_row` method

:param row: a Row object to insert into raster
:type row: Buffer object

Input and output must have the same type in case of row copy

> > > map_a = RasterSegment(test_raster_name)
> > > map_b = RasterSegment(test_raster_name + "\_segment")
> > > map_a.open("r")
> > > map_b.open("w", mtype="CELL", overwrite=True)
> > > for row in range(map_a.info.rows):
> > > ... map_b[row] = map_a[row] + 1000
> > > map_a.close()
> > > map_b.close()

> > > map_b = RasterSegment(test_raster_name + "\_segment")
> > > map_b.open("r")
> > > for row in map_b:
> > > ... row
> > > Buffer([1011, 1021, 1031, 1041], dtype=int32)
> > > Buffer([1012, 1022, 1032, 1042], dtype=int32)
> > > Buffer([1013, 1023, 1033, 1043], dtype=int32)
> > > Buffer([1014, 1024, 1034, 1044], dtype=int32)
> > > map_b.close()

###### grass.pygrass.raster.RasterSegment.read_cats

```python
read_cats()
```

Read category from the raster map file

###### grass.pygrass.raster.RasterSegment.read_cats_rules

```python
read_cats_rules(filename, sep=':')
```

Read category from the raster map file

###### grass.pygrass.raster.RasterSegment.remove

```python
remove()
```

Remove the map

###### grass.pygrass.raster.RasterSegment.rename

```python
rename(newname)
```

Rename the map

###### grass.pygrass.raster.RasterSegment.segment

```python
segment = Segment(srows, scols, maxmem)
```

###### grass.pygrass.raster.RasterSegment.segment2map

```python
segment2map()
```

Transform the segment file to a map.

###### grass.pygrass.raster.RasterSegment.set_cat

```python
set_cat(label, min_cat, max_cat=None, index=None)
```

Set or update a category

###### grass.pygrass.raster.RasterSegment.set_cats

```python
set_cats(category)
```

The internal categories are copied from this object.

###### grass.pygrass.raster.RasterSegment.set_region

```python
set_region(region)
```

Set the computational region that can be different from the
current region settings. This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

###### grass.pygrass.raster.RasterSegment.set_region_from_rast

```python
set_region_from_rast(rastname='', mapset='')
```

Set the computational region from a map,
if rastername and mapset is not specify, use itself.
This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

call C function `Rast_get_cellhd`, `Rast_set_window`

###### grass.pygrass.raster.RasterSegment.sort_cats

```python
sort_cats()
```

Sort categories order by range

###### grass.pygrass.raster.RasterSegment.write_cats

```python
write_cats()
```

Write category to the raster map file

###### grass.pygrass.raster.RasterSegment.write_cats_rules

```python
write_cats_rules(filename, sep=':')
```

Write category to the raster map file

##### grass.pygrass.raster.WARN_OVERWRITE

```python
WARN_OVERWRITE = 'Raster map <{0}> already exists and will be overwritten'
```

##### grass.pygrass.raster.abstract

Created on Fri Aug 17 16:05:25 2012

@author: pietro

**Classes:**

- [**Info**](#grass.pygrass.raster.abstract.Info) –
- [**RasterAbstractBase**](#grass.pygrass.raster.abstract.RasterAbstractBase) – Raster_abstract_base: The base class from which all sub-classes

**Attributes:**

- [**INDXOUTRANGE**](#grass.pygrass.raster.abstract.INDXOUTRANGE) –
- [**INFO**](#grass.pygrass.raster.abstract.INFO) –
- [**mset**](#grass.pygrass.raster.abstract.mset) –
- [**test_raster_name**](#grass.pygrass.raster.abstract.test_raster_name) –

###### grass.pygrass.raster.abstract.INDXOUTRANGE

```python
INDXOUTRANGE = 'The index (%d) is out of range, have you open the map?.'
```

###### grass.pygrass.raster.abstract.INFO

```python
INFO = '{name}@{mapset}\nrows: {rows}\ncols: {cols}\nnorth: {north} south: {south} nsres:{nsres}\neast:  {east} west: {west} ewres:{ewres}\nrange: {min}, {max}\nproj: {proj}\n'
```

###### grass.pygrass.raster.abstract.Info

```python
Info(name, mapset='')
```

**Functions:**

- [**items**](#grass.pygrass.raster.abstract.Info.items) –
- [**keys**](#grass.pygrass.raster.abstract.Info.keys) –
- [**read**](#grass.pygrass.raster.abstract.Info.read) –

**Attributes:**

- [**bottom**](#grass.pygrass.raster.abstract.Info.bottom) –
- [**c_range**](#grass.pygrass.raster.abstract.Info.c_range) –
- [**c_region**](#grass.pygrass.raster.abstract.Info.c_region) –
- [**cols**](#grass.pygrass.raster.abstract.Info.cols) –
- [**east**](#grass.pygrass.raster.abstract.Info.east) –
- [**ewres**](#grass.pygrass.raster.abstract.Info.ewres) –
- [**mapset**](#grass.pygrass.raster.abstract.Info.mapset) –
- [**max**](#grass.pygrass.raster.abstract.Info.max) –
- [**min**](#grass.pygrass.raster.abstract.Info.min) –
- [**mtype**](#grass.pygrass.raster.abstract.Info.mtype) –
- [**name**](#grass.pygrass.raster.abstract.Info.name) –
- [**north**](#grass.pygrass.raster.abstract.Info.north) –
- [**nsres**](#grass.pygrass.raster.abstract.Info.nsres) –
- [**proj**](#grass.pygrass.raster.abstract.Info.proj) –
- [**range**](#grass.pygrass.raster.abstract.Info.range) –
- [**rows**](#grass.pygrass.raster.abstract.Info.rows) –
- [**semantic_label**](#grass.pygrass.raster.abstract.Info.semantic_label) –
- [**south**](#grass.pygrass.raster.abstract.Info.south) –
- [**tbres**](#grass.pygrass.raster.abstract.Info.tbres) –
- [**top**](#grass.pygrass.raster.abstract.Info.top) –
- [**units**](#grass.pygrass.raster.abstract.Info.units) –
- [**vdatum**](#grass.pygrass.raster.abstract.Info.vdatum) –
- [**west**](#grass.pygrass.raster.abstract.Info.west) –
- [**zone**](#grass.pygrass.raster.abstract.Info.zone) –

Read the information for a raster map. ::

> > > info = Info(test_raster_name)
> > > info.read()
> > > info # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
> > > abstract_test_map@
> > > rows: 4
> > > cols: 4
> > > north: 40.0 south: 0.0 nsres:10.0
> > > east: 40.0 west: 0.0 ewres:10.0
> > > range: 11, 44
> > > ...
> > > <BLANKLINE>

####### grass.pygrass.raster.abstract.Info.bottom

```python
bottom
```

####### grass.pygrass.raster.abstract.Info.c_range

```python
c_range = None
```

####### grass.pygrass.raster.abstract.Info.c_region

```python
c_region = ctypes.pointer(libraster.struct_Cell_head())
```

####### grass.pygrass.raster.abstract.Info.cols

```python
cols
```

####### grass.pygrass.raster.abstract.Info.east

```python
east
```

####### grass.pygrass.raster.abstract.Info.ewres

```python
ewres
```

####### grass.pygrass.raster.abstract.Info.items

```python
items()
```

####### grass.pygrass.raster.abstract.Info.keys

```python
keys()
```

####### grass.pygrass.raster.abstract.Info.mapset

```python
mapset = mapset
```

####### grass.pygrass.raster.abstract.Info.max

```python
max
```

####### grass.pygrass.raster.abstract.Info.min

```python
min
```

####### grass.pygrass.raster.abstract.Info.mtype

```python
mtype
```

####### grass.pygrass.raster.abstract.Info.name

```python
name = name
```

####### grass.pygrass.raster.abstract.Info.north

```python
north
```

####### grass.pygrass.raster.abstract.Info.nsres

```python
nsres
```

####### grass.pygrass.raster.abstract.Info.proj

```python
proj
```

####### grass.pygrass.raster.abstract.Info.range

```python
range
```

####### grass.pygrass.raster.abstract.Info.read

```python
read()
```

####### grass.pygrass.raster.abstract.Info.rows

```python
rows
```

####### grass.pygrass.raster.abstract.Info.semantic_label

```python
semantic_label = property(_get_semantic_label, _set_semantic_label)
```

####### grass.pygrass.raster.abstract.Info.south

```python
south
```

####### grass.pygrass.raster.abstract.Info.tbres

```python
tbres
```

####### grass.pygrass.raster.abstract.Info.top

```python
top
```

####### grass.pygrass.raster.abstract.Info.units

```python
units = property(_get_units, _set_units)
```

####### grass.pygrass.raster.abstract.Info.vdatum

```python
vdatum = property(_get_vdatum, _set_vdatum)
```

####### grass.pygrass.raster.abstract.Info.west

```python
west
```

####### grass.pygrass.raster.abstract.Info.zone

```python
zone
```

###### grass.pygrass.raster.abstract.RasterAbstractBase

```python
RasterAbstractBase(name, mapset='', *aopen, **kwopen)
```

Raster_abstract_base: The base class from which all sub-classes
inherit. It does not implement any row or map access methods:

- Implements raster metadata information access (Type, ...)
- Implements an open method that will be overwritten by the sub-classes
- Implements the close method that might be overwritten by sub-classes
  (should work for simple row access)
- Implements get and set region methods
- Implements color, history and category handling
- Renaming, deletion, ...

**Functions:**

- [**close**](#grass.pygrass.raster.abstract.RasterAbstractBase.close) – Close the map
- [**copy_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.copy_cats) – Copy categories from another raster map object
- [**exist**](#grass.pygrass.raster.abstract.RasterAbstractBase.exist) – Return True if the map already exist, and
- [**fullname**](#grass.pygrass.raster.abstract.RasterAbstractBase.fullname) – Return the full name of a raster map: name@mapset
- [**get_cat**](#grass.pygrass.raster.abstract.RasterAbstractBase.get_cat) – Return a category given an index or a label
- [**get_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.get_cats) – Return a category object
- [**get_value**](#grass.pygrass.raster.abstract.RasterAbstractBase.get_value) – This method returns the pixel value of a given pair of coordinates:
- [**has_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.has_cats) – Return True if the raster map has categories
- [**is_open**](#grass.pygrass.raster.abstract.RasterAbstractBase.is_open) – Return True if the map is open False otherwise.
- [**name_mapset**](#grass.pygrass.raster.abstract.RasterAbstractBase.name_mapset) – Return the full name of the Raster.
- [**num_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.num_cats) – Return the number of categories
- [**read_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.read_cats) – Read category from the raster map file
- [**read_cats_rules**](#grass.pygrass.raster.abstract.RasterAbstractBase.read_cats_rules) – Read category from the raster map file
- [**remove**](#grass.pygrass.raster.abstract.RasterAbstractBase.remove) – Remove the map
- [**rename**](#grass.pygrass.raster.abstract.RasterAbstractBase.rename) – Rename the map
- [**set_cat**](#grass.pygrass.raster.abstract.RasterAbstractBase.set_cat) – Set or update a category
- [**set_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.set_cats) – The internal categories are copied from this object.
- [**set_region**](#grass.pygrass.raster.abstract.RasterAbstractBase.set_region) – Set the computational region that can be different from the
- [**set_region_from_rast**](#grass.pygrass.raster.abstract.RasterAbstractBase.set_region_from_rast) – Set the computational region from a map,
- [**sort_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.sort_cats) – Sort categories order by range
- [**write_cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.write_cats) – Write category to the raster map file
- [**write_cats_rules**](#grass.pygrass.raster.abstract.RasterAbstractBase.write_cats_rules) – Write category to the raster map file

**Attributes:**

- [**cats**](#grass.pygrass.raster.abstract.RasterAbstractBase.cats) –
- [**cats_title**](#grass.pygrass.raster.abstract.RasterAbstractBase.cats_title) –
- [**hist**](#grass.pygrass.raster.abstract.RasterAbstractBase.hist) –
- [**info**](#grass.pygrass.raster.abstract.RasterAbstractBase.info) –
- [**mapset**](#grass.pygrass.raster.abstract.RasterAbstractBase.mapset) –
- [**mode**](#grass.pygrass.raster.abstract.RasterAbstractBase.mode) –
- [**mtype**](#grass.pygrass.raster.abstract.RasterAbstractBase.mtype) –
- [**name**](#grass.pygrass.raster.abstract.RasterAbstractBase.name) –
- [**overwrite**](#grass.pygrass.raster.abstract.RasterAbstractBase.overwrite) –

The constructor need at least the name of the map
*optional* field is the `mapset`.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.name
> > > 'abstract_test_map'
> > > ele.exist()
> > > True

..

####### grass.pygrass.raster.abstract.RasterAbstractBase.cats

```python
cats = Category(self.name, self.mapset)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.cats_title

```python
cats_title = property(fget=_get_cats_title, fset=_set_cats_title)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.close

```python
close()
```

Close the map

####### grass.pygrass.raster.abstract.RasterAbstractBase.copy_cats

```python
copy_cats(raster)
```

Copy categories from another raster map object

####### grass.pygrass.raster.abstract.RasterAbstractBase.exist

```python
exist()
```

Return True if the map already exist, and
set the mapset if were not set.

call the C function `G_find_raster`.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.exist()
> > > True

####### grass.pygrass.raster.abstract.RasterAbstractBase.fullname

```python
fullname()
```

Return the full name of a raster map: name@mapset

####### grass.pygrass.raster.abstract.RasterAbstractBase.get_cat

```python
get_cat(label)
```

Return a category given an index or a label

####### grass.pygrass.raster.abstract.RasterAbstractBase.get_cats

```python
get_cats()
```

Return a category object

####### grass.pygrass.raster.abstract.RasterAbstractBase.get_value

```python
get_value(point, region=None)
```

This method returns the pixel value of a given pair of coordinates:

:param point: pair of coordinates in tuple object or class object with coords()
method

####### grass.pygrass.raster.abstract.RasterAbstractBase.has_cats

```python
has_cats()
```

Return True if the raster map has categories

####### grass.pygrass.raster.abstract.RasterAbstractBase.hist

```python
hist = History(self.name, self.mapset)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.info

```python
info = Info(self.name, self.mapset)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.is_open

```python
is_open()
```

Return True if the map is open False otherwise.

> > > ele = RasterAbstractBase(test_raster_name)
> > > ele.is_open()
> > > False

####### grass.pygrass.raster.abstract.RasterAbstractBase.mapset

```python
mapset = mapset
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.mode

```python
mode = property(fget=_get_mode, fset=_set_mode)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.mtype

```python
mtype = property(fget=_get_mtype, fset=_set_mtype)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.name

```python
name = property(fget=_get_name, fset=_set_name)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.name_mapset

```python
name_mapset(name=None, mapset=None)
```

Return the full name of the Raster.

> > > ele = RasterAbstractBase(test_raster_name)
> > > name = ele.name_mapset().split("@")
> > > name
> > > ['abstract_test_map']

####### grass.pygrass.raster.abstract.RasterAbstractBase.num_cats

```python
num_cats()
```

Return the number of categories

####### grass.pygrass.raster.abstract.RasterAbstractBase.overwrite

```python
overwrite = property(fget=_get_overwrite, fset=_set_overwrite)
```

####### grass.pygrass.raster.abstract.RasterAbstractBase.read_cats

```python
read_cats()
```

Read category from the raster map file

####### grass.pygrass.raster.abstract.RasterAbstractBase.read_cats_rules

```python
read_cats_rules(filename, sep=':')
```

Read category from the raster map file

####### grass.pygrass.raster.abstract.RasterAbstractBase.remove

```python
remove()
```

Remove the map

####### grass.pygrass.raster.abstract.RasterAbstractBase.rename

```python
rename(newname)
```

Rename the map

####### grass.pygrass.raster.abstract.RasterAbstractBase.set_cat

```python
set_cat(label, min_cat, max_cat=None, index=None)
```

Set or update a category

####### grass.pygrass.raster.abstract.RasterAbstractBase.set_cats

```python
set_cats(category)
```

The internal categories are copied from this object.

####### grass.pygrass.raster.abstract.RasterAbstractBase.set_region

```python
set_region(region)
```

Set the computational region that can be different from the
current region settings. This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

####### grass.pygrass.raster.abstract.RasterAbstractBase.set_region_from_rast

```python
set_region_from_rast(rastname='', mapset='')
```

Set the computational region from a map,
if rastername and mapset is not specify, use itself.
This region will be used by all
raster map layers that are opened in the same process.

The GRASS region settings will not be modified.

call C function `Rast_get_cellhd`, `Rast_set_window`

####### grass.pygrass.raster.abstract.RasterAbstractBase.sort_cats

```python
sort_cats()
```

Sort categories order by range

####### grass.pygrass.raster.abstract.RasterAbstractBase.write_cats

```python
write_cats()
```

Write category to the raster map file

####### grass.pygrass.raster.abstract.RasterAbstractBase.write_cats_rules

```python
write_cats_rules(filename, sep=':')
```

Write category to the raster map file

###### grass.pygrass.raster.abstract.mset

```python
mset = utils.get_mapset_raster(test_raster_name, mapset='')
```

###### grass.pygrass.raster.abstract.test_raster_name

```python
test_raster_name = 'abstract_test_map'
```

##### grass.pygrass.raster.buffer

**Classes:**

- [**Buffer**](#grass.pygrass.raster.buffer.Buffer) – shape, mtype='FCELL', buffer=None, offset=0,

**Attributes:**

- [**CELL**](#grass.pygrass.raster.buffer.CELL) –
- [**DCELL**](#grass.pygrass.raster.buffer.DCELL) –
- [**FCELL**](#grass.pygrass.raster.buffer.FCELL) –

###### grass.pygrass.raster.buffer.Buffer

Bases: <code>[ndarray](#numpy.ndarray)</code>

shape, mtype='FCELL', buffer=None, offset=0,
strides=None, order=None

**Attributes:**

- [**mtype**](#grass.pygrass.raster.buffer.Buffer.mtype) –

####### grass.pygrass.raster.buffer.Buffer.mtype

```python
mtype
```

###### grass.pygrass.raster.buffer.CELL

```python
CELL = tuple(getattr(np, attr) for attr in _CELL if hasattr(np, attr))
```

###### grass.pygrass.raster.buffer.DCELL

```python
DCELL = tuple(getattr(np, attr) for attr in _DCELL if hasattr(np, attr))
```

###### grass.pygrass.raster.buffer.FCELL

```python
FCELL = tuple(getattr(np, attr) for attr in _FCELL if hasattr(np, attr))
```

##### grass.pygrass.raster.category

Created on Thu Jun 28 17:44:14 2012

@author: pietro

**Classes:**

- [**Category**](#grass.pygrass.raster.category.Category) – I would like to add the following functions:

###### grass.pygrass.raster.category.Category

```python
Category(name, mapset='', mtype='CELL', *args, **kargs)
```

Bases: <code>[list](#list)</code>

I would like to add the following functions:

Getting the umber of cats:
Rast_number_of_cats() \<- Important for ith access

Getting and setting the title:
Rast_get_cats_title()
Rast_set_cats_title()

Do not use these functions for category access:
Rast_get_cat()
and the specialized types for CELL, FCELL and DCELL.
Since these functions are working on hidden static buffer.

Use the ith-get methods:
Rast_get_ith_c_cat()
Rast_get_ith_f_cat()
Rast_get_ith_d_cat()

This can be implemented using an iterator too. So that the category object
provides the [] access operator to the categories, returning a tuple
(label, min, max).
Using this, the category object must be aware of its raster map type.

Set categories using:
Rast_set_c_cat()
Rast_set_f_cat()
Rast_set_d_cat()

Misc:
Rast_sort_cats()
Rast_copy_cats() \<- This should be wrapped so that categories from an
existing Python category class are copied.

**Functions:**

- [**copy**](#grass.pygrass.raster.category.Category.copy) – Copy from another Category class
- [**get_cat**](#grass.pygrass.raster.category.Category.get_cat) –
- [**labels**](#grass.pygrass.raster.category.Category.labels) –
- [**ncats**](#grass.pygrass.raster.category.Category.ncats) –
- [**read**](#grass.pygrass.raster.category.Category.read) – Read categories from a raster map
- [**read_rules**](#grass.pygrass.raster.category.Category.read_rules) – Copy categories from a rules file, default separator is ':', the
- [**reset**](#grass.pygrass.raster.category.Category.reset) –
- [**set_cat**](#grass.pygrass.raster.category.Category.set_cat) –
- [**set_cats_fmt**](#grass.pygrass.raster.category.Category.set_cats_fmt) – Not implemented yet.
- [**sort**](#grass.pygrass.raster.category.Category.sort) –
- [**write**](#grass.pygrass.raster.category.Category.write) – Writes the category file for the raster map name in the current
- [**write_rules**](#grass.pygrass.raster.category.Category.write_rules) – Copy categories from a rules file, default separator is ':', the

**Attributes:**

- [**c_cats**](#grass.pygrass.raster.category.Category.c_cats) –
- [**mapset**](#grass.pygrass.raster.category.Category.mapset) –
- [**mtype**](#grass.pygrass.raster.category.Category.mtype) –
- [**name**](#grass.pygrass.raster.category.Category.name) –
- [**title**](#grass.pygrass.raster.category.Category.title) –

####### grass.pygrass.raster.category.Category.c_cats

```python
c_cats = libraster.Categories()
```

####### grass.pygrass.raster.category.Category.copy

```python
copy(category)
```

Copy from another Category class

:param category: Category class to be copied
:type category: Category object

####### grass.pygrass.raster.category.Category.get_cat

```python
get_cat(index)
```

####### grass.pygrass.raster.category.Category.labels

```python
labels()
```

####### grass.pygrass.raster.category.Category.mapset

```python
mapset = mapset
```

####### grass.pygrass.raster.category.Category.mtype

```python
mtype = property(fget=_get_mtype, fset=_set_mtype, doc='Set or obtain raster data type')
```

####### grass.pygrass.raster.category.Category.name

```python
name = name
```

####### grass.pygrass.raster.category.Category.ncats

```python
ncats()
```

####### grass.pygrass.raster.category.Category.read

```python
read()
```

Read categories from a raster map

The category file for raster map name in mapset is read into the
cats structure. If there is an error reading the category file,
a diagnostic message is printed.

int Rast_read_cats(const char * name,
const char * mapset,
struct Categories * pcats
)

####### grass.pygrass.raster.category.Category.read_rules

```python
read_rules(filename, sep=':')
```

Copy categories from a rules file, default separator is ':', the
columns must be: min and/or max and label. ::

```
1:forest
2:road
3:urban

0.:0.5:forest
0.5:1.0:road
1.0:1.5:urban
```

:param str filename: the name of file with categories rules
:param str sep: the separator used to divide values and category

####### grass.pygrass.raster.category.Category.reset

```python
reset()
```

####### grass.pygrass.raster.category.Category.set_cat

```python
set_cat(index, value)
```

####### grass.pygrass.raster.category.Category.set_cats_fmt

```python
set_cats_fmt(fmt, m1, a1, m2, a2)
```

Not implemented yet.
void Rast_set_cats_fmt()

####### grass.pygrass.raster.category.Category.sort

```python
sort()
```

####### grass.pygrass.raster.category.Category.title

```python
title = property(fget=_get_title, fset=_set_title, doc='Set or obtain raster title')
```

####### grass.pygrass.raster.category.Category.write

```python
write()
```

Writes the category file for the raster map name in the current
mapset from the cats structure.

void Rast_write_cats(const char * name,
struct Categories * cats
)

####### grass.pygrass.raster.category.Category.write_rules

```python
write_rules(filename, sep=':')
```

Copy categories from a rules file, default separator is ':', the
columns must be: min and/or max and label. ::

```
1:forest
2:road
3:urban

0.:0.5:forest
0.5:1.0:road
1.0:1.5:urban
```

:param str filename: the name of file with categories rules
:param str sep: the separator used to divide values and category

##### grass.pygrass.raster.cats

```python
cats = '11:A\n            12:B\n            13:C\n            14:D\n            21:E\n            22:F\n            23:G\n            24:H\n            31:I\n            32:J\n            33:K\n            34:L\n            41:M\n            42:n\n            43:O\n            44:P'
```

##### grass.pygrass.raster.history

Created on Thu Jun 28 17:44:45 2012

@author: pietro

**Classes:**

- [**History**](#grass.pygrass.raster.history.History) – History class help to manage all the metadata of a raster map

###### grass.pygrass.raster.history.History

```python
History(name, mapset='', mtype='', creator='', src1='', src2='', keyword='', date='', title='')
```

History class help to manage all the metadata of a raster map

**Functions:**

- [**append**](#grass.pygrass.raster.history.History.append) – Rast_append_history
- [**append_fmt**](#grass.pygrass.raster.history.History.append_fmt) – Rast_append_format_history
- [**clear**](#grass.pygrass.raster.history.History.clear) – Clear the history
- [**command**](#grass.pygrass.raster.history.History.command) – Rast_command_history
- [**format**](#grass.pygrass.raster.history.History.format) – Rast_format_history
- [**length**](#grass.pygrass.raster.history.History.length) – Rast_history_length
- [**line**](#grass.pygrass.raster.history.History.line) – Rast_history_line
- [**read**](#grass.pygrass.raster.history.History.read) – Read the history of map, users need to use this function to
- [**short**](#grass.pygrass.raster.history.History.short) – Rast_short_history
- [**write**](#grass.pygrass.raster.history.History.write) – Rast_write_history

**Attributes:**

- [**attrs**](#grass.pygrass.raster.history.History.attrs) –
- [**c_hist**](#grass.pygrass.raster.history.History.c_hist) –
- [**creator**](#grass.pygrass.raster.history.History.creator) –
- [**date**](#grass.pygrass.raster.history.History.date) –
- [**date_fmt**](#grass.pygrass.raster.history.History.date_fmt) –
- [**keyword**](#grass.pygrass.raster.history.History.keyword) –
- [**mapset**](#grass.pygrass.raster.history.History.mapset) –
- [**maptype**](#grass.pygrass.raster.history.History.maptype) –
- [**mtype**](#grass.pygrass.raster.history.History.mtype) –
- [**name**](#grass.pygrass.raster.history.History.name) –
- [**src1**](#grass.pygrass.raster.history.History.src1) –
- [**src2**](#grass.pygrass.raster.history.History.src2) –
- [**title**](#grass.pygrass.raster.history.History.title) –

####### grass.pygrass.raster.history.History.append

```python
append(obj)
```

Rast_append_history

####### grass.pygrass.raster.history.History.append_fmt

```python
append_fmt(fmt, *args)
```

Rast_append_format_history

####### grass.pygrass.raster.history.History.attrs

```python
attrs = ['name', 'mapset', 'mtype', 'creator', 'src1', 'src2', 'keyword', 'date', 'title']
```

####### grass.pygrass.raster.history.History.c_hist

```python
c_hist = ctypes.pointer(libraster.History())
```

####### grass.pygrass.raster.history.History.clear

```python
clear()
```

Clear the history

####### grass.pygrass.raster.history.History.command

```python
command()
```

Rast_command_history

####### grass.pygrass.raster.history.History.creator

```python
creator = property(fget=_get_creator, fset=_set_creator, doc='Set or obtain the creator of map')
```

####### grass.pygrass.raster.history.History.date

```python
date = property(fget=_get_date, fset=_set_date, doc='Set or obtain the date of map')
```

####### grass.pygrass.raster.history.History.date_fmt

```python
date_fmt = '%a %b  %d %H:%M:%S %Y'
```

####### grass.pygrass.raster.history.History.format

```python
format(field, fmt, *args)
```

Rast_format_history

####### grass.pygrass.raster.history.History.keyword

```python
keyword = property(fget=_get_keyword, fset=_set_keyword, doc='Set or obtain the keywords of map')
```

####### grass.pygrass.raster.history.History.length

```python
length()
```

Rast_history_length

####### grass.pygrass.raster.history.History.line

```python
line(line)
```

Rast_history_line

####### grass.pygrass.raster.history.History.mapset

```python
mapset = property(fget=_get_mapset, fset=_set_mapset, doc='Set or obtain the mapset of map')
```

####### grass.pygrass.raster.history.History.maptype

```python
maptype = property(fget=_get_maptype, fset=_set_maptype, doc='Set or obtain the type of map')
```

####### grass.pygrass.raster.history.History.mtype

```python
mtype = mtype
```

####### grass.pygrass.raster.history.History.name

```python
name = name
```

####### grass.pygrass.raster.history.History.read

```python
read()
```

Read the history of map, users need to use this function to
obtain all the information of map. ::

```
>>> import grass.lib.gis as libgis
>>> import ctypes
>>> import grass.lib.raster as libraster
>>> hist = libraster.History()
```

..

####### grass.pygrass.raster.history.History.short

```python
short()
```

Rast_short_history

####### grass.pygrass.raster.history.History.src1

```python
src1 = property(fget=_get_src1, fset=_set_src1, doc='Set or obtain the first source of map')
```

####### grass.pygrass.raster.history.History.src2

```python
src2 = property(fget=_get_src2, fset=_set_src2, doc='Set or obtain the second source of map')
```

####### grass.pygrass.raster.history.History.title

```python
title = property(fget=_get_title, fset=_set_title, doc='Set or obtain the title of map')
```

####### grass.pygrass.raster.history.History.write

```python
write()
```

Rast_write_history

##### grass.pygrass.raster.mset

```python
mset = utils.get_mapset_raster(test_raster_name, mapset='')
```

##### grass.pygrass.raster.numpy2raster

```python
numpy2raster(array, mtype, rastname, overwrite=False)
```

Save a numpy array to a raster map

:param obj array: a numpy array
:param obj mtype: the datatype of array
:param str rastername: the name of output map
:param bool overwrite: True to overwrite existing map

##### grass.pygrass.raster.random_map

```python
random_map(mapname, mtype, overwrite=True, factor=100)
```

##### grass.pygrass.raster.random_map_only_columns

```python
random_map_only_columns(mapname, mtype, overwrite=True, factor=100)
```

##### grass.pygrass.raster.raster2numpy

```python
raster2numpy(rastname, mapset='')
```

Return a numpy array from a raster map

:param str rastname: the name of raster map
:parar str mapset: the name of mapset containing raster map

##### grass.pygrass.raster.raster2numpy_img

```python
raster2numpy_img(rastname, region, color='ARGB', array=None)
```

Convert a raster map layer into a string with
32Bit ARGB, 24Bit RGB or 8Bit Gray little endian encoding.

Return a numpy array from a raster map of type uint8
that contains the colored map data as 32 bit ARGB, 32Bit RGB
or 8 bit image

:param rastname: The name of raster map
:type rastname: string

:param region: The region to be used for raster map reading
:type region: grass.pygrass.gis.region.Region

:param color: "ARGB", "RGB", "GRAY1", "GRAY2"
ARGB -> 32Bit RGB with alpha channel (0xAARRGGBB)
RGB -> 32Bit RGB (0xffRRGGBB)
GRAY1 -> grey scale formular: .33R+ .5G+ .17B
GRAY2 -> grey scale formular: .30R+ .59G+ .11B
:type color: String

:param array: A numpy array (optional) to store the image,
the array needs to setup as follows:

```
          array = np.ndarray((region.rows*region.cols*scale), np.uint8)

          scale = 4 in case of ARGB and RGB or scale = 1
          in case of Gray scale
```

:type array: numpy.ndarray

:return: A numpy array of size rows*cols*4 in case of ARGB, RGB and
rows*cols*1 in case of gray scale

Attention: This function will change the computational raster region
of the current process while running.

##### grass.pygrass.raster.raster_type

Created on Wed Jun 13 19:42:22 2012

@author: pietro

**Attributes:**

- [**RTYPE_STR**](#grass.pygrass.raster.raster_type.RTYPE_STR) –
- [**TYPE**](#grass.pygrass.raster.raster_type.TYPE) –

###### grass.pygrass.raster.raster_type.RTYPE_STR

```python
RTYPE_STR = {libraster.CELL_TYPE: 'CELL', libraster.FCELL_TYPE: 'FCELL', libraster.DCELL_TYPE: 'DCELL'}
```

###### grass.pygrass.raster.raster_type.TYPE

```python
TYPE = {'CELL': {'grass type': libraster.CELL_TYPE, 'grass def': libraster.CELL, 'numpy': np.int32, 'ctypes': ctypes.c_int}, 'FCELL': {'grass type': libraster.FCELL_TYPE, 'grass def': libraster.FCELL, 'numpy': np.float32, 'ctypes': ctypes.c_float}, 'DCELL': {'grass type': libraster.DCELL_TYPE, 'grass def': libraster.DCELL, 'numpy': np.float64, 'ctypes': ctypes.c_double}}
```

##### grass.pygrass.raster.rowio

Created on Mon Jun 18 13:22:38 2012

@author: pietro

**Classes:**

- [**RowIO**](#grass.pygrass.raster.rowio.RowIO) –

**Functions:**

- [**getmaprow_CELL**](#grass.pygrass.raster.rowio.getmaprow_CELL) –
- [**getmaprow_DCELL**](#grass.pygrass.raster.rowio.getmaprow_DCELL) –
- [**getmaprow_FCELL**](#grass.pygrass.raster.rowio.getmaprow_FCELL) –

**Attributes:**

- [**CMPFUNC**](#grass.pygrass.raster.rowio.CMPFUNC) –
- [**get_row**](#grass.pygrass.raster.rowio.get_row) –

###### grass.pygrass.raster.rowio.CMPFUNC

```python
CMPFUNC = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.c_void_p, ctypes.c_int)
```

###### grass.pygrass.raster.rowio.RowIO

```python
RowIO()
```

**Functions:**

- [**get**](#grass.pygrass.raster.rowio.RowIO.get) –
- [**open**](#grass.pygrass.raster.rowio.RowIO.open) –
- [**release**](#grass.pygrass.raster.rowio.RowIO.release) –

**Attributes:**

- [**c_rowio**](#grass.pygrass.raster.rowio.RowIO.c_rowio) –
- [**cols**](#grass.pygrass.raster.rowio.RowIO.cols) –
- [**fd**](#grass.pygrass.raster.rowio.RowIO.fd) –
- [**mtype**](#grass.pygrass.raster.rowio.RowIO.mtype) –
- [**row_size**](#grass.pygrass.raster.rowio.RowIO.row_size) –
- [**rows**](#grass.pygrass.raster.rowio.RowIO.rows) –

####### grass.pygrass.raster.rowio.RowIO.c_rowio

```python
c_rowio = librowio.ROWIO()
```

####### grass.pygrass.raster.rowio.RowIO.cols

```python
cols = None
```

####### grass.pygrass.raster.rowio.RowIO.fd

```python
fd = None
```

####### grass.pygrass.raster.rowio.RowIO.get

```python
get(row_index, buf)
```

####### grass.pygrass.raster.rowio.RowIO.mtype

```python
mtype = None
```

####### grass.pygrass.raster.rowio.RowIO.open

```python
open(fd, rows, cols, mtype)
```

####### grass.pygrass.raster.rowio.RowIO.release

```python
release()
```

####### grass.pygrass.raster.rowio.RowIO.row_size

```python
row_size = None
```

####### grass.pygrass.raster.rowio.RowIO.rows

```python
rows = None
```

###### grass.pygrass.raster.rowio.get_row

```python
get_row = {'CELL': CMPFUNC(getmaprow_CELL), 'FCELL': CMPFUNC(getmaprow_FCELL), 'DCELL': CMPFUNC(getmaprow_DCELL)}
```

###### grass.pygrass.raster.rowio.getmaprow_CELL

```python
getmaprow_CELL(fd, buf, row)
```

###### grass.pygrass.raster.rowio.getmaprow_DCELL

```python
getmaprow_DCELL(fd, buf, row)
```

###### grass.pygrass.raster.rowio.getmaprow_FCELL

```python
getmaprow_FCELL(fd, buf, row)
```

##### grass.pygrass.raster.segment

Created on Mon Jun 11 18:02:27 2012

@author: pietro

**Classes:**

- [**Segment**](#grass.pygrass.raster.segment.Segment) –

###### grass.pygrass.raster.segment.Segment

```python
Segment(srows=64, scols=64, maxmem=100)
```

**Functions:**

- [**close**](#grass.pygrass.raster.segment.Segment.close) – Free memory allocated to segment and delete temp file.
- [**cols**](#grass.pygrass.raster.segment.Segment.cols) –
- [**flush**](#grass.pygrass.raster.segment.Segment.flush) – Flush pending updates to disk.
- [**format**](#grass.pygrass.raster.segment.Segment.format) – The segmentation routines require a disk file to be used for paging
- [**get**](#grass.pygrass.raster.segment.Segment.get) – Return the value of the map
- [**get_row**](#grass.pygrass.raster.segment.Segment.get_row) – Return the row using, the `segment` method
- [**get_seg_number**](#grass.pygrass.raster.segment.Segment.get_seg_number) – Return the segment number
- [**init**](#grass.pygrass.raster.segment.Segment.init) –
- [**nseg**](#grass.pygrass.raster.segment.Segment.nseg) –
- [**open**](#grass.pygrass.raster.segment.Segment.open) – Open a segment it is necessary to pass a RasterSegment object.
- [**put**](#grass.pygrass.raster.segment.Segment.put) – Write the value to the map
- [**put_row**](#grass.pygrass.raster.segment.Segment.put_row) – Write the row using the `segment` method
- [**release**](#grass.pygrass.raster.segment.Segment.release) – Free memory allocated to segment.
- [**rows**](#grass.pygrass.raster.segment.Segment.rows) –
- [**segments_in_mem**](#grass.pygrass.raster.segment.Segment.segments_in_mem) –

**Attributes:**

- [**c_seg**](#grass.pygrass.raster.segment.Segment.c_seg) –
- [**maxmem**](#grass.pygrass.raster.segment.Segment.maxmem) –
- [**scols**](#grass.pygrass.raster.segment.Segment.scols) –
- [**srows**](#grass.pygrass.raster.segment.Segment.srows) –

####### grass.pygrass.raster.segment.Segment.c_seg

```python
c_seg = ctypes.pointer(libseg.SEGMENT())
```

####### grass.pygrass.raster.segment.Segment.close

```python
close()
```

Free memory allocated to segment and delete temp file.

####### grass.pygrass.raster.segment.Segment.cols

```python
cols()
```

####### grass.pygrass.raster.segment.Segment.flush

```python
flush()
```

Flush pending updates to disk.
Forces all pending updates generated by Segment_put() to be written to
the segment file seg. Must be called after the final Segment_put()
to force all pending updates to disk. Must also be called before the
first call to Segment_get_row.

####### grass.pygrass.raster.segment.Segment.format

```python
format(mapobj, file_name='', fill=True)
```

The segmentation routines require a disk file to be used for paging
segments in and out of memory. This routine formats the file open for
write on file descriptor fd for use as a segment file.

####### grass.pygrass.raster.segment.Segment.get

```python
get(row_index, col_index)
```

Return the value of the map

####### grass.pygrass.raster.segment.Segment.get_row

```python
get_row(row_index, buf)
```

Return the row using, the `segment` method

####### grass.pygrass.raster.segment.Segment.get_seg_number

```python
get_seg_number(row_index, col_index)
```

Return the segment number

####### grass.pygrass.raster.segment.Segment.init

```python
init(mapobj, file_name='')
```

####### grass.pygrass.raster.segment.Segment.maxmem

```python
maxmem = maxmem
```

####### grass.pygrass.raster.segment.Segment.nseg

```python
nseg()
```

####### grass.pygrass.raster.segment.Segment.open

```python
open(mapobj)
```

Open a segment it is necessary to pass a RasterSegment object.

####### grass.pygrass.raster.segment.Segment.put

```python
put(row_index, col_index)
```

Write the value to the map

####### grass.pygrass.raster.segment.Segment.put_row

```python
put_row(row_index, buf)
```

Write the row using the `segment` method

####### grass.pygrass.raster.segment.Segment.release

```python
release()
```

Free memory allocated to segment.
Releases the allocated memory associated with the segment file seg.
Note: Does not close the file. Does not flush the data which may be
pending from previous Segment_put() calls.

####### grass.pygrass.raster.segment.Segment.rows

```python
rows()
```

####### grass.pygrass.raster.segment.Segment.scols

```python
scols = scols
```

####### grass.pygrass.raster.segment.Segment.segments_in_mem

```python
segments_in_mem()
```

####### grass.pygrass.raster.segment.Segment.srows

```python
srows = srows
```

##### grass.pygrass.raster.test_raster_name

```python
test_raster_name = 'Raster_test_map'
```

#### grass.pygrass.rpc

Fast and exit-safe interface to PyGRASS Raster and Vector layer
using multiprocessing

(C) 2015 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

:authors: Soeren Gebbert

**Modules:**

- [**base**](#grass.pygrass.rpc.base) – Fast and exit-safe interface to PyGRASS Raster and Vector layer

**Classes:**

- [**DataProvider**](#grass.pygrass.rpc.DataProvider) – Fast and exit-safe interface to PyGRASS data delivery functions
- [**RPCDefs**](#grass.pygrass.rpc.RPCDefs) –

**Functions:**

- [**data_provider_server**](#grass.pygrass.rpc.data_provider_server) – The PyGRASS data provider server designed to be a target for

**Attributes:**

- [**mset**](#grass.pygrass.rpc.mset) –
- [**test_raster_name**](#grass.pygrass.rpc.test_raster_name) –
- [**test_vector_name**](#grass.pygrass.rpc.test_vector_name) –

##### grass.pygrass.rpc.DataProvider

```python
DataProvider()
```

Bases: <code>[RPCServerBase](#grass.pygrass.rpc.base.RPCServerBase)</code>

Fast and exit-safe interface to PyGRASS data delivery functions

**Functions:**

- [**check_server**](#grass.pygrass.rpc.DataProvider.check_server) –
- [**get_raster_image_as_np**](#grass.pygrass.rpc.DataProvider.get_raster_image_as_np) – Return the attribute table of a vector map as dictionary.
- [**get_vector_features_as_wkb_list**](#grass.pygrass.rpc.DataProvider.get_vector_features_as_wkb_list) – Return the features of a vector map as wkb list.
- [**get_vector_table_as_dict**](#grass.pygrass.rpc.DataProvider.get_vector_table_as_dict) – Return the attribute table of a vector map as dictionary.
- [**is_check_thread_alive**](#grass.pygrass.rpc.DataProvider.is_check_thread_alive) –
- [**is_server_alive**](#grass.pygrass.rpc.DataProvider.is_server_alive) –
- [**safe_receive**](#grass.pygrass.rpc.DataProvider.safe_receive) – Receive the data and throw a FatalError exception in case the server
- [**start_checker_thread**](#grass.pygrass.rpc.DataProvider.start_checker_thread) –
- [**start_server**](#grass.pygrass.rpc.DataProvider.start_server) – This function must be re-implemented in the subclasses
- [**stop**](#grass.pygrass.rpc.DataProvider.stop) – Stop the check thread, the libgis server and close the pipe
- [**stop_checker_thread**](#grass.pygrass.rpc.DataProvider.stop_checker_thread) –
- [**thread_checker**](#grass.pygrass.rpc.DataProvider.thread_checker) – Check every 200 micro seconds if the server process is alive

**Attributes:**

- [**checkThread**](#grass.pygrass.rpc.DataProvider.checkThread) (<code>[Thread](#threading.Thread) | None</code>) –
- [**client_conn**](#grass.pygrass.rpc.DataProvider.client_conn) (<code>[Connection](#multiprocessing.connection.Connection) | None</code>) –
- [**queue**](#grass.pygrass.rpc.DataProvider.queue) –
- [**server**](#grass.pygrass.rpc.DataProvider.server) –
- [**server_conn**](#grass.pygrass.rpc.DataProvider.server_conn) (<code>[Connection](#multiprocessing.connection.Connection) | None</code>) –
- [**stopThread**](#grass.pygrass.rpc.DataProvider.stopThread) –
- [**stopped**](#grass.pygrass.rpc.DataProvider.stopped) –
- [**threadLock**](#grass.pygrass.rpc.DataProvider.threadLock) –

###### grass.pygrass.rpc.DataProvider.checkThread

```python
checkThread: threading.Thread | None = None
```

###### grass.pygrass.rpc.DataProvider.check_server

```python
check_server()
```

###### grass.pygrass.rpc.DataProvider.client_conn

```python
client_conn: Connection | None = None
```

###### grass.pygrass.rpc.DataProvider.get_raster_image_as_np

```python
get_raster_image_as_np(name, mapset=None, extent=None, color='RGB')
```

Return the attribute table of a vector map as dictionary.

See documentation of: pygrass.raster.raster2numpy_img

Usage:

.. code-block:: python

> > > from grass.pygrass.rpc import DataProvider
> > > import time
> > > provider = DataProvider()
> > > ret = provider.get_raster_image_as_np(name=test_raster_name)
> > > len(ret)
> > > 64

> > > extent = {
> > > ... "north": 30,
> > > ... "south": 10,
> > > ... "east": 30,
> > > ... "west": 10,
> > > ... "rows": 2,
> > > ... "cols": 2,
> > > ... }
> > > ret = provider.get_raster_image_as_np(name=test_raster_name, extent=extent)
> > > len(ret)
> > > 16

> > > extent = {"rows": 3, "cols": 1}
> > > ret = provider.get_raster_image_as_np(name=test_raster_name, extent=extent)
> > > len(ret)
> > > 12

> > > extent = {
> > > ... "north": 100,
> > > ... "south": 10,
> > > ... "east": 30,
> > > ... "west": 10,
> > > ... "rows": 2,
> > > ... "cols": 2,
> > > ... }
> > > ret = provider.get_raster_image_as_np(name=test_raster_name, extent=extent)

> > > provider.stop()
> > > time.sleep(1)

> > > extent = {"rows": 3, "cols": 1}
> > > ret = provider.get_raster_image_as_np(name=test_raster_name, extent=extent)
> > > len(ret)
> > > 12

..

###### grass.pygrass.rpc.DataProvider.get_vector_features_as_wkb_list

```python
get_vector_features_as_wkb_list(name, mapset=None, extent=None, feature_type='point', field=1)
```

Return the features of a vector map as wkb list.

:param extent: A dictionary of {"north":double, "south":double,
"east":double, "west":double}
:param feature_type: point, centroid, line, boundary or area

<details class="see-documentation" open>
<summary>pygrass.vector.VectorTopo::features_to_wkb_list</summary>
pygrass.vector.VectorTopo::areas_to_wkb_list
</details>

Usage:

.. code-block:: python

> > > from grass.pygrass.rpc import DataProvider
> > > provider = DataProvider()
> > > wkb = provider.get_vector_features_as_wkb_list(
> > > ... name=test_vector_name, extent=None, feature_type="point"
> > > ... )
> > > for entry in wkb:
> > > ... f_id, cat, string = entry
> > > ... print(f_id, cat, len(string))
> > > ...
> > > 1 1 21
> > > 2 1 21
> > > 3 1 21

> > > extent = {"north": 6.6, "south": 5.5, "east": 14.5, "west": 13.5}
> > > wkb = provider.get_vector_features_as_wkb_list(
> > > ... name=test_vector_name, extent=extent, feature_type="point"
> > > ... )
> > > for entry in wkb:
> > > ... f_id, cat, string = entry
> > > ... print(f_id, cat, len(string))
> > > ...
> > > 3 1 21

> > > wkb = provider.get_vector_features_as_wkb_list(
> > > ... name=test_vector_name, extent=None, feature_type="line"
> > > ... )
> > > for entry in wkb:
> > > ... f_id, cat, string = entry
> > > ... print(f_id, cat, len(string))
> > > ...
> > > 4 2 57
> > > 5 2 57
> > > 6 2 57

> > > wkb = provider.get_vector_features_as_wkb_list(
> > > ... name=test_vector_name, extent=None, feature_type="centroid"
> > > ... )
> > > for entry in wkb:
> > > ... f_id, cat, string = entry
> > > ... print(f_id, cat, len(string))
> > > ...
> > > 19 3 21
> > > 18 3 21
> > > 20 3 21
> > > 21 3 21

> > > wkb = provider.get_vector_features_as_wkb_list(
> > > ... name=test_vector_name, extent=None, feature_type="area"
> > > ... )
> > > for entry in wkb:
> > > ... f_id, cat, string = entry
> > > ... print(f_id, cat, len(string))
> > > ...
> > > 1 3 225
> > > 2 3 141
> > > 3 3 93
> > > 4 3 141

> > > wkb = provider.get_vector_features_as_wkb_list(
> > > ... name=test_vector_name, extent=None, feature_type="boundary"
> > > ... )
> > > for entry in wkb:
> > > ... f_id, cat, string = entry
> > > ... print(f_id, cat, len(string))
> > > ...
> > > 10 None 41
> > > 7 None 41
> > > 8 None 41
> > > 9 None 41
> > > 11 None 89
> > > 12 None 41
> > > 14 None 41
> > > 13 None 41
> > > 17 None 41
> > > 15 None 41
> > > 16 None 41

> > > provider.stop()

..

###### grass.pygrass.rpc.DataProvider.get_vector_table_as_dict

```python
get_vector_table_as_dict(name, mapset=None, where=None)
```

Return the attribute table of a vector map as dictionary.

See documentation of: pygrass.vector.VectorTopo::table_to_dict

Usage:

.. code-block:: python

> > > from grass.pygrass.rpc import DataProvider
> > > provider = DataProvider()
> > > ret = provider.get_vector_table_as_dict(name=test_vector_name)
> > > ret["table"]
> > > {1: [1, 'point', 1.0], 2: [2, 'line', 2.0], 3: [3, 'centroid', 3.0]}
> > > ret["columns"]
> > > Columns([('cat', 'INTEGER'), ('name', 'varchar(50)'), ('value', 'double precision')])
> > > ret = provider.get_vector_table_as_dict(
> > > ... name=test_vector_name, where="value > 1"
> > > ... )
> > > ret["table"]
> > > {2: [2, 'line', 2.0], 3: [3, 'centroid', 3.0]}
> > > ret["columns"]
> > > Columns([('cat', 'INTEGER'), ('name', 'varchar(50)'), ('value', 'double precision')])
> > > provider.get_vector_table_as_dict(name="no_map", where="value > 1")
> > > provider.stop()

..

###### grass.pygrass.rpc.DataProvider.is_check_thread_alive

```python
is_check_thread_alive()
```

###### grass.pygrass.rpc.DataProvider.is_server_alive

```python
is_server_alive()
```

###### grass.pygrass.rpc.DataProvider.queue

```python
queue = None
```

###### grass.pygrass.rpc.DataProvider.safe_receive

```python
safe_receive(message)
```

Receive the data and throw a FatalError exception in case the server
process was killed and the pipe was closed by the checker thread

###### grass.pygrass.rpc.DataProvider.server

```python
server = None
```

###### grass.pygrass.rpc.DataProvider.server_conn

```python
server_conn: Connection | None = None
```

###### grass.pygrass.rpc.DataProvider.start_checker_thread

```python
start_checker_thread()
```

###### grass.pygrass.rpc.DataProvider.start_server

```python
start_server()
```

This function must be re-implemented in the subclasses

###### grass.pygrass.rpc.DataProvider.stop

```python
stop()
```

Stop the check thread, the libgis server and close the pipe

This method should be called at exit using the package atexit

###### grass.pygrass.rpc.DataProvider.stopThread

```python
stopThread = False
```

###### grass.pygrass.rpc.DataProvider.stop_checker_thread

```python
stop_checker_thread()
```

###### grass.pygrass.rpc.DataProvider.stopped

```python
stopped = True
```

###### grass.pygrass.rpc.DataProvider.threadLock

```python
threadLock = threading.Lock()
```

###### grass.pygrass.rpc.DataProvider.thread_checker

```python
thread_checker()
```

Check every 200 micro seconds if the server process is alive

##### grass.pygrass.rpc.RPCDefs

**Attributes:**

- [**GET_RASTER_IMAGE_AS_NP**](#grass.pygrass.rpc.RPCDefs.GET_RASTER_IMAGE_AS_NP) –
- [**GET_VECTOR_FEATURES_AS_WKB**](#grass.pygrass.rpc.RPCDefs.GET_VECTOR_FEATURES_AS_WKB) –
- [**GET_VECTOR_TABLE_AS_DICT**](#grass.pygrass.rpc.RPCDefs.GET_VECTOR_TABLE_AS_DICT) –
- [**G_FATAL_ERROR**](#grass.pygrass.rpc.RPCDefs.G_FATAL_ERROR) –
- [**STOP**](#grass.pygrass.rpc.RPCDefs.STOP) –

###### grass.pygrass.rpc.RPCDefs.GET_RASTER_IMAGE_AS_NP

```python
GET_RASTER_IMAGE_AS_NP = 3
```

###### grass.pygrass.rpc.RPCDefs.GET_VECTOR_FEATURES_AS_WKB

```python
GET_VECTOR_FEATURES_AS_WKB = 2
```

###### grass.pygrass.rpc.RPCDefs.GET_VECTOR_TABLE_AS_DICT

```python
GET_VECTOR_TABLE_AS_DICT = 1
```

###### grass.pygrass.rpc.RPCDefs.G_FATAL_ERROR

```python
G_FATAL_ERROR = 14
```

###### grass.pygrass.rpc.RPCDefs.STOP

```python
STOP = 0
```

##### grass.pygrass.rpc.base

Fast and exit-safe interface to PyGRASS Raster and Vector layer
using multiprocessing

(C) 2015-2024 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

:authors: Soeren Gebbert

**Classes:**

- [**RPCServerBase**](#grass.pygrass.rpc.base.RPCServerBase) – This is the base class for send and receive RPC server

**Functions:**

- [**dummy_server**](#grass.pygrass.rpc.base.dummy_server) – Dummy server process

**Attributes:**

- [**logger**](#grass.pygrass.rpc.base.logger) (<code>[Logger](#logging.Logger)</code>) –

###### grass.pygrass.rpc.base.RPCServerBase

```python
RPCServerBase()
```

This is the base class for send and receive RPC server
It uses a Pipe for IPC.

> > > import grass.script as gscript
> > > from grass.pygrass.rpc.base import RPCServerBase
> > > import time
> > > provider = RPCServerBase()

> > > provider.is_server_alive()
> > > True

> > > provider.is_check_thread_alive()
> > > True

> > > provider.stop()
> > > time.sleep(1)
> > > provider.is_server_alive()
> > > False

> > > provider.is_check_thread_alive()
> > > False

> > > provider = RPCServerBase()
> > > provider.is_server_alive()
> > > True
> > > provider.is_check_thread_alive()
> > > True

Kill the server process with an exception, it should restart

> > > provider.client_conn.send([1])
> > > provider.is_server_alive()
> > > True

> > > provider.is_check_thread_alive()
> > > True

**Functions:**

- [**check_server**](#grass.pygrass.rpc.base.RPCServerBase.check_server) –
- [**is_check_thread_alive**](#grass.pygrass.rpc.base.RPCServerBase.is_check_thread_alive) –
- [**is_server_alive**](#grass.pygrass.rpc.base.RPCServerBase.is_server_alive) –
- [**safe_receive**](#grass.pygrass.rpc.base.RPCServerBase.safe_receive) – Receive the data and throw a FatalError exception in case the server
- [**start_checker_thread**](#grass.pygrass.rpc.base.RPCServerBase.start_checker_thread) –
- [**start_server**](#grass.pygrass.rpc.base.RPCServerBase.start_server) – This function must be re-implemented in the subclasses
- [**stop**](#grass.pygrass.rpc.base.RPCServerBase.stop) – Stop the check thread, the libgis server and close the pipe
- [**stop_checker_thread**](#grass.pygrass.rpc.base.RPCServerBase.stop_checker_thread) –
- [**thread_checker**](#grass.pygrass.rpc.base.RPCServerBase.thread_checker) – Check every 200 micro seconds if the server process is alive

**Attributes:**

- [**checkThread**](#grass.pygrass.rpc.base.RPCServerBase.checkThread) (<code>[Thread](#threading.Thread) | None</code>) –
- [**client_conn**](#grass.pygrass.rpc.base.RPCServerBase.client_conn) (<code>[Connection](#multiprocessing.connection.Connection) | None</code>) –
- [**queue**](#grass.pygrass.rpc.base.RPCServerBase.queue) –
- [**server**](#grass.pygrass.rpc.base.RPCServerBase.server) –
- [**server_conn**](#grass.pygrass.rpc.base.RPCServerBase.server_conn) (<code>[Connection](#multiprocessing.connection.Connection) | None</code>) –
- [**stopThread**](#grass.pygrass.rpc.base.RPCServerBase.stopThread) –
- [**stopped**](#grass.pygrass.rpc.base.RPCServerBase.stopped) –
- [**threadLock**](#grass.pygrass.rpc.base.RPCServerBase.threadLock) –

####### grass.pygrass.rpc.base.RPCServerBase.checkThread

```python
checkThread: threading.Thread | None = None
```

####### grass.pygrass.rpc.base.RPCServerBase.check_server

```python
check_server()
```

####### grass.pygrass.rpc.base.RPCServerBase.client_conn

```python
client_conn: Connection | None = None
```

####### grass.pygrass.rpc.base.RPCServerBase.is_check_thread_alive

```python
is_check_thread_alive()
```

####### grass.pygrass.rpc.base.RPCServerBase.is_server_alive

```python
is_server_alive()
```

####### grass.pygrass.rpc.base.RPCServerBase.queue

```python
queue = None
```

####### grass.pygrass.rpc.base.RPCServerBase.safe_receive

```python
safe_receive(message)
```

Receive the data and throw a FatalError exception in case the server
process was killed and the pipe was closed by the checker thread

####### grass.pygrass.rpc.base.RPCServerBase.server

```python
server = None
```

####### grass.pygrass.rpc.base.RPCServerBase.server_conn

```python
server_conn: Connection | None = None
```

####### grass.pygrass.rpc.base.RPCServerBase.start_checker_thread

```python
start_checker_thread()
```

####### grass.pygrass.rpc.base.RPCServerBase.start_server

```python
start_server()
```

This function must be re-implemented in the subclasses

####### grass.pygrass.rpc.base.RPCServerBase.stop

```python
stop()
```

Stop the check thread, the libgis server and close the pipe

This method should be called at exit using the package atexit

####### grass.pygrass.rpc.base.RPCServerBase.stopThread

```python
stopThread = False
```

####### grass.pygrass.rpc.base.RPCServerBase.stop_checker_thread

```python
stop_checker_thread()
```

####### grass.pygrass.rpc.base.RPCServerBase.stopped

```python
stopped = True
```

####### grass.pygrass.rpc.base.RPCServerBase.threadLock

```python
threadLock = threading.Lock()
```

####### grass.pygrass.rpc.base.RPCServerBase.thread_checker

```python
thread_checker()
```

Check every 200 micro seconds if the server process is alive

###### grass.pygrass.rpc.base.dummy_server

```python
dummy_server(lock, conn)
```

Dummy server process

:param lock: A multiprocessing.Lock
:param conn: A multiprocessing.connection.Connection object obtained from
multiprocessing.Pipe

###### grass.pygrass.rpc.base.logger

```python
logger: logging.Logger = logging.getLogger(__name__)
```

##### grass.pygrass.rpc.data_provider_server

```python
data_provider_server(lock, conn)
```

The PyGRASS data provider server designed to be a target for
multiprocessing.Process

:param lock: A multiprocessing.Lock
:param conn: A multiprocessing.connection.Connection object obtained from
multiprocessing.Pipe

##### grass.pygrass.rpc.mset

```python
mset = utils.get_mapset_raster(test_raster_name, mapset='')
```

##### grass.pygrass.rpc.test_raster_name

```python
test_raster_name = 'data_provider_raster_map'
```

##### grass.pygrass.rpc.test_vector_name

```python
test_vector_name = 'data_provider_vector_map'
```

#### grass.pygrass.shell

**Modules:**

- [**conversion**](#grass.pygrass.shell.conversion) – Created on Sun Jun 23 13:40:19 2013
- [**show**](#grass.pygrass.shell.show) – Created on Sun Jun 23 19:58:54 2013

##### grass.pygrass.shell.conversion

Created on Sun Jun 23 13:40:19 2013

@author: pietro

**Functions:**

- [**dict2html**](#grass.pygrass.shell.conversion.dict2html) – Return a html repr of a dictionary.

**Attributes:**

- [**dcont**](#grass.pygrass.shell.conversion.dcont) –

###### grass.pygrass.shell.conversion.dcont

```python
dcont = '    <tr>\n      <td>{key}</td>\n      <td>{value}</td>\n    </tr>'
```

###### grass.pygrass.shell.conversion.dict2html

```python
dict2html(dic, keys=None, border='', kfmt='%s', kdec='', kfun=None, vfmt='%s', vdec='', vfun=None)
```

Return a html repr of a dictionary.

:param dict dic: dictionary or object with `keys` and `items` methods
:param keys: iterable objectwith only the keys that we want to display
:param str border: could be: "0", "1", etc.
:param str kfmt: string to format the key string (i.e. "%r", etc.)
:param str kdec: string to decorate the key (i.e. "b", "i", etc.)
:param str vfmt: string to format the value string (i.e. "%r", etc.)
:param str vdec: string to decorate the value (i.e. "b", "i", etc.)

> > > dic = {"key 0": 0, "key 1": 1}
> > > print(dict2html(dic))

<table>
    <tr>
      <td>key 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>key 1</td>
      <td>1</td>
    </tr>
</table>
>>> print(dict2html(dic, border="1"))
<table border='1'>
    <tr>
      <td>key 0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>key 1</td>
      <td>1</td>
    </tr>
</table>
>>> print(dict2html(dic, kdec="b", vfmt="%05d", vdec="i"))
<table>
    <tr>
      <td><b>key 0</b></td>
      <td><i>00000</i></td>
    </tr>
    <tr>
      <td><b>key 1</b></td>
      <td><i>00001</i></td>
    </tr>
</table>
>>> dic = {"key 0": (2, 3), "key 1": (10, 5)}
>>> print(
...     dict2html(dic, kdec="b", vdec="i", vfun=lambda x: "%d<sup>%.1f</sup>" % x)
... )
<table>
    <tr>
      <td><b>key 0</b></td>
      <td><i>2<sup>3.0</sup></i></td>
    </tr>
    <tr>
      <td><b>key 1</b></td>
      <td><i>10<sup>5.0</sup></i></td>
    </tr>
</table>

##### grass.pygrass.shell.show

Created on Sun Jun 23 19:58:54 2013

@author: pietro

**Functions:**

- [**raw_figure**](#grass.pygrass.shell.show.raw_figure) –

###### grass.pygrass.shell.show.raw_figure

```python
raw_figure(figpath)
```

#### grass.pygrass.tests

**Modules:**

- [**benchmark**](#grass.pygrass.tests.benchmark) – Created on Sat Jun 16 20:24:56 2012
- [**set_mapset**](#grass.pygrass.tests.set_mapset) – Created on Thu Aug 23 11:07:38 2012

##### grass.pygrass.tests.benchmark

Created on Sat Jun 16 20:24:56 2012

@author: soeren

**Classes:**

- [**OptionParser**](#grass.pygrass.tests.benchmark.OptionParser) –
- [**OptionWithDefault**](#grass.pygrass.tests.benchmark.OptionWithDefault) –

**Functions:**

- [**get_testdict**](#grass.pygrass.tests.benchmark.get_testdict) –
- [**get_testlist**](#grass.pygrass.tests.benchmark.get_testlist) –
- [**get_txt**](#grass.pygrass.tests.benchmark.get_txt) –
- [**main**](#grass.pygrass.tests.benchmark.main) – Main function
- [**mytimer**](#grass.pygrass.tests.benchmark.mytimer) –
- [**print_test**](#grass.pygrass.tests.benchmark.print_test) –
- [**run_benchmark**](#grass.pygrass.tests.benchmark.run_benchmark) –
- [**test\_\_RasterRowIO_row_access\_\_add**](#grass.pygrass.tests.benchmark.test__RasterRowIO_row_access__add) –
- [**test\_\_RasterRowIO_row_access\_\_if**](#grass.pygrass.tests.benchmark.test__RasterRowIO_row_access__if) –
- [**test\_\_RasterRow_row_access\_\_add**](#grass.pygrass.tests.benchmark.test__RasterRow_row_access__add) –
- [**test\_\_RasterRow_row_access\_\_if**](#grass.pygrass.tests.benchmark.test__RasterRow_row_access__if) –
- [**test\_\_RasterRow_value_access\_\_add**](#grass.pygrass.tests.benchmark.test__RasterRow_value_access__add) –
- [**test\_\_RasterRow_value_access\_\_if**](#grass.pygrass.tests.benchmark.test__RasterRow_value_access__if) –
- [**test\_\_RasterSegment_row_access\_\_add**](#grass.pygrass.tests.benchmark.test__RasterSegment_row_access__add) –
- [**test\_\_RasterSegment_row_access\_\_if**](#grass.pygrass.tests.benchmark.test__RasterSegment_row_access__if) –
- [**test\_\_RasterSegment_value_access\_\_add**](#grass.pygrass.tests.benchmark.test__RasterSegment_value_access__add) –
- [**test\_\_RasterSegment_value_access\_\_if**](#grass.pygrass.tests.benchmark.test__RasterSegment_value_access__if) –
- [**test\_\_mapcalc\_\_add**](#grass.pygrass.tests.benchmark.test__mapcalc__add) –
- [**test\_\_mapcalc\_\_if**](#grass.pygrass.tests.benchmark.test__mapcalc__if) –

**Attributes:**

- [**CSV**](#grass.pygrass.tests.benchmark.CSV) –
- [**RST**](#grass.pygrass.tests.benchmark.RST) –
- [**TXT**](#grass.pygrass.tests.benchmark.TXT) –
- [**loc**](#grass.pygrass.tests.benchmark.loc) –
- [**strREQUIRED**](#grass.pygrass.tests.benchmark.strREQUIRED) –
- [**testdict**](#grass.pygrass.tests.benchmark.testdict) –
- [**testlist**](#grass.pygrass.tests.benchmark.testlist) –

###### grass.pygrass.tests.benchmark.CSV

```python
CSV = 'Class; Mode; Operation;\n\n'
```

###### grass.pygrass.tests.benchmark.OptionParser

```python
OptionParser(**kwargs)
```

Bases: <code>[OptionParser](#optparse.OptionParser)</code>

**Functions:**

- [**check_values**](#grass.pygrass.tests.benchmark.OptionParser.check_values) –

####### grass.pygrass.tests.benchmark.OptionParser.check_values

```python
check_values(values, args)
```

###### grass.pygrass.tests.benchmark.OptionWithDefault

```python
OptionWithDefault(*opts, **attrs)
```

Bases: <code>[Option](#optparse.Option)</code>

**Attributes:**

- [**ATTRS**](#grass.pygrass.tests.benchmark.OptionWithDefault.ATTRS) –

####### grass.pygrass.tests.benchmark.OptionWithDefault.ATTRS

```python
ATTRS = optparse.Option.ATTRS + [strREQUIRED]
```

###### grass.pygrass.tests.benchmark.RST

```python
RST = '\n'
```

###### grass.pygrass.tests.benchmark.TXT

```python
TXT = '\n{% for region in regions %}\n{{ \'#\'*60 }}\n# Benchmark cols = {{ region.cols }} rows = {{ region.rows }} cells = {{ region.cells }}\n{{ \'#\'*60 }}\n\n    # equation: c = a + b\n    {% for execmode, operation in region.results.iteritems() %}\n        {{ "%-30s - %5s % 12.6fs"|format(execmode, \'add\', operation.add.time) }}\n    {%- endfor %}\n\n    # equation: c = if a > 50 then 1 else 0\n    {% for execmode, operation in region.results.iteritems() %}\n        {{ "%-30s - %5s % 12.6fs"|format(execmode, \'if\', operation.if.time) }}\n    {%- endfor %}\n{%- endfor %}\n'
```

###### grass.pygrass.tests.benchmark.get_testdict

```python
get_testdict(testlist)
```

###### grass.pygrass.tests.benchmark.get_testlist

```python
get_testlist(loc)
```

###### grass.pygrass.tests.benchmark.get_txt

```python
get_txt(results)
```

###### grass.pygrass.tests.benchmark.loc

```python
loc = locals()
```

###### grass.pygrass.tests.benchmark.main

```python
main(testdict)
```

Main function

###### grass.pygrass.tests.benchmark.mytimer

```python
mytimer(func, runs=1)
```

###### grass.pygrass.tests.benchmark.print_test

```python
print_test(testdict)
```

###### grass.pygrass.tests.benchmark.run_benchmark

```python
run_benchmark(resolution_list, runs, testdict, profile)
```

###### grass.pygrass.tests.benchmark.strREQUIRED

```python
strREQUIRED = 'required'
```

###### grass.pygrass.tests.benchmark.test\_\_RasterRowIO_row_access\_\_add

```python
test__RasterRowIO_row_access__add()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterRowIO_row_access\_\_if

```python
test__RasterRowIO_row_access__if()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterRow_row_access\_\_add

```python
test__RasterRow_row_access__add()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterRow_row_access\_\_if

```python
test__RasterRow_row_access__if()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterRow_value_access\_\_add

```python
test__RasterRow_value_access__add()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterRow_value_access\_\_if

```python
test__RasterRow_value_access__if()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterSegment_row_access\_\_add

```python
test__RasterSegment_row_access__add()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterSegment_row_access\_\_if

```python
test__RasterSegment_row_access__if()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterSegment_value_access\_\_add

```python
test__RasterSegment_value_access__add()
```

###### grass.pygrass.tests.benchmark.test\_\_RasterSegment_value_access\_\_if

```python
test__RasterSegment_value_access__if()
```

###### grass.pygrass.tests.benchmark.test\_\_mapcalc\_\_add

```python
test__mapcalc__add()
```

###### grass.pygrass.tests.benchmark.test\_\_mapcalc\_\_if

```python
test__mapcalc__if()
```

###### grass.pygrass.tests.benchmark.testdict

```python
testdict = get_testdict(testlist)
```

###### grass.pygrass.tests.benchmark.testlist

```python
testlist = get_testlist(loc)
```

##### grass.pygrass.tests.set_mapset

Created on Thu Aug 23 11:07:38 2012

@author: pietro

**Functions:**

- [**main**](#grass.pygrass.tests.set_mapset.main) –
- [**read_gisrc**](#grass.pygrass.tests.set_mapset.read_gisrc) –

###### grass.pygrass.tests.set_mapset.main

```python
main()
```

###### grass.pygrass.tests.set_mapset.read_gisrc

```python
read_gisrc(gisrcpath)
```

#### grass.pygrass.utils

**Functions:**

- [**coor2pixel**](#grass.pygrass.utils.coor2pixel) – Convert coordinates into a pixel row and col
- [**copy**](#grass.pygrass.utils.copy) – Copy a map
- [**create_test_stream_network_map**](#grass.pygrass.utils.create_test_stream_network_map) – Create test data
- [**create_test_vector_map**](#grass.pygrass.utils.create_test_vector_map) – This functions creates a vector map layer with points, lines, boundaries,
- [**decode**](#grass.pygrass.utils.decode) – Decode string coming from c functions,
- [**findfiles**](#grass.pygrass.utils.findfiles) – Return a list of the files
- [**findmaps**](#grass.pygrass.utils.findmaps) – Return a list of tuples containing the names of the:
- [**get_lib_path**](#grass.pygrass.utils.get_lib_path) – Return the path of the libname contained in the module.
- [**get_mapset_raster**](#grass.pygrass.utils.get_mapset_raster) – Return the mapset of the raster map
- [**get_mapset_vector**](#grass.pygrass.utils.get_mapset_vector) – Return the mapset of the vector map
- [**get_raster_for_points**](#grass.pygrass.utils.get_raster_for_points) – Query a raster map for each point feature of a vector
- [**getenv**](#grass.pygrass.utils.getenv) – Return the current grass environment variables
- [**is_clean_name**](#grass.pygrass.utils.is_clean_name) – Return if the name is valid
- [**looking**](#grass.pygrass.utils.looking) – >>> import grass.lib.vector as libvect
- [**pixel2coor**](#grass.pygrass.utils.pixel2coor) – Convert row and col of a pixel into a coordinates
- [**r_export**](#grass.pygrass.utils.r_export) –
- [**remove**](#grass.pygrass.utils.remove) – Remove a map
- [**rename**](#grass.pygrass.utils.rename) – Rename a map
- [**set_path**](#grass.pygrass.utils.set_path) – Set sys.path looking in the the local directory GRASS directories.
- [**split_in_chunk**](#grass.pygrass.utils.split_in_chunk) – Split a list in chunk.
- [**table_exist**](#grass.pygrass.utils.table_exist) – Return True if the table exist False otherwise

**Attributes:**

- [**mset**](#grass.pygrass.utils.mset) –
- [**test_raster_name**](#grass.pygrass.utils.test_raster_name) –
- [**test_vector_name**](#grass.pygrass.utils.test_vector_name) –

##### grass.pygrass.utils.coor2pixel

```python
coor2pixel(coord, region)
```

Convert coordinates into a pixel row and col

> > > from grass.pygrass.gis.region import Region
> > > reg = Region()
> > > coor2pixel((reg.west, reg.north), reg)
> > > (0.0, 0.0)
> > > coor2pixel((reg.east, reg.south), reg) == (reg.rows, reg.cols)
> > > True

##### grass.pygrass.utils.copy

```python
copy(existingmap, newmap, maptype, **kwargs)
```

Copy a map

> > > copy(test_vector_name, "mycensus", "vector")
> > > rename("mycensus", "mynewcensus", "vector")
> > > remove("mynewcensus", "vector")

##### grass.pygrass.utils.create_test_stream_network_map

```python
create_test_stream_network_map(map_name='streams')
```

Create test data

This functions creates a vector map layer with lines that represent
a stream network with two different graphs. The first graph
contains a loop, the second can be used as directed graph.

This should be used in doc and unit tests to create location/mapset
independent vector map layer.

:param map_name: The vector map name that should be used

.. code-block:: none

```
   1(0,2)  3(2,2)
    \     /
   1 \   / 2
      \ /
       2(1,1)
6(0,1) ||  5(2,1)
   5 \ || / 4
      \||/
       4(1,0)
       |
       | 6
       |7(1,-1)

   7(0,-1) 8(2,-1)
    \     /
   8 \   / 9
      \ /
       9(1, -2)
       |
       | 10
       |
      10(1,-3)
```

##### grass.pygrass.utils.create_test_vector_map

```python
create_test_vector_map(map_name='test_vector')
```

This functions creates a vector map layer with points, lines, boundaries,
centroids, areas, isles and attributes for testing purposes

This should be used in doc and unit tests to create location/mapset
independent vector map layer. This map includes 3 points, 3 lines,
11 boundaries and 4 centroids. The attribute table contains cat, name
and value columns.

:param map_name: The vector map name that should be used

.. code-block:: none

```
                           P1 P2 P3
    6                       *  *  *
    5
    4    _______ ___ ___   L1 L2 L3
 Y  3   |A1___ *|  *|  *|   |  |  |
    2   | |A2*| |   |   |   |  |  |
    1   | |___| |A3 |A4 |   |  |  |
    0   |_______|___|___|   |  |  |
   -1
     -1 0 1 2 3 4 5 6 7 8 9 10 12 14
                    X
```

##### grass.pygrass.utils.decode

```python
decode(obj, encoding=None)
```

Decode string coming from c functions,
can be ctypes class String, bytes, or None

##### grass.pygrass.utils.findfiles

```python
findfiles(dirpath, match=None)
```

Return a list of the files

##### grass.pygrass.utils.findmaps

```python
findmaps(type, pattern=None, mapset='', location='', gisdbase='')
```

Return a list of tuples containing the names of the:

- map
- mapset,
- location,
- gisdbase

##### grass.pygrass.utils.get_lib_path

```python
get_lib_path(modname, libname=None)
```

Return the path of the libname contained in the module.

.. deprecated:: 7.1
Use :func:`grass.script.utils.get_lib_path` instead.

##### grass.pygrass.utils.get_mapset_raster

```python
get_mapset_raster(mapname, mapset='')
```

Return the mapset of the raster map

> > > get_mapset_raster(test_raster_name) == getenv("MAPSET")
> > > True

##### grass.pygrass.utils.get_mapset_vector

```python
get_mapset_vector(mapname, mapset='')
```

Return the mapset of the vector map

> > > get_mapset_vector(test_vector_name) == getenv("MAPSET")
> > > True

##### grass.pygrass.utils.get_raster_for_points

```python
get_raster_for_points(poi_vector, raster, column=None, region=None)
```

Query a raster map for each point feature of a vector

Example

> > > from grass.pygrass.raster import RasterRow
> > > from grass.pygrass.gis.region import Region
> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.geometry import Point

Create a vector map

> > > cols = [("cat", "INTEGER PRIMARY KEY"), ("value", "double precision")]
> > > vect = VectorTopo("test_vect_2")
> > > vect.open("w", tab_name="test_vect_2", tab_cols=cols)
> > > vect.write(
> > > ... Point(10, 6),
> > > ... cat=1,
> > > ... attrs=\[
> > > ... 10,
> > > ... \],
> > > ... )
> > > vect.write(
> > > ... Point(12, 6),
> > > ... cat=2,
> > > ... attrs=\[
> > > ... 12,
> > > ... \],
> > > ... )
> > > vect.write(
> > > ... Point(14, 6),
> > > ... cat=3,
> > > ... attrs=\[
> > > ... 14,
> > > ... \],
> > > ... )
> > > vect.table.conn.commit()
> > > vect.close()

Setup the raster sampling

> > > region = Region()
> > > region.from_rast(test_raster_name)
> > > region.set_raster_region()
> > > ele = RasterRow(test_raster_name)

Sample the raster layer at the given points, return a list of values

> > > l = get_raster_for_points(vect, ele, region=region)
> > > l[0] # doctest: +ELLIPSIS
> > > (1, 10.0, 6.0, 1)
> > > l[1] # doctest: +ELLIPSIS
> > > (2, 12.0, 6.0, 1)

Add a new column and sample again

> > > vect.open("r")
> > > vect.table.columns.add(test_raster_name, "double precision")
> > > vect.table.conn.commit()
> > > test_raster_name in vect.table.columns
> > > True
> > > get_raster_for_points(vect, ele, column=test_raster_name, region=region)
> > > True
> > > vect.table.filters.select("value", test_raster_name)
> > > Filters('SELECT value, Utils_test_raster FROM test_vect_2;')
> > > cur = vect.table.execute()
> > > r = cur.fetchall()
> > > r[0] # doctest: +ELLIPSIS
> > > (10.0, 1.0)
> > > r[1] # doctest: +ELLIPSIS
> > > (12.0, 1.0)
> > > remove("test_vect_2", "vect")

:param poi_vector: A VectorTopo object that contains points
:param raster: raster object
:param str column: column name to update in the attrinute table,
if set to None a list of sampled values will be returned
:param region: The region to work with, if not set the current computational region
will be used

:return: True in case of success and a specified column for update,
if column name for update was not set a list of (id, x, y, value) is
returned

##### grass.pygrass.utils.getenv

```python
getenv(env)
```

Return the current grass environment variables

> > > from grass.script.core import gisenv
> > > getenv("MAPSET") == gisenv()["MAPSET"]
> > > True

##### grass.pygrass.utils.is_clean_name

```python
is_clean_name(name)
```

Return if the name is valid

> > > is_clean_name("census")
> > > True
> > > is_clean_name("0census")
> > > True
> > > is_clean_name("census?")
> > > True
> > > is_clean_name("cénsus")
> > > False

##### grass.pygrass.utils.looking

```python
looking(obj, filter_string)
```

> > > import grass.lib.vector as libvect
> > > sorted(looking(libvect, "*by_box*")) # doctest: +NORMALIZE_WHITESPACE
> > > \['Vect_select_areas_by_box', 'Vect_select_isles_by_box',
> > > 'Vect_select_lines_by_box', 'Vect_select_nodes_by_box'\]

##### grass.pygrass.utils.mset

```python
mset = get_mapset_vector(test_vector_name, mapset='')
```

##### grass.pygrass.utils.pixel2coor

```python
pixel2coor(pixel, region)
```

Convert row and col of a pixel into a coordinates

> > > from grass.pygrass.gis.region import Region
> > > reg = Region()
> > > pixel2coor((0, 0), reg) == (reg.north, reg.west)
> > > True
> > > pixel2coor((reg.cols, reg.rows), reg) == (reg.south, reg.east)
> > > True

##### grass.pygrass.utils.r_export

```python
r_export(rast, output='', fmt='png', **kargs)
```

##### grass.pygrass.utils.remove

```python
remove(oldname, maptype)
```

Remove a map

##### grass.pygrass.utils.rename

```python
rename(oldname, newname, maptype, **kwargs)
```

Rename a map

##### grass.pygrass.utils.set_path

```python
set_path(modulename, dirname=None, path='.')
```

Set sys.path looking in the the local directory GRASS directories.

:param modulename: string with the name of the GRASS module
:param dirname: string with the directory name containing the python
libraries, default None
:param path: string with the path to reach the dirname locally.

.. deprecated:: 7.1
Use :func:`grass.script.utils.set_path` instead.

##### grass.pygrass.utils.split_in_chunk

```python
split_in_chunk(iterable, length=10)
```

Split a list in chunk.

> > > for chunk in split_in_chunk(range(25)):
> > > ... print(chunk)
> > > (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
> > > (10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
> > > (20, 21, 22, 23, 24)
> > > for chunk in split_in_chunk(range(25), 3):
> > > ... print(chunk)
> > > (0, 1, 2)
> > > (3, 4, 5)
> > > (6, 7, 8)
> > > (9, 10, 11)
> > > (12, 13, 14)
> > > (15, 16, 17)
> > > (18, 19, 20)
> > > (21, 22, 23)
> > > (24,)

##### grass.pygrass.utils.table_exist

```python
table_exist(cursor, table_name)
```

Return True if the table exist False otherwise

##### grass.pygrass.utils.test_raster_name

```python
test_raster_name = 'Utils_test_raster'
```

##### grass.pygrass.utils.test_vector_name

```python
test_vector_name = 'Utils_test_vector'
```

#### grass.pygrass.vector

**Modules:**

- [**abstract**](#grass.pygrass.vector.abstract) – Created on Fri Aug 17 17:24:03 2012
- [**basic**](#grass.pygrass.vector.basic) – Created on Tue Jul 31 13:06:20 2012
- [**find**](#grass.pygrass.vector.find) – Created on Tue Mar 19 11:09:30 2013
- [**geometry**](#grass.pygrass.vector.geometry) – Created on Wed Jul 18 10:46:25 2012
- [**sql**](#grass.pygrass.vector.sql) – It is a collection of strings to avoid to repeat the code.
- [**table**](#grass.pygrass.vector.table) – Created on Wed Aug 8 15:29:21 2012
- [**vector_type**](#grass.pygrass.vector.vector_type) – Created on Wed Jul 18 10:49:26 2012

**Classes:**

- [**Vector**](#grass.pygrass.vector.Vector) – Vector class is the grass vector format without topology
- [**VectorTopo**](#grass.pygrass.vector.VectorTopo) – Vector class with the support of the GRASS topology.

**Attributes:**

- [**mset**](#grass.pygrass.vector.mset) –
- [**test_vector_name**](#grass.pygrass.vector.test_vector_name) –

##### grass.pygrass.vector.Vector

```python
Vector(name, mapset='', *args, **kwargs)
```

Bases: <code>[Info](#grass.pygrass.vector.abstract.Info)</code>

Vector class is the grass vector format without topology

> > > from grass.pygrass.vector import Vector
> > > test_vect = Vector(test_vector_name)
> > > test_vect.is_open()
> > > False
> > > test_vect.mapset
> > > ''
> > > test_vect.exist()
> > > True
> > > test_vect.overwrite
> > > False

**Functions:**

- [**build**](#grass.pygrass.vector.Vector.build) – Close the vector map and build vector Topology
- [**close**](#grass.pygrass.vector.Vector.close) – Method to close the Vector
- [**exist**](#grass.pygrass.vector.Vector.exist) – Return if the Vector exists or not
- [**has_color_table**](#grass.pygrass.vector.Vector.has_color_table) – Return if vector has color table associated in file system;
- [**is_3D**](#grass.pygrass.vector.Vector.is_3D) – Return if the Vector is 3D
- [**is_open**](#grass.pygrass.vector.Vector.is_open) – Return if the Vector is open
- [**next**](#grass.pygrass.vector.Vector.next) –
- [**open**](#grass.pygrass.vector.Vector.open) – Open a Vector map.
- [**remove**](#grass.pygrass.vector.Vector.remove) – Remove vector map
- [**rename**](#grass.pygrass.vector.Vector.rename) – Method to rename the Vector map
- [**rewind**](#grass.pygrass.vector.Vector.rewind) – Rewind vector map to cause reads to start at beginning.
- [**write**](#grass.pygrass.vector.Vector.write) – Write geometry features and attributes.
- [**write_header**](#grass.pygrass.vector.Vector.write_header) – Save the change in the C struct permanently to disk.

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.Vector.c_mapinfo) –
- [**comment**](#grass.pygrass.vector.Vector.comment) –
- [**date**](#grass.pygrass.vector.Vector.date) –
- [**date_fmt**](#grass.pygrass.vector.Vector.date_fmt) –
- [**full_name**](#grass.pygrass.vector.Vector.full_name) – Return the full name of Vector
- [**map_date**](#grass.pygrass.vector.Vector.map_date) –
- [**mapset**](#grass.pygrass.vector.Vector.mapset) –
- [**maptype**](#grass.pygrass.vector.Vector.maptype) – Return the map type of Vector
- [**mode**](#grass.pygrass.vector.Vector.mode) –
- [**name**](#grass.pygrass.vector.Vector.name) –
- [**organization**](#grass.pygrass.vector.Vector.organization) –
- [**overwrite**](#grass.pygrass.vector.Vector.overwrite) –
- [**person**](#grass.pygrass.vector.Vector.person) –
- [**proj**](#grass.pygrass.vector.Vector.proj) –
- [**proj_name**](#grass.pygrass.vector.Vector.proj_name) – Return the project name of Vector
- [**scale**](#grass.pygrass.vector.Vector.scale) –
- [**thresh**](#grass.pygrass.vector.Vector.thresh) –
- [**title**](#grass.pygrass.vector.Vector.title) –
- [**zone**](#grass.pygrass.vector.Vector.zone) –

###### grass.pygrass.vector.Vector.build

```python
build()
```

Close the vector map and build vector Topology

###### grass.pygrass.vector.Vector.c_mapinfo

```python
c_mapinfo = ctypes.pointer(libvect.Map_info())
```

###### grass.pygrass.vector.Vector.close

```python
close(build=False)
```

Method to close the Vector

:param build: True if the vector map should be build before close it
:type build: bool

###### grass.pygrass.vector.Vector.comment

```python
comment = property(fget=_get_comment, fset=_set_comment, doc='Set or obtain the Vector comment')
```

###### grass.pygrass.vector.Vector.date

```python
date = property(fget=_get_date, fset=_set_date, doc='Set or obtain the Vector date')
```

###### grass.pygrass.vector.Vector.date_fmt

```python
date_fmt = '%a %b  %d %H:%M:%S %Y'
```

###### grass.pygrass.vector.Vector.exist

```python
exist()
```

Return if the Vector exists or not

###### grass.pygrass.vector.Vector.full_name

```python
full_name
```

Return the full name of Vector

###### grass.pygrass.vector.Vector.has_color_table

```python
has_color_table()
```

Return if vector has color table associated in file system;
Color table stored in the vector's attribute table well be not checked

> > > test_vect = Vector(test_vector_name)
> > > test_vect.open(mode="r")
> > > test_vect.has_color_table()
> > > False

> > > test_vect.close()
> > > from grass.pygrass.utils import copy, remove
> > > copy(test_vector_name, "mytest_vect", "vect")
> > > from grass.pygrass.modules.shortcuts import vector as v
> > > v.colors(map="mytest_vect", color="population", column="value")
> > > Module('v.colors')
> > > mytest_vect = Vector("mytest_vect")
> > > mytest_vect.open(mode="r")
> > > mytest_vect.has_color_table()
> > > True
> > > mytest_vect.close()
> > > remove("mytest_vect", "vect")

###### grass.pygrass.vector.Vector.is_3D

```python
is_3D()
```

Return if the Vector is 3D

###### grass.pygrass.vector.Vector.is_open

```python
is_open()
```

Return if the Vector is open

###### grass.pygrass.vector.Vector.map_date

```python
map_date = property(fget=_get_map_date, fset=_set_map_date, doc='Set or obtain the Vector map date')
```

###### grass.pygrass.vector.Vector.mapset

```python
mapset = property(fget=_get_mapset, fset=_set_mapset, doc='Set or obtain the Vector mapset')
```

###### grass.pygrass.vector.Vector.maptype

```python
maptype
```

Return the map type of Vector

###### grass.pygrass.vector.Vector.mode

```python
mode = property(fget=_get_mode, fset=_set_mode)
```

###### grass.pygrass.vector.Vector.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set or obtain the Vector name')
```

###### grass.pygrass.vector.Vector.next

```python
next()
```

###### grass.pygrass.vector.Vector.open

```python
open(mode=None, layer=1, overwrite=None, with_z=None, tab_name='', tab_cols=None, link_name=None, link_key='cat', link_db='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db', link_driver='sqlite')
```

Open a Vector map.

:param mode: open a vector map in `r` in reading, `w` in writing
and in `rw` read and write mode
:type mode: str
:param layer: specify the layer that you want to use
:type layer: int
:param overwrite: valid only for `w` mode
:type overwrite: bool
:param with_z: specify if vector map must be open with third dimension
enabled or not. Valid only for `w` mode,
default: False
:type with_z: bool
:param tab_name: define the name of the table that will be generate
:type tab_name: str
:param tab_cols: define the name and type of the columns of the
attribute table of the vector map
:type tab_cols: list of pairs
:param link_name: define the name of the link connection with the database
:type link_name: str
:param link_key: define the name of the column that will be used as
vector category
:type link_key: str
:param link_db: define the database connection parameters
:type link_db: str
:param link_driver: define witch database driver will be used
:param link_driver: str

Some of the parameters are valid only with mode `w` or `rw`

See more examples in the documentation of the `read` and `write`
methods

###### grass.pygrass.vector.Vector.organization

```python
organization = property(fget=_get_organization, fset=_set_organization, doc='Set or obtain the Vector organization')
```

###### grass.pygrass.vector.Vector.overwrite

```python
overwrite = False
```

###### grass.pygrass.vector.Vector.person

```python
person = property(fget=_get_person, fset=_set_person, doc='Set or obtain the Vector author')
```

###### grass.pygrass.vector.Vector.proj

```python
proj = property(fget=_get_proj, fset=_set_proj, doc='Set or obtain the Vector projection code')
```

###### grass.pygrass.vector.Vector.proj_name

```python
proj_name
```

Return the project name of Vector

###### grass.pygrass.vector.Vector.remove

```python
remove()
```

Remove vector map

###### grass.pygrass.vector.Vector.rename

```python
rename(newname)
```

Method to rename the Vector map

:param newname: the new name for the Vector map
:type newname: str

###### grass.pygrass.vector.Vector.rewind

```python
rewind()
```

Rewind vector map to cause reads to start at beginning.

###### grass.pygrass.vector.Vector.scale

```python
scale = property(fget=_get_scale, fset=_set_scale, doc='Set or obtain the Vector scale')
```

###### grass.pygrass.vector.Vector.thresh

```python
thresh = property(fget=_get_thresh, fset=_set_thresh, doc='Set or obtain the Vector threshold')
```

###### grass.pygrass.vector.Vector.title

```python
title = property(fget=_get_title, fset=_set_title, doc='Set or obtain the Vector title')
```

###### grass.pygrass.vector.Vector.write

```python
write(geo_obj, cat=None, attrs=None)
```

Write geometry features and attributes.

:param geo_obj: a geometry grass object define in
grass.pygrass.vector.geometry
:type geo_obj: geometry GRASS object
:param attrs: a list with the values that will be inserted in the
attribute table.
:type attrs: list
:param cat: The category of the geometry feature, otherwise the
c_cats attribute of the geometry object will be used.
:type cat: integer

Open a new vector map ::

```
>>> new = VectorTopo("newvect")
>>> new.exist()
False
```

define the new columns of the attribute table ::

```
>>> cols = [("cat", "INTEGER PRIMARY KEY"), ("name", "TEXT")]
```

open the vector map in write mode

```
>>> new.open("w", tab_name="newvect", tab_cols=cols)
```

import a geometry feature ::

```
>>> from grass.pygrass.vector.geometry import Point
```

create two points ::

```
>>> point0 = Point(0, 0)
>>> point1 = Point(1, 1)
```

then write the two points on the map, with ::

```
>>> new.write(point0, cat=1, attrs=("pub",))
>>> new.write(point1, cat=2, attrs=("restaurant",))
```

commit the db changes ::

```
>>> new.table.conn.commit()
>>> new.table.execute().fetchall()
[(1, 'pub'), (2, 'restaurant')]
```

close the vector map ::

```
>>> new.close()
>>> new.exist()
True
```

then play with the map ::

```
>>> new.open(mode="r")
>>> new.read(1)
Point(0.000000, 0.000000)
>>> new.read(2)
Point(1.000000, 1.000000)
>>> new.read(1).attrs["name"]
'pub'
>>> new.read(2).attrs["name"]
'restaurant'
>>> new.close()
>>> new.remove()
```

###### grass.pygrass.vector.Vector.write_header

```python
write_header()
```

Save the change in the C struct permanently to disk.

###### grass.pygrass.vector.Vector.zone

```python
zone = property(fget=_get_zone, fset=_set_zone, doc='Set or obtain the Vector projection zone')
```

##### grass.pygrass.vector.VectorTopo

```python
VectorTopo(name, mapset='', *args, **kwargs)
```

Bases: <code>[Vector](#grass.pygrass.vector.Vector)</code>

Vector class with the support of the GRASS topology.

Open a vector map using the *with statement*: ::

```
>>> with VectorTopo(test_vector_name, mode="r") as test_vect:
...     for feature in test_vect[:7]:
...         print(feature.attrs["name"])
...
point
point
point
line
line
line
>>> test_vect.is_open()
False
```

..

**Functions:**

- [**areas_to_wkb_list**](#grass.pygrass.vector.VectorTopo.areas_to_wkb_list) – Return all features of type point, line, boundary or centroid
- [**bbox**](#grass.pygrass.vector.VectorTopo.bbox) – Return the BBox of the vector map
- [**build**](#grass.pygrass.vector.VectorTopo.build) – Close the vector map and build vector Topology
- [**cat**](#grass.pygrass.vector.VectorTopo.cat) – Return the geometry features with category == cat_id.
- [**close**](#grass.pygrass.vector.VectorTopo.close) – Close the VectorTopo map, if release is True, the memory
- [**delete**](#grass.pygrass.vector.VectorTopo.delete) – Remove a feature by its id
- [**exist**](#grass.pygrass.vector.VectorTopo.exist) – Return if the Vector exists or not
- [**features_to_wkb_list**](#grass.pygrass.vector.VectorTopo.features_to_wkb_list) – Return all features of type point, line, boundary or centroid
- [**has_color_table**](#grass.pygrass.vector.VectorTopo.has_color_table) – Return if vector has color table associated in file system;
- [**is_3D**](#grass.pygrass.vector.VectorTopo.is_3D) – Return if the Vector is 3D
- [**is_empty**](#grass.pygrass.vector.VectorTopo.is_empty) – Return if a vector map is empty or not
- [**is_open**](#grass.pygrass.vector.VectorTopo.is_open) – Return if the Vector is open
- [**next**](#grass.pygrass.vector.VectorTopo.next) –
- [**num_primitive_of**](#grass.pygrass.vector.VectorTopo.num_primitive_of) – Return the number of primitive
- [**num_primitives**](#grass.pygrass.vector.VectorTopo.num_primitives) – Return dictionary with the number of all primitives
- [**number_of**](#grass.pygrass.vector.VectorTopo.number_of) – Return the number of the chosen element type
- [**open**](#grass.pygrass.vector.VectorTopo.open) – Open a Vector map.
- [**read**](#grass.pygrass.vector.VectorTopo.read) – Return a geometry object given the feature id.
- [**remove**](#grass.pygrass.vector.VectorTopo.remove) – Remove vector map
- [**rename**](#grass.pygrass.vector.VectorTopo.rename) – Method to rename the Vector map
- [**restore**](#grass.pygrass.vector.VectorTopo.restore) –
- [**rewind**](#grass.pygrass.vector.VectorTopo.rewind) – Rewind vector map to cause reads to start at beginning. ::
- [**rewrite**](#grass.pygrass.vector.VectorTopo.rewrite) – Rewrite a geometry features
- [**table_to_dict**](#grass.pygrass.vector.VectorTopo.table_to_dict) – Return the attribute table as a dictionary with the category as keys
- [**viter**](#grass.pygrass.vector.VectorTopo.viter) – Return an iterator of vector features
- [**write**](#grass.pygrass.vector.VectorTopo.write) – Write geometry features and attributes.
- [**write_header**](#grass.pygrass.vector.VectorTopo.write_header) – Save the change in the C struct permanently to disk.

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.VectorTopo.c_mapinfo) –
- [**comment**](#grass.pygrass.vector.VectorTopo.comment) –
- [**date**](#grass.pygrass.vector.VectorTopo.date) –
- [**date_fmt**](#grass.pygrass.vector.VectorTopo.date_fmt) –
- [**full_name**](#grass.pygrass.vector.VectorTopo.full_name) – Return the full name of Vector
- [**map_date**](#grass.pygrass.vector.VectorTopo.map_date) –
- [**mapset**](#grass.pygrass.vector.VectorTopo.mapset) –
- [**maptype**](#grass.pygrass.vector.VectorTopo.maptype) – Return the map type of Vector
- [**mode**](#grass.pygrass.vector.VectorTopo.mode) –
- [**name**](#grass.pygrass.vector.VectorTopo.name) –
- [**organization**](#grass.pygrass.vector.VectorTopo.organization) –
- [**overwrite**](#grass.pygrass.vector.VectorTopo.overwrite) –
- [**person**](#grass.pygrass.vector.VectorTopo.person) –
- [**proj**](#grass.pygrass.vector.VectorTopo.proj) –
- [**proj_name**](#grass.pygrass.vector.VectorTopo.proj_name) – Return the project name of Vector
- [**scale**](#grass.pygrass.vector.VectorTopo.scale) –
- [**thresh**](#grass.pygrass.vector.VectorTopo.thresh) –
- [**title**](#grass.pygrass.vector.VectorTopo.title) –
- [**zone**](#grass.pygrass.vector.VectorTopo.zone) –

###### grass.pygrass.vector.VectorTopo.areas_to_wkb_list

```python
areas_to_wkb_list(bbox=None, field=1)
```

Return all features of type point, line, boundary or centroid
as a list of Well Known Binary representations (WKB)
(id, cat, wkb) triplets located in a specific
bounding box.

:param bbox: The boundingbox to search for features,
if bbox=None the boundingbox of the whole
vector map layer is used

:type bbox: grass.pygrass.vector.basic.Bbox

:param field: The centroid category field
:type field: integer

:return: A list of triplets, or None if nothing was found

The well known binary are stored in byte arrays.

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

> > > bbox = Bbox(north=20, south=-1, east=20, west=-1)
> > > result = test_vect.areas_to_wkb_list(bbox=bbox)
> > > len(result)
> > > 4
> > > for entry in result:
> > > ... a_id, cat, wkb = entry
> > > ... print((a_id, cat, len(wkb)))
> > > (1, 3, 225)
> > > (2, 3, 141)
> > > (3, 3, 93)
> > > (4, 3, 141)

> > > result = test_vect.areas_to_wkb_list()
> > > len(result)
> > > 4
> > > for entry in result:
> > > ... a_id, cat, wkb = entry
> > > ... print((a_id, cat, len(wkb)))
> > > (1, 3, 225)
> > > (2, 3, 141)
> > > (3, 3, 93)
> > > (4, 3, 141)

> > > test_vect.close()

###### grass.pygrass.vector.VectorTopo.bbox

```python
bbox()
```

Return the BBox of the vector map

###### grass.pygrass.vector.VectorTopo.build

```python
build()
```

Close the vector map and build vector Topology

###### grass.pygrass.vector.VectorTopo.c_mapinfo

```python
c_mapinfo = ctypes.pointer(libvect.Map_info())
```

###### grass.pygrass.vector.VectorTopo.cat

```python
cat(cat_id, vtype, layer=None, generator=False, geo=None)
```

Return the geometry features with category == cat_id.

:param cat_id: the category number
:type cat_id: int
:param vtype: the type of geometry feature that we are looking for
:type vtype: str
:param layer: the layer number that will be used
:type layer: int
:param generator: if True return a generator otherwise it return a
list of features
:type generator: bool

###### grass.pygrass.vector.VectorTopo.close

```python
close(build=True, release=True)
```

Close the VectorTopo map, if release is True, the memory
occupied by spatial index is released

###### grass.pygrass.vector.VectorTopo.comment

```python
comment = property(fget=_get_comment, fset=_set_comment, doc='Set or obtain the Vector comment')
```

###### grass.pygrass.vector.VectorTopo.date

```python
date = property(fget=_get_date, fset=_set_date, doc='Set or obtain the Vector date')
```

###### grass.pygrass.vector.VectorTopo.date_fmt

```python
date_fmt = '%a %b  %d %H:%M:%S %Y'
```

###### grass.pygrass.vector.VectorTopo.delete

```python
delete(feature_id)
```

Remove a feature by its id

:param feature_id: the id of the feature
:type feature_id: int

###### grass.pygrass.vector.VectorTopo.exist

```python
exist()
```

Return if the Vector exists or not

###### grass.pygrass.vector.VectorTopo.features_to_wkb_list

```python
features_to_wkb_list(bbox=None, feature_type='point', field=1)
```

Return all features of type point, line, boundary or centroid
as a list of Well Known Binary representations (WKB)
(id, cat, wkb) triplets located in a specific
bounding box.

:param bbox: The boundingbox to search for features,
if bbox=None the boundingbox of the whole
vector map layer is used

:type bbox: grass.pygrass.vector.basic.Bbox

:param feature_type: The type of feature that should be converted to
the Well Known Binary (WKB) format. Supported are:
'point' -> libvect.GV_POINT 1
'line' -> libvect.GV_LINE 2
'boundary' -> libvect.GV_BOUNDARY 3
'centroid' -> libvect.GV_CENTROID 4
:type type: string

:param field: The category field
:type field: integer

:return: A list of triplets, or None if nothing was found

The well known binary are stored in byte arrays.

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

> > > bbox = Bbox(north=20, south=-1, east=20, west=-1)
> > > result = test_vect.features_to_wkb_list(bbox=bbox, feature_type="point")
> > > len(result)
> > > 3
> > > for entry in result:
> > > ... f_id, cat, wkb = entry
> > > ... print((f_id, cat, len(wkb)))
> > > (1, 1, 21)
> > > (2, 1, 21)
> > > (3, 1, 21)

> > > result = test_vect.features_to_wkb_list(bbox=None, feature_type="line")
> > > len(result)
> > > 3
> > > for entry in result:
> > > ... f_id, cat, wkb = entry
> > > ... print((f_id, cat, len(wkb)))
> > > (4, 2, 57)
> > > (5, 2, 57)
> > > (6, 2, 57)

> > > result = test_vect.features_to_wkb_list(bbox=bbox, feature_type="boundary")
> > > len(result)
> > > 11

> > > result = test_vect.features_to_wkb_list(bbox=None, feature_type="centroid")
> > > len(result)
> > > 4

> > > for entry in result:
> > > ... f_id, cat, wkb = entry
> > > ... print((f_id, cat, len(wkb)))
> > > (19, 3, 21)
> > > (18, 3, 21)
> > > (20, 3, 21)
> > > (21, 3, 21)

> > > result = test_vect.features_to_wkb_list(bbox=bbox, feature_type="blub")
> > > Traceback (most recent call last):
> > > ...
> > > grass.exceptions.GrassError: Unsupported feature type <blub>, supported are \<point,line,boundary,centroid>

> > > test_vect.close()

###### grass.pygrass.vector.VectorTopo.full_name

```python
full_name
```

Return the full name of Vector

###### grass.pygrass.vector.VectorTopo.has_color_table

```python
has_color_table()
```

Return if vector has color table associated in file system;
Color table stored in the vector's attribute table well be not checked

> > > test_vect = Vector(test_vector_name)
> > > test_vect.open(mode="r")
> > > test_vect.has_color_table()
> > > False

> > > test_vect.close()
> > > from grass.pygrass.utils import copy, remove
> > > copy(test_vector_name, "mytest_vect", "vect")
> > > from grass.pygrass.modules.shortcuts import vector as v
> > > v.colors(map="mytest_vect", color="population", column="value")
> > > Module('v.colors')
> > > mytest_vect = Vector("mytest_vect")
> > > mytest_vect.open(mode="r")
> > > mytest_vect.has_color_table()
> > > True
> > > mytest_vect.close()
> > > remove("mytest_vect", "vect")

###### grass.pygrass.vector.VectorTopo.is_3D

```python
is_3D()
```

Return if the Vector is 3D

###### grass.pygrass.vector.VectorTopo.is_empty

```python
is_empty()
```

Return if a vector map is empty or not

###### grass.pygrass.vector.VectorTopo.is_open

```python
is_open()
```

Return if the Vector is open

###### grass.pygrass.vector.VectorTopo.map_date

```python
map_date = property(fget=_get_map_date, fset=_set_map_date, doc='Set or obtain the Vector map date')
```

###### grass.pygrass.vector.VectorTopo.mapset

```python
mapset = property(fget=_get_mapset, fset=_set_mapset, doc='Set or obtain the Vector mapset')
```

###### grass.pygrass.vector.VectorTopo.maptype

```python
maptype
```

Return the map type of Vector

###### grass.pygrass.vector.VectorTopo.mode

```python
mode = property(fget=_get_mode, fset=_set_mode)
```

###### grass.pygrass.vector.VectorTopo.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set or obtain the Vector name')
```

###### grass.pygrass.vector.VectorTopo.next

```python
next()
```

###### grass.pygrass.vector.VectorTopo.num_primitive_of

```python
num_primitive_of(primitive)
```

Return the number of primitive

:param primitive: the name of primitive to query; the supported values are:

```
                * *boundary*,
                * *centroid*,
                * *face*,
                * *kernel*,
                * *line*,
                * *point*
                * *area*
                * *volume*
```

:type primitive: str

::

```
>>> test_vect = VectorTopo(test_vector_name)
>>> test_vect.open(mode="r")
>>> test_vect.num_primitive_of("point")
3
>>> test_vect.num_primitive_of("line")
3
>>> test_vect.num_primitive_of("centroid")
4
>>> test_vect.num_primitive_of("boundary")
11
>>> test_vect.close()
```

..

###### grass.pygrass.vector.VectorTopo.num_primitives

```python
num_primitives()
```

Return dictionary with the number of all primitives

###### grass.pygrass.vector.VectorTopo.number_of

```python
number_of(vtype)
```

Return the number of the chosen element type

:param vtype: the name of type to query; the supported values are:
*areas*, *dblinks*, *faces*, *holes*, *islands*,
*kernels*, *points*, *lines*, *centroids*, *boundaries*,
*nodes*, *line_points*, *update_lines*, *update_nodes*,
*volumes*
:type vtype: str

```
>>> test_vect = VectorTopo(test_vector_name)
>>> test_vect.open(mode="r")
>>> test_vect.number_of("areas")
4
>>> test_vect.number_of("islands")
2
>>> test_vect.number_of("holes")
0
>>> test_vect.number_of("lines")
3
>>> test_vect.number_of("nodes")
15
>>> test_vect.number_of("pizza")
... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: vtype not supported, use one of: 'areas', ...
>>> test_vect.close()
```

..

###### grass.pygrass.vector.VectorTopo.open

```python
open(mode=None, layer=1, overwrite=None, with_z=None, tab_name='', tab_cols=None, link_name=None, link_key='cat', link_db='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db', link_driver='sqlite')
```

Open a Vector map.

:param mode: open a vector map in `r` in reading, `w` in writing
and in `rw` read and write mode
:type mode: str
:param layer: specify the layer that you want to use
:type layer: int
:param overwrite: valid only for `w` mode
:type overwrite: bool
:param with_z: specify if vector map must be open with third dimension
enabled or not. Valid only for `w` mode,
default: False
:type with_z: bool
:param tab_name: define the name of the table that will be generate
:type tab_name: str
:param tab_cols: define the name and type of the columns of the
attribute table of the vector map
:type tab_cols: list of pairs
:param link_name: define the name of the link connection with the database
:type link_name: str
:param link_key: define the name of the column that will be used as
vector category
:type link_key: str
:param link_db: define the database connection parameters
:type link_db: str
:param link_driver: define witch database driver will be used
:param link_driver: str

Some of the parameters are valid only with mode `w` or `rw`

See more examples in the documentation of the `read` and `write`
methods

###### grass.pygrass.vector.VectorTopo.organization

```python
organization = property(fget=_get_organization, fset=_set_organization, doc='Set or obtain the Vector organization')
```

###### grass.pygrass.vector.VectorTopo.overwrite

```python
overwrite = False
```

###### grass.pygrass.vector.VectorTopo.person

```python
person = property(fget=_get_person, fset=_set_person, doc='Set or obtain the Vector author')
```

###### grass.pygrass.vector.VectorTopo.proj

```python
proj = property(fget=_get_proj, fset=_set_proj, doc='Set or obtain the Vector projection code')
```

###### grass.pygrass.vector.VectorTopo.proj_name

```python
proj_name
```

Return the project name of Vector

###### grass.pygrass.vector.VectorTopo.read

```python
read(feature_id)
```

Return a geometry object given the feature id.

:param int feature_id: the id of feature to obtain

> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open(mode="r")
> > > feature1 = test_vect.read(0) # doctest: +ELLIPSIS
> > > Traceback (most recent call last):
> > > ...
> > > ValueError: The index must be >0, 0 given.
> > > feature1 = test_vect.read(5)
> > > feature1
> > > Line([Point(12.000000, 4.000000), Point(12.000000, 2.000000), Point(12.000000, 0.000000)])
> > > feature1.length()
> > > 4.0
> > > test_vect.read(-1)
> > > Centroid(7.500000, 3.500000)
> > > len(test_vect)
> > > 21
> > > test_vect.read(21)
> > > Centroid(7.500000, 3.500000)
> > > test_vect.read(22) # doctest: +ELLIPSIS
> > > Traceback (most recent call last):
> > > ...
> > > IndexError: Index out of range
> > > test_vect.close()

###### grass.pygrass.vector.VectorTopo.remove

```python
remove()
```

Remove vector map

###### grass.pygrass.vector.VectorTopo.rename

```python
rename(newname)
```

Method to rename the Vector map

:param newname: the new name for the Vector map
:type newname: str

###### grass.pygrass.vector.VectorTopo.restore

```python
restore(geo_obj)
```

###### grass.pygrass.vector.VectorTopo.rewind

```python
rewind()
```

Rewind vector map to cause reads to start at beginning. ::

```
>>> test_vect = VectorTopo(test_vector_name)
>>> test_vect.open(mode="r")
>>> test_vect.next()
Point(10.000000, 6.000000)
>>> test_vect.next()
Point(12.000000, 6.000000)
>>> test_vect.next()
Point(14.000000, 6.000000)
>>> test_vect.rewind()
>>> test_vect.next()
Point(10.000000, 6.000000)
>>> test_vect.close()
```

..

###### grass.pygrass.vector.VectorTopo.rewrite

```python
rewrite(geo_obj, cat, attrs=None, **kargs)
```

Rewrite a geometry features

```
>>> cols = [("cat", "INTEGER PRIMARY KEY"), ("name", "TEXT")]
```

Generate a new vector map

```
>>> test_vect = VectorTopo("newvect_2")
>>> test_vect.open("w", tab_name="newvect_2", tab_cols=cols, overwrite=True)
```

import a geometry feature ::

```
>>> from grass.pygrass.vector.geometry import Point
```

create two points ::

```
>>> point0 = Point(0, 0)
>>> point1 = Point(1, 1)
>>> point2 = Point(2, 2)
```

then write the two points on the map, with ::

```
>>> test_vect.write(point0, cat=1, attrs=("pub",))
>>> test_vect.write(point1, cat=2, attrs=("restaurant",))
>>> test_vect.table.conn.commit()  # save changes in the DB
>>> test_vect.table_to_dict()
{1: [1, 'pub'], 2: [2, 'restaurant']}
>>> test_vect.close()
```

Now rewrite one point of the vector map: ::

```
>>> test_vect.open("rw")
>>> test_vect.rewrite(point2, cat=1, attrs=("Irish Pub",))
>>> test_vect.table.conn.commit()  # save changes in the DB
>>> test_vect.close()
```

Check the output:

```
>>> test_vect.open("r")
>>> test_vect[1] == point2
True
>>> test_vect[1].attrs["name"] == "Irish Pub"
True
>>> test_vect.close()
>>> test_vect.remove()
```

###### grass.pygrass.vector.VectorTopo.scale

```python
scale = property(fget=_get_scale, fset=_set_scale, doc='Set or obtain the Vector scale')
```

###### grass.pygrass.vector.VectorTopo.table_to_dict

```python
table_to_dict(where=None)
```

Return the attribute table as a dictionary with the category as keys

The columns have the order of the self.table.columns.names() list.

Examples

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

> > > test_vect.table_to_dict()
> > > {1: [1, 'point', 1.0], 2: [2, 'line', 2.0], 3: [3, 'centroid', 3.0]}

> > > test_vect.table_to_dict(where="value > 2")
> > > {3: [3, 'centroid', 3.0]}

> > > test_vect.table_to_dict(where="value > 0")
> > > {1: [1, 'point', 1.0], 2: [2, 'line', 2.0], 3: [3, 'centroid', 3.0]}

> > > test_vect.table.filters.get_sql()
> > > 'SELECT cat,name,value FROM vector_doctest_map WHERE value > 0 ORDER BY cat;'

###### grass.pygrass.vector.VectorTopo.thresh

```python
thresh = property(fget=_get_thresh, fset=_set_thresh, doc='Set or obtain the Vector threshold')
```

###### grass.pygrass.vector.VectorTopo.title

```python
title = property(fget=_get_title, fset=_set_title, doc='Set or obtain the Vector title')
```

###### grass.pygrass.vector.VectorTopo.viter

```python
viter(vtype, idonly=False)
```

Return an iterator of vector features

:param vtype: the name of type to query; the supported values are:
*areas*, *dblinks*, *faces*, *holes*, *islands*,
*kernels*, *line_points*, *lines*, *nodes*, *points*,
*update_lines*, *update_nodes*, *volumes*
:type vtype: str
:param idonly: variable to return only the id of features instead of
full features
:type idonly: bool

```
>>> test_vect = VectorTopo(test_vector_name, mode="r")
>>> test_vect.open(mode="r")
>>> areas = [area for area in test_vect.viter("areas")]
>>> areas[:3]
[Area(1), Area(2), Area(3)]
```

to sort the result in an efficient way, use: ::

```
>>> from operator import methodcaller as method
>>> areas.sort(key=method("area"), reverse=True)  # sort the list
>>> for area in areas[:3]:
...     print(area, area.area())
Area(1) 12.0
Area(2) 8.0
Area(4) 8.0

>>> areas = [area for area in test_vect.viter("areas")]
>>> for area in areas:
...     print(area.centroid().cat)
...
3
3
3
3

>>> test_vect.close()
```

###### grass.pygrass.vector.VectorTopo.write

```python
write(geo_obj, cat=None, attrs=None)
```

Write geometry features and attributes.

:param geo_obj: a geometry grass object define in
grass.pygrass.vector.geometry
:type geo_obj: geometry GRASS object
:param attrs: a list with the values that will be inserted in the
attribute table.
:type attrs: list
:param cat: The category of the geometry feature, otherwise the
c_cats attribute of the geometry object will be used.
:type cat: integer

Open a new vector map ::

```
>>> new = VectorTopo("newvect")
>>> new.exist()
False
```

define the new columns of the attribute table ::

```
>>> cols = [("cat", "INTEGER PRIMARY KEY"), ("name", "TEXT")]
```

open the vector map in write mode

```
>>> new.open("w", tab_name="newvect", tab_cols=cols)
```

import a geometry feature ::

```
>>> from grass.pygrass.vector.geometry import Point
```

create two points ::

```
>>> point0 = Point(0, 0)
>>> point1 = Point(1, 1)
```

then write the two points on the map, with ::

```
>>> new.write(point0, cat=1, attrs=("pub",))
>>> new.write(point1, cat=2, attrs=("restaurant",))
```

commit the db changes ::

```
>>> new.table.conn.commit()
>>> new.table.execute().fetchall()
[(1, 'pub'), (2, 'restaurant')]
```

close the vector map ::

```
>>> new.close()
>>> new.exist()
True
```

then play with the map ::

```
>>> new.open(mode="r")
>>> new.read(1)
Point(0.000000, 0.000000)
>>> new.read(2)
Point(1.000000, 1.000000)
>>> new.read(1).attrs["name"]
'pub'
>>> new.read(2).attrs["name"]
'restaurant'
>>> new.close()
>>> new.remove()
```

###### grass.pygrass.vector.VectorTopo.write_header

```python
write_header()
```

Save the change in the C struct permanently to disk.

###### grass.pygrass.vector.VectorTopo.zone

```python
zone = property(fget=_get_zone, fset=_set_zone, doc='Set or obtain the Vector projection zone')
```

##### grass.pygrass.vector.abstract

Created on Fri Aug 17 17:24:03 2012

@author: pietro

**Classes:**

- [**Info**](#grass.pygrass.vector.abstract.Info) – Basic vector info.

**Functions:**

- [**is_open**](#grass.pygrass.vector.abstract.is_open) – Return if the Vector is open

**Attributes:**

- [**test_vector_name**](#grass.pygrass.vector.abstract.test_vector_name) –

###### grass.pygrass.vector.abstract.Info

```python
Info(name, mapset='', *aopen, **kwopen)
```

Basic vector info.
To get access to the vector info the map must be opened. ::

```
>>> test_vect = Info(test_vector_name)
>>> test_vect.open(mode='r')
```

Then it is possible to read and write the following map attributes: ::

```
>>> test_vect.organization
'Thuenen Institut'
>>> test_vect.person
'Soeren Gebbert'
>>> test_vect.title
'Test dataset'
>>> test_vect.scale
1
>>> test_vect.comment
'This is a comment'
>>> test_vect.comment = "One useful comment!"
>>> test_vect.comment
'One useful comment!'
```

There are some read only attributes: ::

```
>>> test_vect.maptype
'native'
```

And some basic methods: ::

```
>>> test_vect.is_3D()
False
>>> test_vect.exist()
True
>>> test_vect.is_open()
True
>>> test_vect.close()
```

**Functions:**

- [**build**](#grass.pygrass.vector.abstract.Info.build) – Close the vector map and build vector Topology
- [**close**](#grass.pygrass.vector.abstract.Info.close) – Method to close the Vector
- [**exist**](#grass.pygrass.vector.abstract.Info.exist) – Return if the Vector exists or not
- [**is_3D**](#grass.pygrass.vector.abstract.Info.is_3D) – Return if the Vector is 3D
- [**is_open**](#grass.pygrass.vector.abstract.Info.is_open) – Return if the Vector is open
- [**open**](#grass.pygrass.vector.abstract.Info.open) – Open a Vector map.
- [**remove**](#grass.pygrass.vector.abstract.Info.remove) – Remove vector map
- [**rename**](#grass.pygrass.vector.abstract.Info.rename) – Method to rename the Vector map
- [**write_header**](#grass.pygrass.vector.abstract.Info.write_header) – Save the change in the C struct permanently to disk.

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.abstract.Info.c_mapinfo) –
- [**comment**](#grass.pygrass.vector.abstract.Info.comment) –
- [**date**](#grass.pygrass.vector.abstract.Info.date) –
- [**date_fmt**](#grass.pygrass.vector.abstract.Info.date_fmt) –
- [**full_name**](#grass.pygrass.vector.abstract.Info.full_name) – Return the full name of Vector
- [**map_date**](#grass.pygrass.vector.abstract.Info.map_date) –
- [**mapset**](#grass.pygrass.vector.abstract.Info.mapset) –
- [**maptype**](#grass.pygrass.vector.abstract.Info.maptype) – Return the map type of Vector
- [**mode**](#grass.pygrass.vector.abstract.Info.mode) –
- [**name**](#grass.pygrass.vector.abstract.Info.name) –
- [**organization**](#grass.pygrass.vector.abstract.Info.organization) –
- [**overwrite**](#grass.pygrass.vector.abstract.Info.overwrite) –
- [**person**](#grass.pygrass.vector.abstract.Info.person) –
- [**proj**](#grass.pygrass.vector.abstract.Info.proj) –
- [**proj_name**](#grass.pygrass.vector.abstract.Info.proj_name) – Return the project name of Vector
- [**scale**](#grass.pygrass.vector.abstract.Info.scale) –
- [**thresh**](#grass.pygrass.vector.abstract.Info.thresh) –
- [**title**](#grass.pygrass.vector.abstract.Info.title) –
- [**zone**](#grass.pygrass.vector.abstract.Info.zone) –

####### grass.pygrass.vector.abstract.Info.build

```python
build()
```

Close the vector map and build vector Topology

####### grass.pygrass.vector.abstract.Info.c_mapinfo

```python
c_mapinfo = ctypes.pointer(libvect.Map_info())
```

####### grass.pygrass.vector.abstract.Info.close

```python
close(build=False)
```

Method to close the Vector

:param build: True if the vector map should be build before close it
:type build: bool

####### grass.pygrass.vector.abstract.Info.comment

```python
comment = property(fget=_get_comment, fset=_set_comment, doc='Set or obtain the Vector comment')
```

####### grass.pygrass.vector.abstract.Info.date

```python
date = property(fget=_get_date, fset=_set_date, doc='Set or obtain the Vector date')
```

####### grass.pygrass.vector.abstract.Info.date_fmt

```python
date_fmt = '%a %b  %d %H:%M:%S %Y'
```

####### grass.pygrass.vector.abstract.Info.exist

```python
exist()
```

Return if the Vector exists or not

####### grass.pygrass.vector.abstract.Info.full_name

```python
full_name
```

Return the full name of Vector

####### grass.pygrass.vector.abstract.Info.is_3D

```python
is_3D()
```

Return if the Vector is 3D

####### grass.pygrass.vector.abstract.Info.is_open

```python
is_open()
```

Return if the Vector is open

####### grass.pygrass.vector.abstract.Info.map_date

```python
map_date = property(fget=_get_map_date, fset=_set_map_date, doc='Set or obtain the Vector map date')
```

####### grass.pygrass.vector.abstract.Info.mapset

```python
mapset = property(fget=_get_mapset, fset=_set_mapset, doc='Set or obtain the Vector mapset')
```

####### grass.pygrass.vector.abstract.Info.maptype

```python
maptype
```

Return the map type of Vector

####### grass.pygrass.vector.abstract.Info.mode

```python
mode = property(fget=_get_mode, fset=_set_mode)
```

####### grass.pygrass.vector.abstract.Info.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set or obtain the Vector name')
```

####### grass.pygrass.vector.abstract.Info.open

```python
open(mode=None, layer=1, overwrite=None, with_z=None, tab_name='', tab_cols=None, link_name=None, link_key='cat', link_db='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db', link_driver='sqlite')
```

Open a Vector map.

:param mode: open a vector map in `r` in reading, `w` in writing
and in `rw` read and write mode
:type mode: str
:param layer: specify the layer that you want to use
:type layer: int
:param overwrite: valid only for `w` mode
:type overwrite: bool
:param with_z: specify if vector map must be open with third dimension
enabled or not. Valid only for `w` mode,
default: False
:type with_z: bool
:param tab_name: define the name of the table that will be generate
:type tab_name: str
:param tab_cols: define the name and type of the columns of the
attribute table of the vector map
:type tab_cols: list of pairs
:param link_name: define the name of the link connection with the database
:type link_name: str
:param link_key: define the name of the column that will be used as
vector category
:type link_key: str
:param link_db: define the database connection parameters
:type link_db: str
:param link_driver: define witch database driver will be used
:param link_driver: str

Some of the parameters are valid only with mode `w` or `rw`

See more examples in the documentation of the `read` and `write`
methods

####### grass.pygrass.vector.abstract.Info.organization

```python
organization = property(fget=_get_organization, fset=_set_organization, doc='Set or obtain the Vector organization')
```

####### grass.pygrass.vector.abstract.Info.overwrite

```python
overwrite = False
```

####### grass.pygrass.vector.abstract.Info.person

```python
person = property(fget=_get_person, fset=_set_person, doc='Set or obtain the Vector author')
```

####### grass.pygrass.vector.abstract.Info.proj

```python
proj = property(fget=_get_proj, fset=_set_proj, doc='Set or obtain the Vector projection code')
```

####### grass.pygrass.vector.abstract.Info.proj_name

```python
proj_name
```

Return the project name of Vector

####### grass.pygrass.vector.abstract.Info.remove

```python
remove()
```

Remove vector map

####### grass.pygrass.vector.abstract.Info.rename

```python
rename(newname)
```

Method to rename the Vector map

:param newname: the new name for the Vector map
:type newname: str

####### grass.pygrass.vector.abstract.Info.scale

```python
scale = property(fget=_get_scale, fset=_set_scale, doc='Set or obtain the Vector scale')
```

####### grass.pygrass.vector.abstract.Info.thresh

```python
thresh = property(fget=_get_thresh, fset=_set_thresh, doc='Set or obtain the Vector threshold')
```

####### grass.pygrass.vector.abstract.Info.title

```python
title = property(fget=_get_title, fset=_set_title, doc='Set or obtain the Vector title')
```

####### grass.pygrass.vector.abstract.Info.write_header

```python
write_header()
```

Save the change in the C struct permanently to disk.

####### grass.pygrass.vector.abstract.Info.zone

```python
zone = property(fget=_get_zone, fset=_set_zone, doc='Set or obtain the Vector projection zone')
```

###### grass.pygrass.vector.abstract.is_open

```python
is_open(c_mapinfo)
```

Return if the Vector is open

###### grass.pygrass.vector.abstract.test_vector_name

```python
test_vector_name = 'abstract_doctest_map'
```

##### grass.pygrass.vector.basic

Created on Tue Jul 31 13:06:20 2012

@author: pietro

**Classes:**

- [**Bbox**](#grass.pygrass.vector.basic.Bbox) – Instantiate a Bounding Box class that contains
- [**BoxList**](#grass.pygrass.vector.basic.BoxList) – Instantiate a BoxList class to create a list of Bounding Box
- [**Cats**](#grass.pygrass.vector.basic.Cats) – Instantiate a Category class that contains a ctypes pointer
- [**CatsList**](#grass.pygrass.vector.basic.CatsList) – >>> cats_list = CatsList()
- [**Ilist**](#grass.pygrass.vector.basic.Ilist) – Instantiate a list of integer using the C GRASS struct `ilist`,

###### grass.pygrass.vector.basic.Bbox

```python
Bbox(north=0, south=0, east=0, west=0, top=0, bottom=0)
```

Instantiate a Bounding Box class that contains
a ctypes pointer to the C struct bound_box, that could be used
by C GRASS functions.

> > > bbox = Bbox()
> > > bbox
> > > Bbox(0.0, 0.0, 0.0, 0.0)

The default parameters are 0. It is possible to set or change
the parameters later, with:

> > > bbox.north = 10
> > > bbox.south = -10
> > > bbox.east = -20
> > > bbox.west = 20
> > > bbox
> > > Bbox(10.0, -10.0, -20.0, 20.0)

Or directly istantiate the class with the values, with:

> > > bbox = Bbox(north=100, south=0, east=0, west=100)
> > > bbox
> > > Bbox(100.0, 0.0, 0.0, 100.0)

..

**Functions:**

- [**contains**](#grass.pygrass.vector.basic.Bbox.contains) – Return True if the object is contained by the BoundingBox
- [**items**](#grass.pygrass.vector.basic.Bbox.items) –
- [**keys**](#grass.pygrass.vector.basic.Bbox.keys) –
- [**nsewtb**](#grass.pygrass.vector.basic.Bbox.nsewtb) – Return a list of values from bounding box

**Attributes:**

- [**bottom**](#grass.pygrass.vector.basic.Bbox.bottom) –
- [**c_bbox**](#grass.pygrass.vector.basic.Bbox.c_bbox) –
- [**east**](#grass.pygrass.vector.basic.Bbox.east) –
- [**north**](#grass.pygrass.vector.basic.Bbox.north) –
- [**south**](#grass.pygrass.vector.basic.Bbox.south) –
- [**top**](#grass.pygrass.vector.basic.Bbox.top) –
- [**west**](#grass.pygrass.vector.basic.Bbox.west) –

####### grass.pygrass.vector.basic.Bbox.bottom

```python
bottom = property(fget=_get_b, fset=_set_b, doc='Set and obtain bottom value')
```

####### grass.pygrass.vector.basic.Bbox.c_bbox

```python
c_bbox = ctypes.pointer(libvect.bound_box())
```

####### grass.pygrass.vector.basic.Bbox.contains

```python
contains(point)
```

Return True if the object is contained by the BoundingBox

:param point: the point to analyze
:type point: a Point object or a tuple with the coordinates

> > > from grass.pygrass.vector.geometry import Point
> > > poi = Point(5, 5)
> > > bbox = Bbox(north=10, south=0, west=0, east=10)
> > > bbox.contains(poi)
> > > True

####### grass.pygrass.vector.basic.Bbox.east

```python
east = property(fget=_get_e, fset=_set_e, doc='Set and obtain east value')
```

####### grass.pygrass.vector.basic.Bbox.items

```python
items()
```

####### grass.pygrass.vector.basic.Bbox.keys

```python
keys()
```

####### grass.pygrass.vector.basic.Bbox.north

```python
north = property(fget=_get_n, fset=_set_n, doc='Set and obtain north value')
```

####### grass.pygrass.vector.basic.Bbox.nsewtb

```python
nsewtb(tb=True)
```

Return a list of values from bounding box

:param tb: if tb parameter is False return only: north, south, east,
west and not top and bottom
:type tb: bool

####### grass.pygrass.vector.basic.Bbox.south

```python
south = property(fget=_get_s, fset=_set_s, doc='Set and obtain south value')
```

####### grass.pygrass.vector.basic.Bbox.top

```python
top = property(fget=_get_t, fset=_set_t, doc='Set and obtain top value')
```

####### grass.pygrass.vector.basic.Bbox.west

```python
west = property(fget=_get_w, fset=_set_w, doc='Set and obtain west value')
```

###### grass.pygrass.vector.basic.BoxList

```python
BoxList(boxlist=None)
```

Instantiate a BoxList class to create a list of Bounding Box

**Functions:**

- [**append**](#grass.pygrass.vector.basic.BoxList.append) – Append a Bbox object to a Boxlist object, using the
- [**have_boxes**](#grass.pygrass.vector.basic.BoxList.have_boxes) –
- [**remove**](#grass.pygrass.vector.basic.BoxList.remove) – Remove Bbox from the boxlist, given an integer or a list of integer
- [**reset**](#grass.pygrass.vector.basic.BoxList.reset) – Reset the c_boxlist C struct, using the `Vect_reset_boxlist` C

**Attributes:**

- [**c_boxlist**](#grass.pygrass.vector.basic.BoxList.c_boxlist) –
- [**ids**](#grass.pygrass.vector.basic.BoxList.ids) –
- [**n_values**](#grass.pygrass.vector.basic.BoxList.n_values) –

####### grass.pygrass.vector.basic.BoxList.append

```python
append(box)
```

Append a Bbox object to a Boxlist object, using the
`Vect_boxlist_append` C function.

:param bbox: the bounding box to add to the list
:param bbox: a Bbox object

> > > box0 = Bbox()
> > > box1 = Bbox(1, 2, 3, 4)
> > > box2 = Bbox(5, 6, 7, 8)
> > > boxlist = BoxList([box0, box1])
> > > boxlist
> > > Boxlist([Bbox(0.0, 0.0, 0.0, 0.0), Bbox(1.0, 2.0, 3.0, 4.0)])
> > > len(boxlist)
> > > 2
> > > boxlist.append(box2)
> > > len(boxlist)
> > > 3

####### grass.pygrass.vector.basic.BoxList.c_boxlist

```python
c_boxlist = ctypes.pointer(libvect.boxlist())
```

####### grass.pygrass.vector.basic.BoxList.have_boxes

```python
have_boxes()
```

####### grass.pygrass.vector.basic.BoxList.ids

```python
ids
```

####### grass.pygrass.vector.basic.BoxList.n_values

```python
n_values
```

####### grass.pygrass.vector.basic.BoxList.remove

```python
remove(indx)
```

Remove Bbox from the boxlist, given an integer or a list of integer
or a boxlist, using `Vect_boxlist_delete` C function or the
`Vect_boxlist_delete_boxlist`.

:param indx: the index value of the Bbox to remove
:param indx: int

> > > boxlist = BoxList([Bbox(), Bbox(1, 0, 0, 1), Bbox(1, -1, -1, 1)])
> > > boxlist.remove(0)
> > > boxlist
> > > Boxlist([Bbox(1.0, 0.0, 0.0, 1.0), Bbox(1.0, -1.0, -1.0, 1.0)])

####### grass.pygrass.vector.basic.BoxList.reset

```python
reset()
```

Reset the c_boxlist C struct, using the `Vect_reset_boxlist` C
function.

> > > boxlist = BoxList([Bbox(), Bbox(1, 0, 0, 1), Bbox(1, -1, -1, 1)])
> > > len(boxlist)
> > > 3
> > > boxlist.reset()
> > > len(boxlist)
> > > 0

###### grass.pygrass.vector.basic.Cats

```python
Cats(c_cats=None)
```

Instantiate a Category class that contains a ctypes pointer
to the C line_cats struct.

> > > cats = Cats()
> > > for cat in range(100, 110):
> > > ... cats.set(cat, layer=cat - 50)
> > > cats.n_cats
> > > 10
> > > cats.cat
> > > [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]
> > > cats.layer
> > > [50, 51, 52, 53, 54, 55, 56, 57, 58, 59]
> > > cats.get() # default layer is 1
> > > (-1, 0)
> > > cats.get(50)
> > > (100, 1)
> > > cats.get(51)
> > > (101, 1)
> > > cats.set(1001, 52)
> > > cats.cat
> > > [100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 1001]
> > > cats.layer
> > > [50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 52]
> > > cats.get(52)
> > > (102, 2)
> > > cats.reset()
> > > cats.layer
> > > []
> > > cats.cat
> > > []

**Functions:**

- [**check_cats_constraints**](#grass.pygrass.vector.basic.Cats.check_cats_constraints) – Check if categories match with category constraints
- [**delete**](#grass.pygrass.vector.basic.Cats.delete) – If cat is given delete cat from line_cats structure
- [**get**](#grass.pygrass.vector.basic.Cats.get) – Return the first found category of given layer
- [**get_list**](#grass.pygrass.vector.basic.Cats.get_list) – Get list of categories of given field.
- [**reset**](#grass.pygrass.vector.basic.Cats.reset) – Reset the C cats struct from previous values.
- [**set**](#grass.pygrass.vector.basic.Cats.set) – Add new field/cat to category structure if doesn't exist yet.

**Attributes:**

- [**c_cats**](#grass.pygrass.vector.basic.Cats.c_cats) –
- [**cat**](#grass.pygrass.vector.basic.Cats.cat) –
- [**layer**](#grass.pygrass.vector.basic.Cats.layer) –
- [**n_cats**](#grass.pygrass.vector.basic.Cats.n_cats) – Return the number of categories

####### grass.pygrass.vector.basic.Cats.c_cats

```python
c_cats = c_cats or ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.basic.Cats.cat

```python
cat
```

####### grass.pygrass.vector.basic.Cats.check_cats_constraints

```python
check_cats_constraints(cats_list, layer=1)
```

Check if categories match with category constraints

:param cats_list: a list of categories
:type cats_list: list
:param layer: the number of layer
:type layer: int

####### grass.pygrass.vector.basic.Cats.delete

```python
delete(cat=None, layer=1)
```

If cat is given delete cat from line_cats structure
(using Vect_field_cat_del) else delete all categories of given layer
(using Vect_cat_del).

:param cat: the cat to add
:type cat: int
:param layer: the number of layer
:type layer: int

####### grass.pygrass.vector.basic.Cats.get

```python
get(layer=1)
```

Return the first found category of given layer
and the number of category found.

:param layer: the number of layer
:type layer: int

####### grass.pygrass.vector.basic.Cats.get_list

```python
get_list(layer=1)
```

Get list of categories of given field.

:param layer: the number of layer
:type layer: int

####### grass.pygrass.vector.basic.Cats.layer

```python
layer
```

####### grass.pygrass.vector.basic.Cats.n_cats

```python
n_cats
```

Return the number of categories

####### grass.pygrass.vector.basic.Cats.reset

```python
reset()
```

Reset the C cats struct from previous values.

####### grass.pygrass.vector.basic.Cats.set

```python
set(cat, layer=1)
```

Add new field/cat to category structure if doesn't exist yet.

:param cat: the cat to add
:type cat: int
:param layer: the number of layer
:type layer: int

###### grass.pygrass.vector.basic.CatsList

```python
CatsList(c_cat_list=None)
```

> > > cats_list = CatsList()
> > > cats_list.min
> > > []
> > > cats_list.max
> > > []
> > > cats_list.n_ranges
> > > 0
> > > cats_list.layer
> > > 0
> > > string = "2,3,5-9,20"
> > > cats_list.from_string(string)
> > > cats_list.min
> > > [2, 3, 5, 20]
> > > cats_list.max
> > > [2, 3, 9, 20]
> > > cats_list.n_ranges
> > > 4

**Functions:**

- [**from_array**](#grass.pygrass.vector.basic.CatsList.from_array) – Convert ordered array of integers to cat_list structure.
- [**from_string**](#grass.pygrass.vector.basic.CatsList.from_string) – Converts string of categories and cat ranges separated by commas

**Attributes:**

- [**c_cat_list**](#grass.pygrass.vector.basic.CatsList.c_cat_list) –
- [**layer**](#grass.pygrass.vector.basic.CatsList.layer) – Return the layer number
- [**max**](#grass.pygrass.vector.basic.CatsList.max) – Return the maximum value
- [**min**](#grass.pygrass.vector.basic.CatsList.min) – Return the minimum value
- [**n_ranges**](#grass.pygrass.vector.basic.CatsList.n_ranges) – Return the ranges number

####### grass.pygrass.vector.basic.CatsList.c_cat_list

```python
c_cat_list = c_cat_list or ctypes.pointer(libvect.cat_list())
```

####### grass.pygrass.vector.basic.CatsList.from_array

```python
from_array(array)
```

Convert ordered array of integers to cat_list structure.

:param array: the input array containing the cats
:type array: array

####### grass.pygrass.vector.basic.CatsList.from_string

```python
from_string(string)
```

Converts string of categories and cat ranges separated by commas
to cat_list.

:param string: a string containing the cats separated by commas
:type string: str

####### grass.pygrass.vector.basic.CatsList.layer

```python
layer
```

Return the layer number

####### grass.pygrass.vector.basic.CatsList.max

```python
max
```

Return the maximum value

####### grass.pygrass.vector.basic.CatsList.min

```python
min
```

Return the minimum value

####### grass.pygrass.vector.basic.CatsList.n_ranges

```python
n_ranges
```

Return the ranges number

###### grass.pygrass.vector.basic.Ilist

```python
Ilist(integer_list=None)
```

Instantiate a list of integer using the C GRASS struct `ilist`,
the class contains this struct as `c_ilist` attribute.

**Functions:**

- [**append**](#grass.pygrass.vector.basic.Ilist.append) – Append an integer to the list
- [**contains**](#grass.pygrass.vector.basic.Ilist.contains) – Check if value is in the list
- [**extend**](#grass.pygrass.vector.basic.Ilist.extend) – Extend the list with another Ilist object or
- [**remove**](#grass.pygrass.vector.basic.Ilist.remove) – Remove a value from a list
- [**reset**](#grass.pygrass.vector.basic.Ilist.reset) – Reset the list

**Attributes:**

- [**c_ilist**](#grass.pygrass.vector.basic.Ilist.c_ilist) –

####### grass.pygrass.vector.basic.Ilist.append

```python
append(value)
```

Append an integer to the list

####### grass.pygrass.vector.basic.Ilist.c_ilist

```python
c_ilist = ctypes.pointer(libvect.struct_ilist())
```

####### grass.pygrass.vector.basic.Ilist.contains

```python
contains(value)
```

Check if value is in the list

####### grass.pygrass.vector.basic.Ilist.extend

```python
extend(ilist)
```

Extend the list with another Ilist object or
with a list of integers

:param ilist: the ilist to append
:type ilist: a Ilist object

####### grass.pygrass.vector.basic.Ilist.remove

```python
remove(value)
```

Remove a value from a list

####### grass.pygrass.vector.basic.Ilist.reset

```python
reset()
```

Reset the list

##### grass.pygrass.vector.find

Created on Tue Mar 19 11:09:30 2013

@author: pietro

**Classes:**

- [**AbstractFinder**](#grass.pygrass.vector.find.AbstractFinder) –
- [**BboxFinder**](#grass.pygrass.vector.find.BboxFinder) – Bounding Box finder
- [**PointFinder**](#grass.pygrass.vector.find.PointFinder) – Point finder
- [**PolygonFinder**](#grass.pygrass.vector.find.PolygonFinder) –

**Attributes:**

- [**mset**](#grass.pygrass.vector.find.mset) –
- [**test_vector_name**](#grass.pygrass.vector.find.test_vector_name) –

###### grass.pygrass.vector.find.AbstractFinder

```python
AbstractFinder(c_mapinfo, table=None, writeable=False)
```

**Functions:**

- [**is_open**](#grass.pygrass.vector.find.AbstractFinder.is_open) – Check if the vector map is open or not

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.find.AbstractFinder.c_mapinfo) –
- [**table**](#grass.pygrass.vector.find.AbstractFinder.table) (<code>[Table](#grass.pygrass.vector.table.Table) | None</code>) –
- [**vtype**](#grass.pygrass.vector.find.AbstractFinder.vtype) (<code>[dict](#dict)\[[str](#str), [int](#int)\]</code>) –
- [**writeable**](#grass.pygrass.vector.find.AbstractFinder.writeable) (<code>[bool](#bool)</code>) –

Find geometry feature(s) around a point or that are inside or intersect
with a bounding box.

:param c_mapinfo: Pointer to the vector layer mapinfo structure
:type c_mapinfo: ctypes pointer to mapinfo structure
:param table: Attribute table of the vector layer
:param writable: True or False

####### grass.pygrass.vector.find.AbstractFinder.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.find.AbstractFinder.is_open

```python
is_open()
```

Check if the vector map is open or not

####### grass.pygrass.vector.find.AbstractFinder.table

```python
table: Table | None = table
```

####### grass.pygrass.vector.find.AbstractFinder.vtype

```python
vtype: dict[str, int] = {'point': libvect.GV_POINT, 'line': libvect.GV_LINE, 'boundary': libvect.GV_BOUNDARY, 'centroid': libvect.GV_CENTROID, 'all': -1}
```

####### grass.pygrass.vector.find.AbstractFinder.writeable

```python
writeable: bool = writeable
```

###### grass.pygrass.vector.find.BboxFinder

Bases: <code>[AbstractFinder](#grass.pygrass.vector.find.AbstractFinder)</code>

Bounding Box finder

This class provides an interface to search geometry features
of a vector map that are inside or intersect a boundingbox.
The BboxFinder class is part of a topological vector map object.

**Functions:**

- [**areas**](#grass.pygrass.vector.find.BboxFinder.areas) – Find areas inside a boundingbox.
- [**geos**](#grass.pygrass.vector.find.BboxFinder.geos) – Find vector features inside a boundingbox.
- [**is_open**](#grass.pygrass.vector.find.BboxFinder.is_open) – Check if the vector map is open or not
- [**islands**](#grass.pygrass.vector.find.BboxFinder.islands) – Find isles inside a boundingbox.
- [**nodes**](#grass.pygrass.vector.find.BboxFinder.nodes) – Find nodes inside a boundingbox.

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.find.BboxFinder.c_mapinfo) –
- [**table**](#grass.pygrass.vector.find.BboxFinder.table) (<code>[Table](#grass.pygrass.vector.table.Table) | None</code>) –
- [**vtype**](#grass.pygrass.vector.find.BboxFinder.vtype) (<code>[dict](#dict)\[[str](#str), [int](#int)\]</code>) –
- [**writeable**](#grass.pygrass.vector.find.BboxFinder.writeable) (<code>[bool](#bool)</code>) –

####### grass.pygrass.vector.find.BboxFinder.areas

```python
areas(bbox, boxlist=None, bboxlist_only=False)
```

Find areas inside a boundingbox.

:param bbox: The boundingbox to search in
:type bbox: grass.pygrass.vector.basic.Bbox

:param boxlist: An existing BoxList to be filled with
:type_boxlist: grass.pygrass.vector.basic.BoxList

:param bboxlist_only: If true the BoxList will be returned,
no features are generated
:type bboxlist_only: boolean

:return: A list of areas or None if nothing was found

This methods uses libvect.Vect_select_areas_by_box()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find areas in box

> > > bbox = Bbox(north=5, south=-1, east=9, west=-1)
> > > result = test_vect.find_by_bbox.areas(bbox=bbox)
> > > [area for area in result]
> > > [Area(1), Area(2), Area(3), Area(4)]

> > > bbox = Bbox(north=5, south=-1, east=9, west=-1)
> > > result = test_vect.find_by_bbox.areas(bbox=bbox, bboxlist_only=True)
> > > result # doctest: +NORMALIZE_WHITESPACE
> > > Boxlist(\[Bbox(4.0, 0.0, 4.0, 0.0),
> > > Bbox(4.0, 0.0, 6.0, 4.0),
> > > Bbox(3.0, 1.0, 3.0, 1.0),
> > > Bbox(4.0, 0.0, 8.0, 6.0)\])

> > > bbox = Bbox(north=20, south=18, east=20, west=18)
> > > test_vect.find_by_bbox.areas(bbox=bbox)

> > > test_vect.find_by_bbox.areas(bbox=bbox, bboxlist_only=True)

> > > test_vect.close()

####### grass.pygrass.vector.find.BboxFinder.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.find.BboxFinder.geos

```python
geos(bbox, type='all', bboxlist_only=False)
```

Find vector features inside a boundingbox.

:param bbox: The boundingbox to search in
:type bbox: grass.pygrass.vector.basic.Bbox

:param type: The type of feature to search for
Valid type are all the keys in find.vtype dictionary
:type type: string

:param bboxlist_only: If true the BoxList will be returned,
no features are generated
:type bboxlist_only: boolean

:return: A list of grass.pygrass.vector.geometry
(Line, Point, Boundary, Centroid) if found,
or None if nothing was found.
If bboxlist_only is True a BoxList
object will be returned, or None if nothing was found.

This methods uses libvect.Vect_select_lines_by_box()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

> > > bbox = Bbox(north=5, south=-1, east=3, west=-1)
> > > result = test_vect.find_by_bbox.geos(bbox=bbox)
> > > [bbox for bbox in result] # doctest: +NORMALIZE_WHITESPACE
> > > \[Boundary([Point(4.000000, 0.000000), Point(0.000000, 0.000000)]),
> > > Boundary([Point(0.000000, 0.000000), Point(0.000000, 4.000000)]),
> > > Boundary([Point(0.000000, 4.000000), Point(4.000000, 4.000000)]),
> > > Boundary(\[Point(1.000000, 1.000000), Point(1.000000, 3.000000),
> > > Point(3.000000, 3.000000), Point(3.000000, 1.000000),
> > > Point(1.000000, 1.000000)\]),
> > > Centroid(2.500000, 2.500000)\]

> > > bbox = Bbox(north=5, south=-1, east=3, west=-1)
> > > result = test_vect.find_by_bbox.geos(bbox=bbox, bboxlist_only=True)
> > > result # doctest: +NORMALIZE_WHITESPACE
> > > Boxlist(\[Bbox(0.0, 0.0, 4.0, 0.0),
> > > Bbox(4.0, 0.0, 0.0, 0.0),
> > > Bbox(4.0, 4.0, 4.0, 0.0),
> > > Bbox(3.0, 1.0, 3.0, 1.0),
> > > Bbox(2.5, 2.5, 2.5, 2.5)\])

> > > bbox = Bbox(north=7, south=-1, east=15, west=9)
> > > result = test_vect.find_by_bbox.geos(bbox=bbox)
> > > [bbox for bbox in result] # doctest: +NORMALIZE_WHITESPACE
> > > \[Line(\[Point(10.000000, 4.000000), Point(10.000000, 2.000000),
> > > Point(10.000000, 0.000000)\]),
> > > Point(10.000000, 6.000000),
> > > Line(\[Point(12.000000, 4.000000), Point(12.000000, 2.000000),
> > > Point(12.000000, 0.000000)\]),
> > > Point(12.000000, 6.000000),
> > > Line(\[Point(14.000000, 4.000000), Point(14.000000, 2.000000),
> > > Point(14.000000, 0.000000)\]),
> > > Point(14.000000, 6.000000)\]

> > > bbox = Bbox(north=20, south=18, east=20, west=18)
> > > test_vect.find_by_bbox.geos(bbox=bbox)

> > > bbox = Bbox(north=20, south=18, east=20, west=18)
> > > test_vect.find_by_bbox.geos(bbox=bbox, bboxlist_only=True)

> > > test_vect.close()

####### grass.pygrass.vector.find.BboxFinder.is_open

```python
is_open()
```

Check if the vector map is open or not

####### grass.pygrass.vector.find.BboxFinder.islands

```python
islands(bbox, bboxlist_only=False)
```

Find isles inside a boundingbox.

:param bbox: The boundingbox to search in
:type bbox: grass.pygrass.vector.basic.Bbox

:param bboxlist_only: If true the BoxList will be returned,
no features are generated
:type bboxlist_only: boolean

:return: A list of isles or None if nothing was found

This methods uses libvect.Vect_select_isles_by_box()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find isles in box

> > > bbox = Bbox(north=5, south=-1, east=9, west=-1)
> > > result = test_vect.find_by_bbox.islands(bbox=bbox)
> > > [isle for isle in result]
> > > [Isle(1), Isle(2)]

> > > bbox = Bbox(north=5, south=-1, east=9, west=-1)
> > > result = test_vect.find_by_bbox.islands(bbox=bbox, bboxlist_only=True)
> > > result # doctest: +NORMALIZE_WHITESPACE
> > > Boxlist(\[Bbox(4.0, 0.0, 8.0, 0.0),
> > > Bbox(3.0, 1.0, 3.0, 1.0)\])

> > > bbox = Bbox(north=20, south=18, east=20, west=18)
> > > test_vect.find_by_bbox.islands(bbox=bbox)

> > > test_vect.find_by_bbox.islands(bbox=bbox, bboxlist_only=True)

> > > test_vect.close()

####### grass.pygrass.vector.find.BboxFinder.nodes

```python
nodes(bbox)
```

Find nodes inside a boundingbox.

:param bbox: The boundingbox to search in
:type bbox: grass.pygrass.vector.basic.Bbox

:return: A list of nodes or None if nothing was found

This methods uses libvect.Vect_select_nodes_by_box()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.basic import Bbox
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find nodes in box

> > > bbox = Bbox(north=5, south=-1, east=15, west=9)
> > > result = test_vect.find_by_bbox.nodes(bbox=bbox)
> > > [node for node in result]
> > > [Node(2), Node(1), Node(4), Node(3), Node(5), Node(6)]

> > > bbox = Bbox(north=20, south=18, east=20, west=18)
> > > test_vect.find_by_bbox.nodes(bbox=bbox)

> > > test_vect.close()

####### grass.pygrass.vector.find.BboxFinder.table

```python
table: Table | None = table
```

####### grass.pygrass.vector.find.BboxFinder.vtype

```python
vtype: dict[str, int] = {'point': libvect.GV_POINT, 'line': libvect.GV_LINE, 'boundary': libvect.GV_BOUNDARY, 'centroid': libvect.GV_CENTROID, 'all': -1}
```

####### grass.pygrass.vector.find.BboxFinder.writeable

```python
writeable: bool = writeable
```

###### grass.pygrass.vector.find.PointFinder

Bases: <code>[AbstractFinder](#grass.pygrass.vector.find.AbstractFinder)</code>

Point finder

This class provides an interface to search geometry features
of a vector map that are close to a point. The PointFinder class
is part of a topological vector map object.

**Functions:**

- [**area**](#grass.pygrass.vector.find.PointFinder.area) – Find the nearest area around a specific point.
- [**geo**](#grass.pygrass.vector.find.PointFinder.geo) – Find the nearest vector feature around a specific point.
- [**geos**](#grass.pygrass.vector.find.PointFinder.geos) – Find the nearest vector features around a specific point.
- [**is_open**](#grass.pygrass.vector.find.PointFinder.is_open) – Check if the vector map is open or not
- [**island**](#grass.pygrass.vector.find.PointFinder.island) – Find the nearest island around a specific point.
- [**node**](#grass.pygrass.vector.find.PointFinder.node) – Find the nearest node around a specific point.

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.find.PointFinder.c_mapinfo) –
- [**table**](#grass.pygrass.vector.find.PointFinder.table) (<code>[Table](#grass.pygrass.vector.table.Table) | None</code>) –
- [**vtype**](#grass.pygrass.vector.find.PointFinder.vtype) (<code>[dict](#dict)\[[str](#str), [int](#int)\]</code>) –
- [**writeable**](#grass.pygrass.vector.find.PointFinder.writeable) (<code>[bool](#bool)</code>) –

####### grass.pygrass.vector.find.PointFinder.area

```python
area(point)
```

Find the nearest area around a specific point.

:param point: The point to search
:type point: grass.pygrass.vector.geometry.Point

:return: A grass.pygrass.vector.geometry.Area if found or None

This methods uses libvect.Vect_find_area()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.geometry import Point
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find AREAS

> > > points = (Point(0.5, 0.5), Point(5, 1), Point(7, 1))
> > > result = []
> > > for point in points:
> > > ... area = test_vect.find_by_point.area(point)
> > > ... result.append(area)
> > > result
> > > [Area(1), Area(2), Area(4)]
> > > for area in result:
> > > ... print(area.to_wkt()) # doctest: +NORMALIZE_WHITESPACE
> > > POLYGON ((0.0000000000000000 0.0000000000000000,
> > > 0.0000000000000000 4.0000000000000000,
> > > 0.0000000000000000 4.0000000000000000,
> > > 4.0000000000000000 4.0000000000000000,
> > > 4.0000000000000000 4.0000000000000000,
> > > 4.0000000000000000 0.0000000000000000,
> > > 4.0000000000000000 0.0000000000000000,
> > > 0.0000000000000000 0.0000000000000000),
> > > (1.0000000000000000 1.0000000000000000,
> > > 3.0000000000000000 1.0000000000000000,
> > > 3.0000000000000000 3.0000000000000000,
> > > 1.0000000000000000 3.0000000000000000,
> > > 1.0000000000000000 1.0000000000000000))
> > > POLYGON ((4.0000000000000000 0.0000000000000000,
> > > 4.0000000000000000 4.0000000000000000,
> > > 4.0000000000000000 4.0000000000000000,
> > > 6.0000000000000000 4.0000000000000000,
> > > 6.0000000000000000 4.0000000000000000,
> > > 6.0000000000000000 0.0000000000000000,
> > > 6.0000000000000000 0.0000000000000000,
> > > 4.0000000000000000 0.0000000000000000))
> > > POLYGON ((6.0000000000000000 0.0000000000000000,
> > > 6.0000000000000000 4.0000000000000000,
> > > 6.0000000000000000 4.0000000000000000,
> > > 8.0000000000000000 4.0000000000000000,
> > > 8.0000000000000000 4.0000000000000000,
> > > 8.0000000000000000 0.0000000000000000,
> > > 8.0000000000000000 0.0000000000000000,
> > > 6.0000000000000000 0.0000000000000000))

> > > test_vect.find_by_point.area(Point(20, 20))

> > > test_vect.close()

####### grass.pygrass.vector.find.PointFinder.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.find.PointFinder.geo

```python
geo(point, maxdist, type='all', exclude=0)
```

Find the nearest vector feature around a specific point.

:param point: The point to search
:type point: grass.pygrass.vector.geometry.Point

:param maxdist: The maximum search distance around the point
:type maxdist: float

:param type: The type of feature to search for
Valid type are all the keys in find.vtype dictionary
:type type: string

:param exclude: if > 0 number of lines which should be
excluded from selection

:return: A grass.pygrass.vector.geometry.Node if found or None

This methods uses libvect.Vect_find_line()()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.geometry import Point
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find single features

> > > points = (Point(10, 0), Point(10, 6), Point(14, 2))
> > > result = []
> > > for point in points:
> > > ... f = test_vect.find_by_point.geo(point=point, maxdist=1)
> > > ... if f:
> > > ... result.append(f)
> > > for f in result:
> > > ... print(f.to_wkt_p()) # doctest: +NORMALIZE_WHITESPACE
> > > LINESTRING(10.000000 4.000000,
> > > 10.000000 2.000000,
> > > 10.000000 0.000000)
> > > POINT(10.000000 6.000000)
> > > LINESTRING(14.000000 4.000000,
> > > 14.000000 2.000000,
> > > 14.000000 0.000000)

> > > test_vect.find_by_point.geo(point=Point(20, 20), maxdist=0)

> > > test_vect.close()

####### grass.pygrass.vector.find.PointFinder.geos

```python
geos(point, maxdist, type='all', exclude=None)
```

Find the nearest vector features around a specific point.

:param point: The point to search
:type point: grass.pygrass.vector.geometry.Point

:param maxdist: The maximum search distance around the point
:type maxdist: float

:param type: The type of feature to search for
Valid type are all the keys in find.vtype dictionary
:type type: string

:param exclude: if > 0 number of lines which should be
excluded from selection

:return: A list of grass.pygrass.vector.geometry
(Line, Point, Boundary, Centroid) if found or None

This methods uses libvect.Vect_find_line_list()()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.geometry import Point
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find multiple features

> > > points = (Point(10, 0), Point(10, 5), Point(14, 2))
> > > result = []
> > > for point in points:
> > > ... f = test_vect.find_by_point.geos(point=point, maxdist=1.5)
> > > ... if f:
> > > ... result.append(f)
> > > for f in result:
> > > ... print(f) # doctest: +NORMALIZE_WHITESPACE
> > > \[Line(\[Point(10.000000, 4.000000),
> > > Point(10.000000, 2.000000),
> > > Point(10.000000, 0.000000)\])\]
> > > \[Line(\[Point(10.000000, 4.000000),
> > > Point(10.000000, 2.000000),
> > > Point(10.000000, 0.000000)\]),
> > > Point(10.000000, 6.000000)\]
> > > \[Line(\[Point(14.000000, 4.000000),
> > > Point(14.000000, 2.000000),
> > > Point(14.000000, 0.000000)\])\]

# Find multiple boundaries

> > > point = Point(3, 3)
> > > result = test_vect.find_by_point.geos(
> > > ... point=Point(3, 3), type="boundary", maxdist=1.5
> > > ... )
> > > result # doctest: +NORMALIZE_WHITESPACE
> > > \[Boundary([Point(0.000000, 4.000000), Point(4.000000, 4.000000)]),
> > > Boundary([Point(4.000000, 4.000000), Point(4.000000, 0.000000)]),
> > > Boundary(\[Point(1.000000, 1.000000), Point(1.000000, 3.000000),
> > > Point(3.000000, 3.000000), Point(3.000000, 1.000000),
> > > Point(1.000000, 1.000000)\]),
> > > Boundary([Point(4.000000, 4.000000), Point(6.000000, 4.000000)])\]

# Find multiple centroids

> > > point = Point(3, 3)
> > > result = test_vect.find_by_point.geos(
> > > ... point=Point(3, 3), type="centroid", maxdist=1.5
> > > ... )
> > > result # doctest: +NORMALIZE_WHITESPACE
> > > \[Centroid(2.500000, 2.500000),
> > > Centroid(3.500000, 3.500000)\]

> > > test_vect.find_by_point.geos(point=Point(20, 20), maxdist=0)

> > > test_vect.close()

####### grass.pygrass.vector.find.PointFinder.is_open

```python
is_open()
```

Check if the vector map is open or not

####### grass.pygrass.vector.find.PointFinder.island

```python
island(point)
```

Find the nearest island around a specific point.

:param point: The point to search
:type point: grass.pygrass.vector.geometry.Point

:return: A grass.pygrass.vector.geometry.Isle if found or None

This methods uses Vect_find_island.Vect_find_area()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.geometry import Point
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find ISLANDS

> > > points = (Point(2, 2), Point(5, 1))
> > > result = []
> > > for point in points:
> > > ... area = test_vect.find_by_point.island(point)
> > > ... result.append(area)
> > > result
> > > [Isle(2), Isle(1)]
> > > for isle in result:
> > > ... print(isle.to_wkt()) # doctest: +NORMALIZE_WHITESPACE
> > > Polygon((1.000000 1.000000, 3.000000 1.000000,
> > > 3.000000 3.000000, 1.000000 3.000000, 1.000000 1.000000))
> > > Polygon((0.000000 4.000000, 0.000000 0.000000, 4.000000 0.000000,
> > > 6.000000 0.000000, 8.000000 0.000000, 8.000000 4.000000,
> > > 6.000000 4.000000, 4.000000 4.000000, 0.000000 4.000000))

> > > test_vect.find_by_point.island(Point(20, 20))

> > > test_vect.close()

####### grass.pygrass.vector.find.PointFinder.node

```python
node(point, maxdist)
```

Find the nearest node around a specific point.

:param point: The point to search
:type point: grass.pygrass.vector.geometry.Point

:param maxdist: The maximum search distance around the point
:type maxdist: float

:return: A grass.pygrass.vector.geometry.Node if found or None

This methods uses libvect.Vect_find_node()()

Examples:

> > > from grass.pygrass.vector import VectorTopo
> > > from grass.pygrass.vector.geometry import Point
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")

# Find nearest node

> > > points = (Point(10, 0), Point(10, 4), Point(14, 0))
> > > result = []
> > > for point in points:
> > > ... f = test_vect.find_by_point.node(point=point, maxdist=1)
> > > ... if f:
> > > ... result.append(f)
> > > result
> > > [Node(2), Node(1), Node(6)]

> > > test_vect.find_by_point.node(point=Point(20, 20), maxdist=0)

> > > test_vect.close()

####### grass.pygrass.vector.find.PointFinder.table

```python
table: Table | None = table
```

####### grass.pygrass.vector.find.PointFinder.vtype

```python
vtype: dict[str, int] = {'point': libvect.GV_POINT, 'line': libvect.GV_LINE, 'boundary': libvect.GV_BOUNDARY, 'centroid': libvect.GV_CENTROID, 'all': -1}
```

####### grass.pygrass.vector.find.PointFinder.writeable

```python
writeable: bool = writeable
```

###### grass.pygrass.vector.find.PolygonFinder

Bases: <code>[AbstractFinder](#grass.pygrass.vector.find.AbstractFinder)</code>

**Functions:**

- [**areas**](#grass.pygrass.vector.find.PolygonFinder.areas) –
- [**is_open**](#grass.pygrass.vector.find.PolygonFinder.is_open) – Check if the vector map is open or not
- [**lines**](#grass.pygrass.vector.find.PolygonFinder.lines) –

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.find.PolygonFinder.c_mapinfo) –
- [**table**](#grass.pygrass.vector.find.PolygonFinder.table) (<code>[Table](#grass.pygrass.vector.table.Table) | None</code>) –
- [**vtype**](#grass.pygrass.vector.find.PolygonFinder.vtype) (<code>[dict](#dict)\[[str](#str), [int](#int)\]</code>) –
- [**writeable**](#grass.pygrass.vector.find.PolygonFinder.writeable) (<code>[bool](#bool)</code>) –

####### grass.pygrass.vector.find.PolygonFinder.areas

```python
areas(polygon, isles=None)
```

####### grass.pygrass.vector.find.PolygonFinder.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.find.PolygonFinder.is_open

```python
is_open()
```

Check if the vector map is open or not

####### grass.pygrass.vector.find.PolygonFinder.lines

```python
lines(polygon, isles=None)
```

####### grass.pygrass.vector.find.PolygonFinder.table

```python
table: Table | None = table
```

####### grass.pygrass.vector.find.PolygonFinder.vtype

```python
vtype: dict[str, int] = {'point': libvect.GV_POINT, 'line': libvect.GV_LINE, 'boundary': libvect.GV_BOUNDARY, 'centroid': libvect.GV_CENTROID, 'all': -1}
```

####### grass.pygrass.vector.find.PolygonFinder.writeable

```python
writeable: bool = writeable
```

###### grass.pygrass.vector.find.mset

```python
mset = get_mapset_vector(test_vector_name, mapset='')
```

###### grass.pygrass.vector.find.test_vector_name

```python
test_vector_name = 'find_doctest_map'
```

##### grass.pygrass.vector.geometry

Created on Wed Jul 18 10:46:25 2012

@author: pietro

**Classes:**

- [**Area**](#grass.pygrass.vector.geometry.Area) – Vect_build_line_area,
- [**Attrs**](#grass.pygrass.vector.geometry.Attrs) –
- [**Boundary**](#grass.pygrass.vector.geometry.Boundary) –
- [**Centroid**](#grass.pygrass.vector.geometry.Centroid) – The Centroid class inherit from the Point class.
- [**Geo**](#grass.pygrass.vector.geometry.Geo) – Base object for different feature types
- [**Isle**](#grass.pygrass.vector.geometry.Isle) – An Isle is an area contained by another area.
- [**Isles**](#grass.pygrass.vector.geometry.Isles) –
- [**Line**](#grass.pygrass.vector.geometry.Line) – Instantiate a new Line with a list of tuple, or with a list of Point. ::
- [**Node**](#grass.pygrass.vector.geometry.Node) – Node class for topological analysis of line neighbors.
- [**Point**](#grass.pygrass.vector.geometry.Point) – Instantiate a Point object that could be 2 or 3D, default

**Functions:**

- [**c_read_line**](#grass.pygrass.vector.geometry.c_read_line) –
- [**c_read_next_line**](#grass.pygrass.vector.geometry.c_read_next_line) –
- [**get_xyz**](#grass.pygrass.vector.geometry.get_xyz) – Return a tuple with: x, y, z.
- [**intersects**](#grass.pygrass.vector.geometry.intersects) – Return a list of points
- [**read_WKB**](#grass.pygrass.vector.geometry.read_WKB) – Read the binary buffer and return a geometry object
- [**read_WKT**](#grass.pygrass.vector.geometry.read_WKT) – Read the string and return a geometry object
- [**read_line**](#grass.pygrass.vector.geometry.read_line) – Return a geometry object given the feature id and the c_mapinfo.
- [**read_next_line**](#grass.pygrass.vector.geometry.read_next_line) – Return the next geometry feature of a vector map.

**Attributes:**

- [**GEOOBJ**](#grass.pygrass.vector.geometry.GEOOBJ) –
- [**GV_TYPE**](#grass.pygrass.vector.geometry.GV_TYPE) –
- [**LineDist**](#grass.pygrass.vector.geometry.LineDist) –
- [**WKT**](#grass.pygrass.vector.geometry.WKT) –
- [**mset**](#grass.pygrass.vector.geometry.mset) –
- [**test_vector_name**](#grass.pygrass.vector.geometry.test_vector_name) –

###### grass.pygrass.vector.geometry.Area

```python
Area(**kargs)
```

Bases: <code>[Geo](#grass.pygrass.vector.geometry.Geo)</code>

Vect_build_line_area,
Vect_find_area,
Vect_get_area_box,
Vect_get_area_points_geos,
Vect_centroid_area,

Vect_get_isle_area,
Vect_get_line_areas,
Vect_get_num_areas,
Vect_get_point_in_area,
Vect_isle_find_area,
Vect_point_in_area,
Vect_point_in_area_outer_ring,

Vect_read_area_geos,
Vect_remove_small_areas,
Vect_select_areas_by_box,
Vect_select_areas_by_polygon

**Functions:**

- [**alive**](#grass.pygrass.vector.geometry.Area.alive) – Check if area is alive or dead (topology required)
- [**area**](#grass.pygrass.vector.geometry.Area.area) – Returns area of area without areas of isles.
- [**bbox**](#grass.pygrass.vector.geometry.Area.bbox) – Return the Bbox of area
- [**boundaries**](#grass.pygrass.vector.geometry.Area.boundaries) – Creates list of boundaries for given area.
- [**buffer**](#grass.pygrass.vector.geometry.Area.buffer) – Return the buffer area around the area, using the
- [**cats**](#grass.pygrass.vector.geometry.Area.cats) – Get area categories.
- [**centroid**](#grass.pygrass.vector.geometry.Area.centroid) – Return the centroid
- [**contains_point**](#grass.pygrass.vector.geometry.Area.contains_point) – Check if point is in area.
- [**get_first_cat**](#grass.pygrass.vector.geometry.Area.get_first_cat) – Find FIRST category of given field and area.
- [**has_topology**](#grass.pygrass.vector.geometry.Area.has_topology) –
- [**isles**](#grass.pygrass.vector.geometry.Area.isles) – Return a list of islands located in this area
- [**num_isles**](#grass.pygrass.vector.geometry.Area.num_isles) –
- [**perimeter**](#grass.pygrass.vector.geometry.Area.perimeter) – Calculate area perimeter.
- [**points**](#grass.pygrass.vector.geometry.Area.points) – Return a Line object with the outer ring
- [**read**](#grass.pygrass.vector.geometry.Area.read) –
- [**to_wkb**](#grass.pygrass.vector.geometry.Area.to_wkb) – Return a "well know binary" (WKB) area byte array, this method uses
- [**to_wkt**](#grass.pygrass.vector.geometry.Area.to_wkt) – Return a "well know text" (WKT) area string, this method uses

**Attributes:**

- [**attrs**](#grass.pygrass.vector.geometry.Area.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Area.c_cats) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Area.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Area.c_points) –
- [**cat**](#grass.pygrass.vector.geometry.Area.cat) –
- [**gtype**](#grass.pygrass.vector.geometry.Area.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Area.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Area.is2D) –

####### grass.pygrass.vector.geometry.Area.alive

```python
alive()
```

Check if area is alive or dead (topology required)

####### grass.pygrass.vector.geometry.Area.area

```python
area()
```

Returns area of area without areas of isles.
double Vect_get_area_area (const struct Map_info \*Map, int area)

####### grass.pygrass.vector.geometry.Area.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Area.bbox

```python
bbox(bbox=None)
```

Return the Bbox of area

:param bbox: a Bbox object to fill with info from bounding box of area
:type bbox: a Bbox object

####### grass.pygrass.vector.geometry.Area.boundaries

```python
boundaries(ilist=False)
```

Creates list of boundaries for given area.

int Vect_get_area_boundaries(const struct Map_info \*Map,
int area, struct ilist \*List)

####### grass.pygrass.vector.geometry.Area.buffer

```python
buffer(dist=None, dist_x=None, dist_y=None, angle=0, round_=True, caps=True, tol=0.1)
```

Return the buffer area around the area, using the
`Vect_area_buffer2` C function.

:param dist: the distance around the area
:type dist: num
:param dist_x: the distance along x
:type dist_x: num
:param dist_y: the distance along y
:type dist_y: num
:param angle: the angle between 0x and major axis
:type angle: num
:param round\_: to make corners round
:type round\_: bool
:param tol: fix the maximum distance between theoretical arc and output segments
:type tol: float
:returns: the buffer as line, centroid, isles object tuple

####### grass.pygrass.vector.geometry.Area.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Area.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Area.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Area.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Area.cats

```python
cats(cats=None)
```

Get area categories.

:param cats: a Cats object to fill with info with area categories
:type cats: a Cats object

####### grass.pygrass.vector.geometry.Area.centroid

```python
centroid()
```

Return the centroid

:param centroid: a Centroid object to fill with info from centroid of area
:type centroid: a Centroid object

####### grass.pygrass.vector.geometry.Area.contains_point

```python
contains_point(point, bbox=None)
```

Check if point is in area.

:param point: the point to analyze
:type point: a Point object or a tuple with the coordinates
:param bbox: the bounding box where run the analysis
:type bbox: a Bbox object

####### grass.pygrass.vector.geometry.Area.get_first_cat

```python
get_first_cat()
```

Find FIRST category of given field and area.

int Vect_get_area_cat(const struct Map_info \*Map, int area, int field)

..warning: Not implemented

####### grass.pygrass.vector.geometry.Area.gtype

```python
gtype = libvect.GV_AREA
```

####### grass.pygrass.vector.geometry.Area.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Area.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Area.is2D

```python
is2D = is2D if is2D is not None else bool(libvect.Vect_is_3d(self.c_mapinfo) != 1)
```

####### grass.pygrass.vector.geometry.Area.isles

```python
isles(isles=None)
```

Return a list of islands located in this area

####### grass.pygrass.vector.geometry.Area.num_isles

```python
num_isles()
```

####### grass.pygrass.vector.geometry.Area.perimeter

```python
perimeter()
```

Calculate area perimeter.

:return: double Vect_area_perimeter (const struct line_pnts \*Points)

####### grass.pygrass.vector.geometry.Area.points

```python
points(line=None)
```

Return a Line object with the outer ring

:param line: a Line object to fill with info from points of area
:type line: a Line object

####### grass.pygrass.vector.geometry.Area.read

```python
read()
```

####### grass.pygrass.vector.geometry.Area.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) area byte array, this method uses
the GEOS implementation in the vector library. ::

####### grass.pygrass.vector.geometry.Area.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) area string, this method uses
the GEOS implementation in the vector library. ::

###### grass.pygrass.vector.geometry.Attrs

```python
Attrs(cat, table, writeable=False)
```

**Functions:**

- [**commit**](#grass.pygrass.vector.geometry.Attrs.commit) – Save the changes
- [**keys**](#grass.pygrass.vector.geometry.Attrs.keys) – Return the column name of the attribute table.
- [**values**](#grass.pygrass.vector.geometry.Attrs.values) – Return the values of the attribute table row.

**Attributes:**

- [**cat**](#grass.pygrass.vector.geometry.Attrs.cat) –
- [**cond**](#grass.pygrass.vector.geometry.Attrs.cond) –
- [**table**](#grass.pygrass.vector.geometry.Attrs.table) –
- [**writeable**](#grass.pygrass.vector.geometry.Attrs.writeable) –

####### grass.pygrass.vector.geometry.Attrs.cat

```python
cat = property(fget=_get_cat, fset=_set_cat, doc='Set and obtain cat value')
```

####### grass.pygrass.vector.geometry.Attrs.commit

```python
commit()
```

Save the changes

####### grass.pygrass.vector.geometry.Attrs.cond

```python
cond = ''
```

####### grass.pygrass.vector.geometry.Attrs.keys

```python
keys()
```

Return the column name of the attribute table.

> > > from grass.pygrass.vector import VectorTopo
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")
> > > v1 = test_vect[1]
> > > v1.attrs.keys()
> > > ['cat', 'name', 'value']
> > > test_vect.close()

####### grass.pygrass.vector.geometry.Attrs.table

```python
table = table
```

####### grass.pygrass.vector.geometry.Attrs.values

```python
values()
```

Return the values of the attribute table row.

> > > from grass.pygrass.vector import VectorTopo
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open("r")
> > > v1 = test_vect[1]
> > > v1.attrs.values()
> > > (1, 'point', 1.0)
> > > test_vect.close()

####### grass.pygrass.vector.geometry.Attrs.writeable

```python
writeable = writeable
```

###### grass.pygrass.vector.geometry.Boundary

```python
Boundary(**kargs)
```

Bases: <code>[Line](#grass.pygrass.vector.geometry.Line)</code>

**Functions:**

- [**alive**](#grass.pygrass.vector.geometry.Boundary.alive) – Return True if this line is alive or False if this line is
- [**append**](#grass.pygrass.vector.geometry.Boundary.append) – Appends one point to the end of a line, using the
- [**area**](#grass.pygrass.vector.geometry.Boundary.area) – Return the area of the polygon.
- [**bbox**](#grass.pygrass.vector.geometry.Boundary.bbox) – Return the bounding box of the line, using `Vect_line_box`
- [**buffer**](#grass.pygrass.vector.geometry.Boundary.buffer) – Return the buffer area around the line, using the
- [**delete**](#grass.pygrass.vector.geometry.Boundary.delete) – Remove the point in the index position.
- [**distance**](#grass.pygrass.vector.geometry.Boundary.distance) – Calculate the distance between line and a point.
- [**extend**](#grass.pygrass.vector.geometry.Boundary.extend) – Appends points to the end of a line.
- [**first_cat**](#grass.pygrass.vector.geometry.Boundary.first_cat) – Fetches FIRST category number for given vector line and field, using
- [**from_wkt**](#grass.pygrass.vector.geometry.Boundary.from_wkt) – Create a line reading a WKT string.
- [**has_topology**](#grass.pygrass.vector.geometry.Boundary.has_topology) –
- [**insert**](#grass.pygrass.vector.geometry.Boundary.insert) – Insert new point at index position and move all old points at
- [**left_centroid**](#grass.pygrass.vector.geometry.Boundary.left_centroid) – Return left centroid
- [**length**](#grass.pygrass.vector.geometry.Boundary.length) – Calculate line length, 3D-length in case of 3D vector line, using
- [**length_geodesic**](#grass.pygrass.vector.geometry.Boundary.length_geodesic) – Calculate line length, using `Vect_line_geodesic_length` C function.
- [**nodes**](#grass.pygrass.vector.geometry.Boundary.nodes) – Return the start and end nodes of the line
- [**point_on_line**](#grass.pygrass.vector.geometry.Boundary.point_on_line) – Return a Point object on line in the specified distance, using the
- [**pop**](#grass.pygrass.vector.geometry.Boundary.pop) – Return the point in the index position and remove from the Line.
- [**prune**](#grass.pygrass.vector.geometry.Boundary.prune) – Remove duplicate points, i.e. zero length segments, using
- [**prune_thresh**](#grass.pygrass.vector.geometry.Boundary.prune_thresh) – Remove points in threshold, using the `Vect_line_prune_thresh`
- [**read**](#grass.pygrass.vector.geometry.Boundary.read) – Read and set the coordinates of the centroid from the vector map,
- [**read_area_ids**](#grass.pygrass.vector.geometry.Boundary.read_area_ids) – Read and return left and right area ids of the boundary
- [**remove**](#grass.pygrass.vector.geometry.Boundary.remove) – Delete point at given index and move all points above down, using
- [**reset**](#grass.pygrass.vector.geometry.Boundary.reset) – Reset line, using `Vect_reset_line` C function. ::
- [**reverse**](#grass.pygrass.vector.geometry.Boundary.reverse) – Reverse the order of vertices, using `Vect_line_reverse`
- [**right_centroid**](#grass.pygrass.vector.geometry.Boundary.right_centroid) – Return right centroid
- [**segment**](#grass.pygrass.vector.geometry.Boundary.segment) – Create line segment. using the `Vect_line_segment` C function.
- [**to_array**](#grass.pygrass.vector.geometry.Boundary.to_array) – Return an array of coordinates. ::
- [**to_list**](#grass.pygrass.vector.geometry.Boundary.to_list) – Return a list of tuple. ::
- [**to_wkb**](#grass.pygrass.vector.geometry.Boundary.to_wkb) – Return a "well know binary" (WKB) geometry byte array, this method uses
- [**to_wkt**](#grass.pygrass.vector.geometry.Boundary.to_wkt) – Return a "well know text" (WKT) geometry string, this method uses
- [**to_wkt_p**](#grass.pygrass.vector.geometry.Boundary.to_wkt_p) – Return a Well Known Text string of the line. ::

**Attributes:**

- [**attrs**](#grass.pygrass.vector.geometry.Boundary.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Boundary.c_cats) –
- [**c_left**](#grass.pygrass.vector.geometry.Boundary.c_left) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Boundary.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Boundary.c_points) –
- [**c_right**](#grass.pygrass.vector.geometry.Boundary.c_right) –
- [**cat**](#grass.pygrass.vector.geometry.Boundary.cat) –
- [**dir**](#grass.pygrass.vector.geometry.Boundary.dir) –
- [**gtype**](#grass.pygrass.vector.geometry.Boundary.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Boundary.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Boundary.is2D) –
- [**left_area_id**](#grass.pygrass.vector.geometry.Boundary.left_area_id) – Left side area id, only available after read_area_ids() was called
- [**right_area_id**](#grass.pygrass.vector.geometry.Boundary.right_area_id) – Right side area id, only available after read_area_ids() was called

####### grass.pygrass.vector.geometry.Boundary.alive

```python
alive()
```

Return True if this line is alive or False if this line is
dead or its index is out of range.

####### grass.pygrass.vector.geometry.Boundary.append

```python
append(pnt)
```

Appends one point to the end of a line, using the
`Vect_append_point` C function.

:param pnt: the point to add to line
:type pnt: a Point object or a tuple with the coordinates

```
>>> line = Line()
>>> line.append((10, 100))
>>> line
Line([Point(10.000000, 100.000000)])
>>> line.append((20, 200))
>>> line
Line([Point(10.000000, 100.000000), Point(20.000000, 200.000000)])
```

Like python list.

####### grass.pygrass.vector.geometry.Boundary.area

```python
area()
```

Return the area of the polygon.

> > > bound = Boundary(points=[(0, 0), (0, 2), (2, 2), (2, 0), (0, 0)])
> > > bound.area()
> > > 4.0

####### grass.pygrass.vector.geometry.Boundary.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Boundary.bbox

```python
bbox(bbox=None)
```

Return the bounding box of the line, using `Vect_line_box`
C function. ::

```
>>> line = Line([(0, 0), (0, 1), (2, 1), (2, 0)])
>>> bbox = line.bbox()
>>> bbox
Bbox(1.0, 0.0, 2.0, 0.0)
```

..

####### grass.pygrass.vector.geometry.Boundary.buffer

```python
buffer(dist=None, dist_x=None, dist_y=None, angle=0, round_=True, caps=True, tol=0.1)
```

Return the buffer area around the line, using the
`Vect_line_buffer2` C function.

:param dist: the distance around the line
:type dist: num
:param dist_x: the distance along x
:type dist_x: num
:param dist_y: the distance along y
:type dist_y: num
:param angle: the angle between 0x and major axis
:type angle: num
:param round\_: to make corners round
:type round\_: bool
:param tol: fix the maximum distance between theoretical arc and output segments
:type tol: float
:returns: the buffer as Area object

> > > line = Line([(0, 0), (0, 2)])
> > > boundary, centroid, isles = line.buffer(10)
> > > boundary # doctest: +ELLIPSIS
> > > Line([Point(-10.000000, 0.000000),...Point(-10.000000, 0.000000)])
> > > centroid # doctest: +NORMALIZE_WHITESPACE
> > > Point(0.000000, 0.000000)
> > > isles
> > > []

..

####### grass.pygrass.vector.geometry.Boundary.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Boundary.c_left

```python
c_left = ctypes.pointer(ctypes.c_int())
```

####### grass.pygrass.vector.geometry.Boundary.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Boundary.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Boundary.c_right

```python
c_right = ctypes.pointer(ctypes.c_int())
```

####### grass.pygrass.vector.geometry.Boundary.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Boundary.delete

```python
delete(indx)
```

Remove the point in the index position.
:param indx: the index where add new point
:type indx: int

> > > line = Line([(0, 0), (1, 1), (2, 2)])
> > > line.delete(-1)
> > > line # doctest: +NORMALIZE_WHITESPACE
> > > Line([Point(0.000000, 0.000000), Point(1.000000, 1.000000)])

####### grass.pygrass.vector.geometry.Boundary.dir

```python
dir = libvect.GV_FORWARD if v_id > 0 else libvect.GV_BACKWARD
```

####### grass.pygrass.vector.geometry.Boundary.distance

```python
distance(pnt)
```

Calculate the distance between line and a point.

:param pnt: the point to calculate distance
:type pnt: a Point object or a tuple with the coordinates

Return a namedtuple with:

```
* point: the closest point on the line,
* dist: the distance between these two points,
* spdist: distance to point on line from segment beginning
* sldist: distance to point on line form line beginning along line
```

The distance is compute using the `Vect_line_distance` C function.

```
>>> point = Point(2.3, 0.5)
>>> line = Line([(0, 0), (2, 0), (3, 0)])
>>> line.distance(point)  # doctest: +NORMALIZE_WHITESPACE
LineDist(point=Point(2.300000, 0.000000),
         dist=0.5, spdist=0.2999999999999998, sldist=2.3)
```

####### grass.pygrass.vector.geometry.Boundary.extend

```python
extend(line, forward=True)
```

Appends points to the end of a line.

:param line: it is possible to extend a line, give a list of points,
or directly with a line_pnts struct.
:type line: Line object of list of points
:param forward: if forward is True the line is extend forward otherwise
is extend backward. The method use the
`Vect_append_points` C function.
:type forward: bool

```
>>> line = Line([(0, 0), (1, 1)])
>>> line.extend(Line([(2, 2), (3, 3)]))
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 2.000000),
      Point(3.000000, 3.000000)])
```

####### grass.pygrass.vector.geometry.Boundary.first_cat

```python
first_cat()
```

Fetches FIRST category number for given vector line and field, using
the `Vect_get_line_cat` C function.

.. warning::

```
Not implemented yet.
```

####### grass.pygrass.vector.geometry.Boundary.from_wkt

```python
from_wkt(wkt)
```

Create a line reading a WKT string.

:param wkt: the WKT string containing the LINESTRING
:type wkt: str

```
>>> line = Line()
>>> line.from_wkt("LINESTRING(0 0,1 1,1 2)")
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(1.000000, 2.000000)])
```

..

####### grass.pygrass.vector.geometry.Boundary.gtype

```python
gtype = libvect.GV_BOUNDARY
```

####### grass.pygrass.vector.geometry.Boundary.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Boundary.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Boundary.insert

```python
insert(indx, pnt)
```

Insert new point at index position and move all old points at
that position and above up, using `Vect_line_insert_point`
C function.

:param indx: the index where add new point
:type indx: int
:param pnt: the point to add
:type pnt: a Point object

```
>>> line = Line([(0, 0), (1, 1)])
>>> line.insert(0, Point(1.000000, -1.000000))
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(1.000000, -1.000000),
      Point(0.000000, 0.000000),
      Point(1.000000, 1.000000)])
```

####### grass.pygrass.vector.geometry.Boundary.is2D

```python
is2D = is2D if is2D is not None else bool(libvect.Vect_is_3d(self.c_mapinfo) != 1)
```

####### grass.pygrass.vector.geometry.Boundary.left_area_id

```python
left_area_id
```

Left side area id, only available after read_area_ids() was called

####### grass.pygrass.vector.geometry.Boundary.left_centroid

```python
left_centroid(idonly=False)
```

Return left centroid

:param idonly: True to return only the cat of feature
:type idonly: bool

####### grass.pygrass.vector.geometry.Boundary.length

```python
length()
```

Calculate line length, 3D-length in case of 3D vector line, using
`Vect_line_length` C function. ::

```
>>> line = Line([(0, 0), (1, 1), (0, 1)])
>>> line.length()
2.414213562373095
```

..

####### grass.pygrass.vector.geometry.Boundary.length_geodesic

```python
length_geodesic()
```

Calculate line length, using `Vect_line_geodesic_length` C function.
::

```
>>> line = Line([(0, 0), (1, 1), (0, 1)])
>>> line.length_geodesic()
2.414213562373095
```

..

####### grass.pygrass.vector.geometry.Boundary.nodes

```python
nodes()
```

Return the start and end nodes of the line

This method requires topology build.

<details class="return" open>
<summary>A tuple of Node objects that represent the</summary>
start and end point of this line.
</details>

####### grass.pygrass.vector.geometry.Boundary.point_on_line

```python
point_on_line(distance, angle=0, slope=0)
```

Return a Point object on line in the specified distance, using the
`Vect_point_on_line` C function.
Raise a ValueError If the distance exceed the Line length. ::

```
>>> line = Line([(0, 0), (1, 1)])
>>> line.point_on_line(5)      #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: The distance exceed the length of the line,
that is: 1.414214
>>> line.point_on_line(1)
Point(0.707107, 0.707107)
```

..

####### grass.pygrass.vector.geometry.Boundary.pop

```python
pop(indx)
```

Return the point in the index position and remove from the Line.

:param indx: the index where add new point
:type indx: int

> > > line = Line([(0, 0), (1, 1), (2, 2)])
> > > midle_pnt = line.pop(1)
> > > midle_pnt # doctest: +NORMALIZE_WHITESPACE
> > > Point(1.000000, 1.000000)
> > > line # doctest: +NORMALIZE_WHITESPACE
> > > Line([Point(0.000000, 0.000000), Point(2.000000, 2.000000)])

####### grass.pygrass.vector.geometry.Boundary.prune

```python
prune()
```

Remove duplicate points, i.e. zero length segments, using
`Vect_line_prune` C function. ::

```
>>> line = Line([(0, 0), (1, 1), (1, 1), (2, 2)])
>>> line.prune()
>>> line                           #doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 2.000000)])
```

..

####### grass.pygrass.vector.geometry.Boundary.prune_thresh

```python
prune_thresh(threshold)
```

Remove points in threshold, using the `Vect_line_prune_thresh`
C function.

:param threshold: the threshold value where prune points
:type threshold: num

```
>>> line = Line([(0, 0), (1.0, 1.0), (1.2, 0.9), (2, 2)])
>>> line.prune_thresh(0.5)
>>> line  # doctest: +SKIP +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 2.000000)])
```

.. warning ::

```
prune_thresh is not working yet.
```

####### grass.pygrass.vector.geometry.Boundary.read

```python
read()
```

Read and set the coordinates of the centroid from the vector map,
using the centroid_id and calling the Vect_read_line C function

####### grass.pygrass.vector.geometry.Boundary.read_area_ids

```python
read_area_ids()
```

Read and return left and right area ids of the boundary

####### grass.pygrass.vector.geometry.Boundary.remove

```python
remove(pnt)
```

Delete point at given index and move all points above down, using
`Vect_line_delete_point` C function.

:param pnt: the point to remove
:type pnt: a Point object or a tuple with the coordinates

```
>>> line = Line([(0, 0), (1, 1), (2, 2)])
>>> line.remove((2, 2))
>>> line[-1]  # doctest: +NORMALIZE_WHITESPACE
Point(1.000000, 1.000000)
```

..

####### grass.pygrass.vector.geometry.Boundary.reset

```python
reset()
```

Reset line, using `Vect_reset_line` C function. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> len(line)
4
>>> line.reset()
>>> len(line)
0
>>> line
Line([])
```

..

####### grass.pygrass.vector.geometry.Boundary.reverse

```python
reverse()
```

Reverse the order of vertices, using `Vect_line_reverse`
C function. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 2)])
>>> line.reverse()
>>> line                           #doctest: +NORMALIZE_WHITESPACE
Line([Point(2.000000, 2.000000),
      Point(1.000000, 1.000000),
      Point(0.000000, 0.000000)])
```

..

####### grass.pygrass.vector.geometry.Boundary.right_area_id

```python
right_area_id
```

Right side area id, only available after read_area_ids() was called

####### grass.pygrass.vector.geometry.Boundary.right_centroid

```python
right_centroid(idonly=False)
```

Return right centroid

:param idonly: True to return only the cat of feature
:type idonly: bool

####### grass.pygrass.vector.geometry.Boundary.segment

```python
segment(start, end)
```

Create line segment. using the `Vect_line_segment` C function.

:param start: distance from the beginning of the line where the segment starts
:type start: float
:param end: distance from the beginning of the line where the segment ends
:type end: float

::
\# x (1, 1)
\# |
\# |-
\# |
\# x--------x (1, 0)
\# (0, 0) ^

```
>>> line = Line([(0, 0), (1, 0), (1, 1)])
>>> line.segment(0.5, 1.5)         #doctest: +NORMALIZE_WHITESPACE
Line([Point(0.500000, 0.000000),
      Point(1.000000, 0.000000),
      Point(1.000000, 0.500000)])
```

####### grass.pygrass.vector.geometry.Boundary.to_array

```python
to_array()
```

Return an array of coordinates. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> line.to_array()  # doctest: +NORMALIZE_WHITESPACE
array([[ 0.,  0.],
       [ 1.,  1.],
       [ 2.,  0.],
       [ 1., -1.]])
```

..

####### grass.pygrass.vector.geometry.Boundary.to_list

```python
to_list()
```

Return a list of tuple. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> line.to_list()
[(0.0, 0.0), (1.0, 1.0), (2.0, 0.0), (1.0, -1.0)]
```

..

####### grass.pygrass.vector.geometry.Boundary.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) geometry byte array, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > wkb = pnt.to_wkb()
> > > len(wkb)
> > > 21

####### grass.pygrass.vector.geometry.Boundary.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) geometry string, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > pnt.to_wkt()
> > > 'POINT (10.0000000000000000 100.0000000000000000)'

####### grass.pygrass.vector.geometry.Boundary.to_wkt_p

```python
to_wkt_p()
```

Return a Well Known Text string of the line. ::

```
>>> line = Line([(0, 0), (1, 1), (1, 2)])
>>> line.to_wkt_p()  # doctest: +ELLIPSIS
'LINESTRING(0.000000 0.000000, ..., 1.000000 2.000000)'
```

..

###### grass.pygrass.vector.geometry.Centroid

```python
Centroid(area_id=None, **kargs)
```

Bases: <code>[Point](#grass.pygrass.vector.geometry.Point)</code>

The Centroid class inherit from the Point class.
Centroid contains an attribute with the C Map_info struct, and attributes
with the id of the Area. ::

```
>>> centroid = Centroid(x=0, y=10)
>>> centroid
Centroid(0.000000, 10.000000)
>>> from grass.pygrass.vector import VectorTopo
>>> test_vect = VectorTopo(test_vector_name)
>>> test_vect.open(mode='r')
>>> centroid = Centroid(v_id=18, c_mapinfo=test_vect.c_mapinfo)
>>> centroid
Centroid(3.500000, 3.500000)
>>> test_vect.close()
```

..

**Functions:**

- [**buffer**](#grass.pygrass.vector.geometry.Centroid.buffer) – Return the buffer area around the point, using the
- [**coords**](#grass.pygrass.vector.geometry.Centroid.coords) – Return a tuple with the point coordinates. ::
- [**distance**](#grass.pygrass.vector.geometry.Centroid.distance) – Calculate distance of 2 points, using the Vect_points_distance
- [**has_topology**](#grass.pygrass.vector.geometry.Centroid.has_topology) –
- [**read**](#grass.pygrass.vector.geometry.Centroid.read) – Read and set the coordinates of the centroid from the vector map,
- [**to_wkb**](#grass.pygrass.vector.geometry.Centroid.to_wkb) – Return a "well know binary" (WKB) geometry byte array, this method uses
- [**to_wkt**](#grass.pygrass.vector.geometry.Centroid.to_wkt) – Return a "well know text" (WKT) geometry string, this method uses
- [**to_wkt_p**](#grass.pygrass.vector.geometry.Centroid.to_wkt_p) – Return a "well know text" (WKT) geometry string Python implementation. ::

**Attributes:**

- [**area_id**](#grass.pygrass.vector.geometry.Centroid.area_id) –
- [**attrs**](#grass.pygrass.vector.geometry.Centroid.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Centroid.c_cats) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Centroid.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Centroid.c_points) –
- [**cat**](#grass.pygrass.vector.geometry.Centroid.cat) –
- [**gtype**](#grass.pygrass.vector.geometry.Centroid.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Centroid.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Centroid.is2D) –
- [**x**](#grass.pygrass.vector.geometry.Centroid.x) –
- [**y**](#grass.pygrass.vector.geometry.Centroid.y) –
- [**z**](#grass.pygrass.vector.geometry.Centroid.z) –

####### grass.pygrass.vector.geometry.Centroid.area_id

```python
area_id = area_id
```

####### grass.pygrass.vector.geometry.Centroid.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Centroid.buffer

```python
buffer(dist=None, dist_x=None, dist_y=None, angle=0, round_=True, tol=0.1)
```

Return the buffer area around the point, using the
`Vect_point_buffer2` C function.

:param dist: the distance around the point
:type dist: num
:param dist_x: the distance along x
:type dist_x: num
:param dist_y: the distance along y
:type dist_y: num
:param angle: the angle between 0x and major axis
:type angle: num
:param round\_: to make corners round
:type round\_: bool
:param tol: fix the maximum distance between theoretical arc and output segments
:type tol: float
:returns: the buffer as Area object

> > > pnt = Point(0, 0)
> > > boundary, centroid = pnt.buffer(10)
> > > boundary # doctest: +ELLIPSIS
> > > Line([Point(10.000000, 0.000000),...Point(10.000000, 0.000000)])
> > > centroid
> > > Point(0.000000, 0.000000)

####### grass.pygrass.vector.geometry.Centroid.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Centroid.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Centroid.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Centroid.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Centroid.coords

```python
coords()
```

Return a tuple with the point coordinates. ::

```
>>> pnt = Point(10, 100)
>>> pnt.coords()
(10.0, 100.0)
```

If the point is 2D return a x, y tuple. But if we change the `z`
the Point object become a 3D point, therefore the method return a
x, y, z tuple. ::

```
>>> pnt.z = 1000.
>>> pnt.coords()
(10.0, 100.0, 1000.0)
```

..

####### grass.pygrass.vector.geometry.Centroid.distance

```python
distance(pnt)
```

Calculate distance of 2 points, using the Vect_points_distance
C function, If one of the point have z == None, return the 2D distance.

:param pnt: the point for calculate the distance
:type pnt: a Point object or a tuple with the coordinates

```
>>> pnt0 = Point(0, 0, 0)
>>> pnt1 = Point(1, 0)
>>> pnt0.distance(pnt1)
1.0
>>> pnt1.z = 1
>>> pnt1
Point(1.000000, 0.000000, 1.000000)
>>> pnt0.distance(pnt1)
1.4142135623730951
```

####### grass.pygrass.vector.geometry.Centroid.gtype

```python
gtype = libvect.GV_CENTROID
```

####### grass.pygrass.vector.geometry.Centroid.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Centroid.id

```python
id = self._centroid_id()
```

####### grass.pygrass.vector.geometry.Centroid.is2D

```python
is2D = z is None
```

####### grass.pygrass.vector.geometry.Centroid.read

```python
read()
```

Read and set the coordinates of the centroid from the vector map,
using the centroid_id and calling the Vect_read_line C function

####### grass.pygrass.vector.geometry.Centroid.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) geometry byte array, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > wkb = pnt.to_wkb()
> > > len(wkb)
> > > 21

####### grass.pygrass.vector.geometry.Centroid.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) geometry string, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > pnt.to_wkt()
> > > 'POINT (10.0000000000000000 100.0000000000000000)'

####### grass.pygrass.vector.geometry.Centroid.to_wkt_p

```python
to_wkt_p()
```

Return a "well know text" (WKT) geometry string Python implementation. ::

```
>>> pnt = Point(10, 100)
>>> pnt.to_wkt_p()
'POINT(10.000000 100.000000)'
```

.. warning::

```
Only ``POINT`` (2/3D) are supported, ``POINTM`` and ``POINT`` with:
``XYZM`` are not supported yet.
```

####### grass.pygrass.vector.geometry.Centroid.x

```python
x = property(fget=_get_x, fset=_set_x, doc='Set and obtain x coordinate')
```

####### grass.pygrass.vector.geometry.Centroid.y

```python
y = property(fget=_get_y, fset=_set_y, doc='Set and obtain y coordinate')
```

####### grass.pygrass.vector.geometry.Centroid.z

```python
z = property(fget=_get_z, fset=_set_z, doc='Set and obtain z coordinate')
```

###### grass.pygrass.vector.geometry.GEOOBJ

```python
GEOOBJ = {'areas': Area, 'dblinks': None, 'faces': None, 'holes': None, 'boundaries': Boundary, 'islands': Isle, 'kernels': None, 'line_points': None, 'points': Point, 'lines': Line, 'nodes': Node, 'volumes': None}
```

###### grass.pygrass.vector.geometry.GV_TYPE

```python
GV_TYPE = {libvect.GV_POINT: {'label': 'point', 'obj': Point}, libvect.GV_LINE: {'label': 'line', 'obj': Line}, libvect.GV_BOUNDARY: {'label': 'boundary', 'obj': Boundary}, libvect.GV_CENTROID: {'label': 'centroid', 'obj': Centroid}, libvect.GV_FACE: {'label': 'face', 'obj': None}, libvect.GV_KERNEL: {'label': 'kernel', 'obj': None}, libvect.GV_AREA: {'label': 'area', 'obj': Area}, libvect.GV_VOLUME: {'label': 'volume', 'obj': None}}
```

###### grass.pygrass.vector.geometry.Geo

```python
Geo(v_id=0, c_mapinfo=None, c_points=None, c_cats=None, table=None, writeable=False, is2D=True, free_points=False, free_cats=False)
```

Base object for different feature types

**Functions:**

- [**has_topology**](#grass.pygrass.vector.geometry.Geo.has_topology) –
- [**read**](#grass.pygrass.vector.geometry.Geo.read) – Read and set the coordinates of the centroid from the vector map,
- [**to_wkb**](#grass.pygrass.vector.geometry.Geo.to_wkb) – Return a "well know binary" (WKB) geometry byte array, this method uses
- [**to_wkt**](#grass.pygrass.vector.geometry.Geo.to_wkt) – Return a "well know text" (WKT) geometry string, this method uses

**Attributes:**

- [**attrs**](#grass.pygrass.vector.geometry.Geo.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Geo.c_cats) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Geo.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Geo.c_points) –
- [**cat**](#grass.pygrass.vector.geometry.Geo.cat) –
- [**gtype**](#grass.pygrass.vector.geometry.Geo.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Geo.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Geo.is2D) –

Constructor of a geometry object

:param v_id: The vector feature id
:param c_mapinfo: A pointer to the vector mapinfo structure
:param c_points: A pointer to a libvect.line_pnts structure, this
is optional, if not set an internal structure will
be allocated and free'd at object destruction
:param c_cats: A pointer to a libvect.line_cats structure, this
is optional, if not set an internal structure will
be allocated and free'd at object destruction
:param table: The attribute table to select attributes for
this feature
:param writeable: Not sure what this is for?
:param is2D: If True this feature has two dimensions, False if
this feature has three dimensions
:param free_points: Set this True if the provided c_points structure
should be free'd at object destruction, be aware
that no other object should free them, otherwise
you can expect a double free corruption segfault
:param free_cats: Set this True if the provided c_cats structure
should be free'd at object destruction, be aware
that no other object should free them, otherwise
you can expect a double free corruption segfault

####### grass.pygrass.vector.geometry.Geo.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Geo.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Geo.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Geo.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Geo.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Geo.gtype

```python
gtype = None
```

####### grass.pygrass.vector.geometry.Geo.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Geo.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Geo.is2D

```python
is2D = is2D if is2D is not None else bool(libvect.Vect_is_3d(self.c_mapinfo) != 1)
```

####### grass.pygrass.vector.geometry.Geo.read

```python
read()
```

Read and set the coordinates of the centroid from the vector map,
using the centroid_id and calling the Vect_read_line C function

####### grass.pygrass.vector.geometry.Geo.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) geometry byte array, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > wkb = pnt.to_wkb()
> > > len(wkb)
> > > 21

####### grass.pygrass.vector.geometry.Geo.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) geometry string, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > pnt.to_wkt()
> > > 'POINT (10.0000000000000000 100.0000000000000000)'

###### grass.pygrass.vector.geometry.Isle

```python
Isle(**kargs)
```

Bases: <code>[Geo](#grass.pygrass.vector.geometry.Geo)</code>

An Isle is an area contained by another area.

**Functions:**

- [**alive**](#grass.pygrass.vector.geometry.Isle.alive) – Check if isle is alive or dead (topology required)
- [**area**](#grass.pygrass.vector.geometry.Isle.area) – Return the area value of an Isle
- [**area_id**](#grass.pygrass.vector.geometry.Isle.area_id) – Returns area id for isle.
- [**bbox**](#grass.pygrass.vector.geometry.Isle.bbox) – Return bounding box of Isle
- [**boundaries**](#grass.pygrass.vector.geometry.Isle.boundaries) – Return a list of boundaries
- [**contain_pnt**](#grass.pygrass.vector.geometry.Isle.contain_pnt) – Check if point is in area.
- [**has_topology**](#grass.pygrass.vector.geometry.Isle.has_topology) –
- [**perimeter**](#grass.pygrass.vector.geometry.Isle.perimeter) – Return the perimeter value of an Isle.
- [**points**](#grass.pygrass.vector.geometry.Isle.points) – Return a Line object with the outer ring points
- [**points_geos**](#grass.pygrass.vector.geometry.Isle.points_geos) – Return a Line object with the outer ring points
- [**read**](#grass.pygrass.vector.geometry.Isle.read) – Read and set the coordinates of the centroid from the vector map,
- [**to_wkb**](#grass.pygrass.vector.geometry.Isle.to_wkb) – Return a "well know text" (WKB) geometry array. ::
- [**to_wkt**](#grass.pygrass.vector.geometry.Isle.to_wkt) – Return a Well Known Text string of the isle. ::

**Attributes:**

- [**attrs**](#grass.pygrass.vector.geometry.Isle.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Isle.c_cats) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Isle.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Isle.c_points) –
- [**cat**](#grass.pygrass.vector.geometry.Isle.cat) –
- [**gtype**](#grass.pygrass.vector.geometry.Isle.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Isle.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Isle.is2D) –

####### grass.pygrass.vector.geometry.Isle.alive

```python
alive()
```

Check if isle is alive or dead (topology required)

####### grass.pygrass.vector.geometry.Isle.area

```python
area()
```

Return the area value of an Isle

####### grass.pygrass.vector.geometry.Isle.area_id

```python
area_id()
```

Returns area id for isle.

####### grass.pygrass.vector.geometry.Isle.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Isle.bbox

```python
bbox(bbox=None)
```

Return bounding box of Isle

####### grass.pygrass.vector.geometry.Isle.boundaries

```python
boundaries()
```

Return a list of boundaries

####### grass.pygrass.vector.geometry.Isle.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Isle.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Isle.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Isle.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Isle.contain_pnt

```python
contain_pnt(pnt)
```

Check if point is in area.

:param pnt: the point to remove
:type pnt: a Point object or a tuple with the coordinates

####### grass.pygrass.vector.geometry.Isle.gtype

```python
gtype = None
```

####### grass.pygrass.vector.geometry.Isle.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Isle.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Isle.is2D

```python
is2D = is2D if is2D is not None else bool(libvect.Vect_is_3d(self.c_mapinfo) != 1)
```

####### grass.pygrass.vector.geometry.Isle.perimeter

```python
perimeter()
```

Return the perimeter value of an Isle.

####### grass.pygrass.vector.geometry.Isle.points

```python
points()
```

Return a Line object with the outer ring points

####### grass.pygrass.vector.geometry.Isle.points_geos

```python
points_geos()
```

Return a Line object with the outer ring points

####### grass.pygrass.vector.geometry.Isle.read

```python
read()
```

Read and set the coordinates of the centroid from the vector map,
using the centroid_id and calling the Vect_read_line C function

####### grass.pygrass.vector.geometry.Isle.to_wkb

```python
to_wkb()
```

Return a "well know text" (WKB) geometry array. ::

####### grass.pygrass.vector.geometry.Isle.to_wkt

```python
to_wkt()
```

Return a Well Known Text string of the isle. ::

For now the outer ring is returned

TODO: Implement inner rings detected from isles

###### grass.pygrass.vector.geometry.Isles

```python
Isles(c_mapinfo, area_id=None)
```

**Functions:**

- [**isles**](#grass.pygrass.vector.geometry.Isles.isles) – Return isles
- [**isles_ids**](#grass.pygrass.vector.geometry.Isles.isles_ids) – Return the id of isles

**Attributes:**

- [**area_id**](#grass.pygrass.vector.geometry.Isles.area_id) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Isles.c_mapinfo) –

####### grass.pygrass.vector.geometry.Isles.area_id

```python
area_id = area_id
```

####### grass.pygrass.vector.geometry.Isles.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Isles.isles

```python
isles()
```

Return isles

####### grass.pygrass.vector.geometry.Isles.isles_ids

```python
isles_ids()
```

Return the id of isles

###### grass.pygrass.vector.geometry.Line

```python
Line(points=None, **kargs)
```

Bases: <code>[Geo](#grass.pygrass.vector.geometry.Geo)</code>

Instantiate a new Line with a list of tuple, or with a list of Point. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 0.000000),
      Point(1.000000, -1.000000)])
```

..

**Functions:**

- [**alive**](#grass.pygrass.vector.geometry.Line.alive) – Return True if this line is alive or False if this line is
- [**append**](#grass.pygrass.vector.geometry.Line.append) – Appends one point to the end of a line, using the
- [**bbox**](#grass.pygrass.vector.geometry.Line.bbox) – Return the bounding box of the line, using `Vect_line_box`
- [**buffer**](#grass.pygrass.vector.geometry.Line.buffer) – Return the buffer area around the line, using the
- [**delete**](#grass.pygrass.vector.geometry.Line.delete) – Remove the point in the index position.
- [**distance**](#grass.pygrass.vector.geometry.Line.distance) – Calculate the distance between line and a point.
- [**extend**](#grass.pygrass.vector.geometry.Line.extend) – Appends points to the end of a line.
- [**first_cat**](#grass.pygrass.vector.geometry.Line.first_cat) – Fetches FIRST category number for given vector line and field, using
- [**from_wkt**](#grass.pygrass.vector.geometry.Line.from_wkt) – Create a line reading a WKT string.
- [**has_topology**](#grass.pygrass.vector.geometry.Line.has_topology) –
- [**insert**](#grass.pygrass.vector.geometry.Line.insert) – Insert new point at index position and move all old points at
- [**length**](#grass.pygrass.vector.geometry.Line.length) – Calculate line length, 3D-length in case of 3D vector line, using
- [**length_geodesic**](#grass.pygrass.vector.geometry.Line.length_geodesic) – Calculate line length, using `Vect_line_geodesic_length` C function.
- [**nodes**](#grass.pygrass.vector.geometry.Line.nodes) – Return the start and end nodes of the line
- [**point_on_line**](#grass.pygrass.vector.geometry.Line.point_on_line) – Return a Point object on line in the specified distance, using the
- [**pop**](#grass.pygrass.vector.geometry.Line.pop) – Return the point in the index position and remove from the Line.
- [**prune**](#grass.pygrass.vector.geometry.Line.prune) – Remove duplicate points, i.e. zero length segments, using
- [**prune_thresh**](#grass.pygrass.vector.geometry.Line.prune_thresh) – Remove points in threshold, using the `Vect_line_prune_thresh`
- [**read**](#grass.pygrass.vector.geometry.Line.read) – Read and set the coordinates of the centroid from the vector map,
- [**remove**](#grass.pygrass.vector.geometry.Line.remove) – Delete point at given index and move all points above down, using
- [**reset**](#grass.pygrass.vector.geometry.Line.reset) – Reset line, using `Vect_reset_line` C function. ::
- [**reverse**](#grass.pygrass.vector.geometry.Line.reverse) – Reverse the order of vertices, using `Vect_line_reverse`
- [**segment**](#grass.pygrass.vector.geometry.Line.segment) – Create line segment. using the `Vect_line_segment` C function.
- [**to_array**](#grass.pygrass.vector.geometry.Line.to_array) – Return an array of coordinates. ::
- [**to_list**](#grass.pygrass.vector.geometry.Line.to_list) – Return a list of tuple. ::
- [**to_wkb**](#grass.pygrass.vector.geometry.Line.to_wkb) – Return a "well know binary" (WKB) geometry byte array, this method uses
- [**to_wkt**](#grass.pygrass.vector.geometry.Line.to_wkt) – Return a "well know text" (WKT) geometry string, this method uses
- [**to_wkt_p**](#grass.pygrass.vector.geometry.Line.to_wkt_p) – Return a Well Known Text string of the line. ::

**Attributes:**

- [**attrs**](#grass.pygrass.vector.geometry.Line.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Line.c_cats) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Line.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Line.c_points) –
- [**cat**](#grass.pygrass.vector.geometry.Line.cat) –
- [**gtype**](#grass.pygrass.vector.geometry.Line.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Line.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Line.is2D) –

####### grass.pygrass.vector.geometry.Line.alive

```python
alive()
```

Return True if this line is alive or False if this line is
dead or its index is out of range.

####### grass.pygrass.vector.geometry.Line.append

```python
append(pnt)
```

Appends one point to the end of a line, using the
`Vect_append_point` C function.

:param pnt: the point to add to line
:type pnt: a Point object or a tuple with the coordinates

```
>>> line = Line()
>>> line.append((10, 100))
>>> line
Line([Point(10.000000, 100.000000)])
>>> line.append((20, 200))
>>> line
Line([Point(10.000000, 100.000000), Point(20.000000, 200.000000)])
```

Like python list.

####### grass.pygrass.vector.geometry.Line.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Line.bbox

```python
bbox(bbox=None)
```

Return the bounding box of the line, using `Vect_line_box`
C function. ::

```
>>> line = Line([(0, 0), (0, 1), (2, 1), (2, 0)])
>>> bbox = line.bbox()
>>> bbox
Bbox(1.0, 0.0, 2.0, 0.0)
```

..

####### grass.pygrass.vector.geometry.Line.buffer

```python
buffer(dist=None, dist_x=None, dist_y=None, angle=0, round_=True, caps=True, tol=0.1)
```

Return the buffer area around the line, using the
`Vect_line_buffer2` C function.

:param dist: the distance around the line
:type dist: num
:param dist_x: the distance along x
:type dist_x: num
:param dist_y: the distance along y
:type dist_y: num
:param angle: the angle between 0x and major axis
:type angle: num
:param round\_: to make corners round
:type round\_: bool
:param tol: fix the maximum distance between theoretical arc and output segments
:type tol: float
:returns: the buffer as Area object

> > > line = Line([(0, 0), (0, 2)])
> > > boundary, centroid, isles = line.buffer(10)
> > > boundary # doctest: +ELLIPSIS
> > > Line([Point(-10.000000, 0.000000),...Point(-10.000000, 0.000000)])
> > > centroid # doctest: +NORMALIZE_WHITESPACE
> > > Point(0.000000, 0.000000)
> > > isles
> > > []

..

####### grass.pygrass.vector.geometry.Line.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Line.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Line.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Line.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Line.delete

```python
delete(indx)
```

Remove the point in the index position.
:param indx: the index where add new point
:type indx: int

> > > line = Line([(0, 0), (1, 1), (2, 2)])
> > > line.delete(-1)
> > > line # doctest: +NORMALIZE_WHITESPACE
> > > Line([Point(0.000000, 0.000000), Point(1.000000, 1.000000)])

####### grass.pygrass.vector.geometry.Line.distance

```python
distance(pnt)
```

Calculate the distance between line and a point.

:param pnt: the point to calculate distance
:type pnt: a Point object or a tuple with the coordinates

Return a namedtuple with:

```
* point: the closest point on the line,
* dist: the distance between these two points,
* spdist: distance to point on line from segment beginning
* sldist: distance to point on line form line beginning along line
```

The distance is compute using the `Vect_line_distance` C function.

```
>>> point = Point(2.3, 0.5)
>>> line = Line([(0, 0), (2, 0), (3, 0)])
>>> line.distance(point)  # doctest: +NORMALIZE_WHITESPACE
LineDist(point=Point(2.300000, 0.000000),
         dist=0.5, spdist=0.2999999999999998, sldist=2.3)
```

####### grass.pygrass.vector.geometry.Line.extend

```python
extend(line, forward=True)
```

Appends points to the end of a line.

:param line: it is possible to extend a line, give a list of points,
or directly with a line_pnts struct.
:type line: Line object of list of points
:param forward: if forward is True the line is extend forward otherwise
is extend backward. The method use the
`Vect_append_points` C function.
:type forward: bool

```
>>> line = Line([(0, 0), (1, 1)])
>>> line.extend(Line([(2, 2), (3, 3)]))
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 2.000000),
      Point(3.000000, 3.000000)])
```

####### grass.pygrass.vector.geometry.Line.first_cat

```python
first_cat()
```

Fetches FIRST category number for given vector line and field, using
the `Vect_get_line_cat` C function.

.. warning::

```
Not implemented yet.
```

####### grass.pygrass.vector.geometry.Line.from_wkt

```python
from_wkt(wkt)
```

Create a line reading a WKT string.

:param wkt: the WKT string containing the LINESTRING
:type wkt: str

```
>>> line = Line()
>>> line.from_wkt("LINESTRING(0 0,1 1,1 2)")
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(1.000000, 2.000000)])
```

..

####### grass.pygrass.vector.geometry.Line.gtype

```python
gtype = libvect.GV_LINE
```

####### grass.pygrass.vector.geometry.Line.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Line.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Line.insert

```python
insert(indx, pnt)
```

Insert new point at index position and move all old points at
that position and above up, using `Vect_line_insert_point`
C function.

:param indx: the index where add new point
:type indx: int
:param pnt: the point to add
:type pnt: a Point object

```
>>> line = Line([(0, 0), (1, 1)])
>>> line.insert(0, Point(1.000000, -1.000000))
>>> line  # doctest: +NORMALIZE_WHITESPACE
Line([Point(1.000000, -1.000000),
      Point(0.000000, 0.000000),
      Point(1.000000, 1.000000)])
```

####### grass.pygrass.vector.geometry.Line.is2D

```python
is2D = is2D if is2D is not None else bool(libvect.Vect_is_3d(self.c_mapinfo) != 1)
```

####### grass.pygrass.vector.geometry.Line.length

```python
length()
```

Calculate line length, 3D-length in case of 3D vector line, using
`Vect_line_length` C function. ::

```
>>> line = Line([(0, 0), (1, 1), (0, 1)])
>>> line.length()
2.414213562373095
```

..

####### grass.pygrass.vector.geometry.Line.length_geodesic

```python
length_geodesic()
```

Calculate line length, using `Vect_line_geodesic_length` C function.
::

```
>>> line = Line([(0, 0), (1, 1), (0, 1)])
>>> line.length_geodesic()
2.414213562373095
```

..

####### grass.pygrass.vector.geometry.Line.nodes

```python
nodes()
```

Return the start and end nodes of the line

This method requires topology build.

<details class="return" open>
<summary>A tuple of Node objects that represent the</summary>
start and end point of this line.
</details>

####### grass.pygrass.vector.geometry.Line.point_on_line

```python
point_on_line(distance, angle=0, slope=0)
```

Return a Point object on line in the specified distance, using the
`Vect_point_on_line` C function.
Raise a ValueError If the distance exceed the Line length. ::

```
>>> line = Line([(0, 0), (1, 1)])
>>> line.point_on_line(5)      #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
Traceback (most recent call last):
    ...
ValueError: The distance exceed the length of the line,
that is: 1.414214
>>> line.point_on_line(1)
Point(0.707107, 0.707107)
```

..

####### grass.pygrass.vector.geometry.Line.pop

```python
pop(indx)
```

Return the point in the index position and remove from the Line.

:param indx: the index where add new point
:type indx: int

> > > line = Line([(0, 0), (1, 1), (2, 2)])
> > > midle_pnt = line.pop(1)
> > > midle_pnt # doctest: +NORMALIZE_WHITESPACE
> > > Point(1.000000, 1.000000)
> > > line # doctest: +NORMALIZE_WHITESPACE
> > > Line([Point(0.000000, 0.000000), Point(2.000000, 2.000000)])

####### grass.pygrass.vector.geometry.Line.prune

```python
prune()
```

Remove duplicate points, i.e. zero length segments, using
`Vect_line_prune` C function. ::

```
>>> line = Line([(0, 0), (1, 1), (1, 1), (2, 2)])
>>> line.prune()
>>> line                           #doctest: +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 2.000000)])
```

..

####### grass.pygrass.vector.geometry.Line.prune_thresh

```python
prune_thresh(threshold)
```

Remove points in threshold, using the `Vect_line_prune_thresh`
C function.

:param threshold: the threshold value where prune points
:type threshold: num

```
>>> line = Line([(0, 0), (1.0, 1.0), (1.2, 0.9), (2, 2)])
>>> line.prune_thresh(0.5)
>>> line  # doctest: +SKIP +NORMALIZE_WHITESPACE
Line([Point(0.000000, 0.000000),
      Point(1.000000, 1.000000),
      Point(2.000000, 2.000000)])
```

.. warning ::

```
prune_thresh is not working yet.
```

####### grass.pygrass.vector.geometry.Line.read

```python
read()
```

Read and set the coordinates of the centroid from the vector map,
using the centroid_id and calling the Vect_read_line C function

####### grass.pygrass.vector.geometry.Line.remove

```python
remove(pnt)
```

Delete point at given index and move all points above down, using
`Vect_line_delete_point` C function.

:param pnt: the point to remove
:type pnt: a Point object or a tuple with the coordinates

```
>>> line = Line([(0, 0), (1, 1), (2, 2)])
>>> line.remove((2, 2))
>>> line[-1]  # doctest: +NORMALIZE_WHITESPACE
Point(1.000000, 1.000000)
```

..

####### grass.pygrass.vector.geometry.Line.reset

```python
reset()
```

Reset line, using `Vect_reset_line` C function. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> len(line)
4
>>> line.reset()
>>> len(line)
0
>>> line
Line([])
```

..

####### grass.pygrass.vector.geometry.Line.reverse

```python
reverse()
```

Reverse the order of vertices, using `Vect_line_reverse`
C function. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 2)])
>>> line.reverse()
>>> line                           #doctest: +NORMALIZE_WHITESPACE
Line([Point(2.000000, 2.000000),
      Point(1.000000, 1.000000),
      Point(0.000000, 0.000000)])
```

..

####### grass.pygrass.vector.geometry.Line.segment

```python
segment(start, end)
```

Create line segment. using the `Vect_line_segment` C function.

:param start: distance from the beginning of the line where the segment starts
:type start: float
:param end: distance from the beginning of the line where the segment ends
:type end: float

::
\# x (1, 1)
\# |
\# |-
\# |
\# x--------x (1, 0)
\# (0, 0) ^

```
>>> line = Line([(0, 0), (1, 0), (1, 1)])
>>> line.segment(0.5, 1.5)         #doctest: +NORMALIZE_WHITESPACE
Line([Point(0.500000, 0.000000),
      Point(1.000000, 0.000000),
      Point(1.000000, 0.500000)])
```

####### grass.pygrass.vector.geometry.Line.to_array

```python
to_array()
```

Return an array of coordinates. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> line.to_array()  # doctest: +NORMALIZE_WHITESPACE
array([[ 0.,  0.],
       [ 1.,  1.],
       [ 2.,  0.],
       [ 1., -1.]])
```

..

####### grass.pygrass.vector.geometry.Line.to_list

```python
to_list()
```

Return a list of tuple. ::

```
>>> line = Line([(0, 0), (1, 1), (2, 0), (1, -1)])
>>> line.to_list()
[(0.0, 0.0), (1.0, 1.0), (2.0, 0.0), (1.0, -1.0)]
```

..

####### grass.pygrass.vector.geometry.Line.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) geometry byte array, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > wkb = pnt.to_wkb()
> > > len(wkb)
> > > 21

####### grass.pygrass.vector.geometry.Line.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) geometry string, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > pnt.to_wkt()
> > > 'POINT (10.0000000000000000 100.0000000000000000)'

####### grass.pygrass.vector.geometry.Line.to_wkt_p

```python
to_wkt_p()
```

Return a Well Known Text string of the line. ::

```
>>> line = Line([(0, 0), (1, 1), (1, 2)])
>>> line.to_wkt_p()  # doctest: +ELLIPSIS
'LINESTRING(0.000000 0.000000, ..., 1.000000 2.000000)'
```

..

###### grass.pygrass.vector.geometry.LineDist

```python
LineDist = namedtuple('LineDist', 'point dist spdist sldist')
```

###### grass.pygrass.vector.geometry.Node

```python
Node(v_id, c_mapinfo, **kwords)
```

Node class for topological analysis of line neighbors.

Objects of this class will be returned by the node() function
of a Line object.

All methods in this class require a proper setup of the Node
objects. Hence, the correct id and a valid pointer to a mapinfo
object must be provided in the constructions. Otherwise a segfault
may happen.

**Functions:**

- [**alive**](#grass.pygrass.vector.geometry.Node.alive) – Return True if this node is alive or False if this node is
- [**angles**](#grass.pygrass.vector.geometry.Node.angles) – Return a generator with all lines angles in a node.
- [**coords**](#grass.pygrass.vector.geometry.Node.coords) – Return a tuple with the node coordinates.
- [**ilines**](#grass.pygrass.vector.geometry.Node.ilines) – Return a generator with all lines id connected to a node.
- [**lines**](#grass.pygrass.vector.geometry.Node.lines) – Return a generator with all lines connected to a node.
- [**to_wkb**](#grass.pygrass.vector.geometry.Node.to_wkb) – Return a "well know binary" (WKB) geometry array. ::
- [**to_wkt**](#grass.pygrass.vector.geometry.Node.to_wkt) – Return a "well know text" (WKT) geometry string. ::

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.geometry.Node.c_mapinfo) –
- [**id**](#grass.pygrass.vector.geometry.Node.id) –

Construct a Node object

param v_id: The unique node id
param c_mapinfo: A valid pointer to the mapinfo object
param \*\*kwords: Ignored

####### grass.pygrass.vector.geometry.Node.alive

```python
alive()
```

Return True if this node is alive or False if this node is
dead or its index is out of range.

####### grass.pygrass.vector.geometry.Node.angles

```python
angles()
```

Return a generator with all lines angles in a node.

####### grass.pygrass.vector.geometry.Node.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Node.coords

```python
coords()
```

Return a tuple with the node coordinates.

####### grass.pygrass.vector.geometry.Node.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Node.ilines

```python
ilines(only_in=False, only_out=False)
```

Return a generator with all lines id connected to a node.
The line id is negative if line is ending on the node and positive if
starting from the node.

:param only_in: Return only the lines that are ending in the node
:type only_in: bool
:param only_out: Return only the lines that are starting in the node
:type only_out: bool

####### grass.pygrass.vector.geometry.Node.lines

```python
lines(only_in=False, only_out=False)
```

Return a generator with all lines connected to a node.

:param only_in: Return only the lines that are ending in the node
:type only_in: bool
:param only_out: Return only the lines that are starting in the node
:type only_out: bool

####### grass.pygrass.vector.geometry.Node.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) geometry array. ::

TODO: Must be implemented

####### grass.pygrass.vector.geometry.Node.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) geometry string. ::

###### grass.pygrass.vector.geometry.Point

```python
Point(x=0, y=0, z=None, **kargs)
```

Bases: <code>[Geo](#grass.pygrass.vector.geometry.Geo)</code>

Instantiate a Point object that could be 2 or 3D, default
parameters are 0.

::

```
>>> pnt = Point()
>>> pnt.x
0.0
>>> pnt.y
0.0
>>> pnt.z
>>> pnt.is2D
True
>>> pnt
Point(0.000000, 0.000000)
>>> pnt.z = 0
>>> pnt.is2D
False
>>> pnt
Point(0.000000, 0.000000, 0.000000)
>>> print(pnt)
POINT Z (0.0000000000000000 0.0000000000000000 0.0000000000000000)


>>> c_points = ctypes.pointer(libvect.line_pnts())
>>> c_cats = ctypes.pointer(libvect.line_cats())
>>> p = Point(c_points = c_points, c_cats=c_cats)
>>> del p


>>> c_points = ctypes.pointer(libvect.line_pnts())
>>> c_cats = ctypes.pointer(libvect.line_cats())
>>> p = Point(c_points=c_points, c_cats=c_cats, free_points=True,
...           free_cats=True)
>>> del p
```

..

**Functions:**

- [**buffer**](#grass.pygrass.vector.geometry.Point.buffer) – Return the buffer area around the point, using the
- [**coords**](#grass.pygrass.vector.geometry.Point.coords) – Return a tuple with the point coordinates. ::
- [**distance**](#grass.pygrass.vector.geometry.Point.distance) – Calculate distance of 2 points, using the Vect_points_distance
- [**has_topology**](#grass.pygrass.vector.geometry.Point.has_topology) –
- [**read**](#grass.pygrass.vector.geometry.Point.read) – Read and set the coordinates of the centroid from the vector map,
- [**to_wkb**](#grass.pygrass.vector.geometry.Point.to_wkb) – Return a "well know binary" (WKB) geometry byte array, this method uses
- [**to_wkt**](#grass.pygrass.vector.geometry.Point.to_wkt) – Return a "well know text" (WKT) geometry string, this method uses
- [**to_wkt_p**](#grass.pygrass.vector.geometry.Point.to_wkt_p) – Return a "well know text" (WKT) geometry string Python implementation. ::

**Attributes:**

- [**attrs**](#grass.pygrass.vector.geometry.Point.attrs) –
- [**c_cats**](#grass.pygrass.vector.geometry.Point.c_cats) –
- [**c_mapinfo**](#grass.pygrass.vector.geometry.Point.c_mapinfo) –
- [**c_points**](#grass.pygrass.vector.geometry.Point.c_points) –
- [**cat**](#grass.pygrass.vector.geometry.Point.cat) –
- [**gtype**](#grass.pygrass.vector.geometry.Point.gtype) –
- [**id**](#grass.pygrass.vector.geometry.Point.id) –
- [**is2D**](#grass.pygrass.vector.geometry.Point.is2D) –
- [**x**](#grass.pygrass.vector.geometry.Point.x) –
- [**y**](#grass.pygrass.vector.geometry.Point.y) –
- [**z**](#grass.pygrass.vector.geometry.Point.z) –

####### grass.pygrass.vector.geometry.Point.attrs

```python
attrs = None
```

####### grass.pygrass.vector.geometry.Point.buffer

```python
buffer(dist=None, dist_x=None, dist_y=None, angle=0, round_=True, tol=0.1)
```

Return the buffer area around the point, using the
`Vect_point_buffer2` C function.

:param dist: the distance around the point
:type dist: num
:param dist_x: the distance along x
:type dist_x: num
:param dist_y: the distance along y
:type dist_y: num
:param angle: the angle between 0x and major axis
:type angle: num
:param round\_: to make corners round
:type round\_: bool
:param tol: fix the maximum distance between theoretical arc and output segments
:type tol: float
:returns: the buffer as Area object

> > > pnt = Point(0, 0)
> > > boundary, centroid = pnt.buffer(10)
> > > boundary # doctest: +ELLIPSIS
> > > Line([Point(10.000000, 0.000000),...Point(10.000000, 0.000000)])
> > > centroid
> > > Point(0.000000, 0.000000)

####### grass.pygrass.vector.geometry.Point.c_cats

```python
c_cats = ctypes.pointer(libvect.line_cats())
```

####### grass.pygrass.vector.geometry.Point.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.geometry.Point.c_points

```python
c_points = ctypes.pointer(libvect.line_pnts())
```

####### grass.pygrass.vector.geometry.Point.cat

```python
cat
```

####### grass.pygrass.vector.geometry.Point.coords

```python
coords()
```

Return a tuple with the point coordinates. ::

```
>>> pnt = Point(10, 100)
>>> pnt.coords()
(10.0, 100.0)
```

If the point is 2D return a x, y tuple. But if we change the `z`
the Point object become a 3D point, therefore the method return a
x, y, z tuple. ::

```
>>> pnt.z = 1000.
>>> pnt.coords()
(10.0, 100.0, 1000.0)
```

..

####### grass.pygrass.vector.geometry.Point.distance

```python
distance(pnt)
```

Calculate distance of 2 points, using the Vect_points_distance
C function, If one of the point have z == None, return the 2D distance.

:param pnt: the point for calculate the distance
:type pnt: a Point object or a tuple with the coordinates

```
>>> pnt0 = Point(0, 0, 0)
>>> pnt1 = Point(1, 0)
>>> pnt0.distance(pnt1)
1.0
>>> pnt1.z = 1
>>> pnt1
Point(1.000000, 0.000000, 1.000000)
>>> pnt0.distance(pnt1)
1.4142135623730951
```

####### grass.pygrass.vector.geometry.Point.gtype

```python
gtype = libvect.GV_POINT
```

####### grass.pygrass.vector.geometry.Point.has_topology

```python
has_topology()
```

####### grass.pygrass.vector.geometry.Point.id

```python
id = v_id
```

####### grass.pygrass.vector.geometry.Point.is2D

```python
is2D = z is None
```

####### grass.pygrass.vector.geometry.Point.read

```python
read()
```

Read and set the coordinates of the centroid from the vector map,
using the centroid_id and calling the Vect_read_line C function

####### grass.pygrass.vector.geometry.Point.to_wkb

```python
to_wkb()
```

Return a "well know binary" (WKB) geometry byte array, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > wkb = pnt.to_wkb()
> > > len(wkb)
> > > 21

####### grass.pygrass.vector.geometry.Point.to_wkt

```python
to_wkt()
```

Return a "well know text" (WKT) geometry string, this method uses
the GEOS implementation in the vector library. ::

> > > pnt = Point(10, 100)
> > > pnt.to_wkt()
> > > 'POINT (10.0000000000000000 100.0000000000000000)'

####### grass.pygrass.vector.geometry.Point.to_wkt_p

```python
to_wkt_p()
```

Return a "well know text" (WKT) geometry string Python implementation. ::

```
>>> pnt = Point(10, 100)
>>> pnt.to_wkt_p()
'POINT(10.000000 100.000000)'
```

.. warning::

```
Only ``POINT`` (2/3D) are supported, ``POINTM`` and ``POINT`` with:
``XYZM`` are not supported yet.
```

####### grass.pygrass.vector.geometry.Point.x

```python
x = property(fget=_get_x, fset=_set_x, doc='Set and obtain x coordinate')
```

####### grass.pygrass.vector.geometry.Point.y

```python
y = property(fget=_get_y, fset=_set_y, doc='Set and obtain y coordinate')
```

####### grass.pygrass.vector.geometry.Point.z

```python
z = property(fget=_get_z, fset=_set_z, doc='Set and obtain z coordinate')
```

###### grass.pygrass.vector.geometry.WKT

```python
WKT = {'POINT\\((.*)\\)': 'point', 'LINESTRING\\((.*)\\)': 'line'}
```

###### grass.pygrass.vector.geometry.c_read_line

```python
c_read_line(feature_id, c_mapinfo, c_points, c_cats)
```

###### grass.pygrass.vector.geometry.c_read_next_line

```python
c_read_next_line(c_mapinfo, c_points, c_cats)
```

###### grass.pygrass.vector.geometry.get_xyz

```python
get_xyz(pnt)
```

Return a tuple with: x, y, z.

> > > pnt = Point(0, 0)
> > > get_xyz(pnt)
> > > (0.0, 0.0, 0.0)
> > > get_xyz((1, 1))
> > > (1, 1, 0.0)
> > > get_xyz((1, 1, 2))
> > > (1, 1, 2)
> > > get_xyz((1, 1, 2, 2)) # doctest: +ELLIPSIS
> > > Traceback (most recent call last):
> > > ...
> > > ValueError: The the format of the point is not supported: (1, 1, 2, 2)

###### grass.pygrass.vector.geometry.intersects

```python
intersects(lineA, lineB, with_z=False)
```

Return a list of points

> > > lineA = Line([(0, 0), (4, 0)])
> > > lineB = Line([(2, 2), (2, -2)])
> > > intersects(lineA, lineB)
> > > Line([Point(2.000000, 0.000000)])

###### grass.pygrass.vector.geometry.mset

```python
mset = get_mapset_vector(test_vector_name, mapset='')
```

###### grass.pygrass.vector.geometry.read_WKB

```python
read_WKB(buff)
```

Read the binary buffer and return a geometry object

###### grass.pygrass.vector.geometry.read_WKT

```python
read_WKT(string)
```

Read the string and return a geometry object

**WKT**:
::

```
POINT(0 0)
LINESTRING(0 0,1 1,1 2)
POLYGON((0 0,4 0,4 4,0 4,0 0),(1 1, 2 1, 2 2, 1 2,1 1))
MULTIPOINT(0 0,1 2)
MULTILINESTRING((0 0,1 1,1 2),(2 3,3 2,5 4))
MULTIPOLYGON(((0 0,4 0,4 4,0 4,0 0),(1 1,2 1,2 2,1 2,1 1)),
             ((-1 -1,-1 -2,-2 -2,-2 -1,-1 -1)))
GEOMETRYCOLLECTION(POINT(2 3),LINESTRING(2 3,3 4))
```

**EWKT**:

::

```
POINT(0 0 0) -- XYZ
SRID=32632;POINT(0 0) -- XY with SRID
POINTM(0 0 0) -- XYM
POINT(0 0 0 0) -- XYZM
SRID=4326;MULTIPOINTM(0 0 0,1 2 1) -- XYM with SRID
MULTILINESTRING((0 0 0,1 1 0,1 2 1),(2 3 1,3 2 1,5 4 1))
POLYGON((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),(1 1 0,2 1 0,2 2 0,1 2 0,1 1 0))
MULTIPOLYGON(((0 0 0,4 0 0,4 4 0,0 4 0,0 0 0),
              (1 1 0,2 1 0,2 2 0,1 2 0,1 1 0)),
             ((-1 -1 0,-1 -2 0,-2 -2 0,-2 -1 0,-1 -1 0)))
GEOMETRYCOLLECTIONM( POINTM(2 3 9), LINESTRINGM(2 3 4, 3 4 5) )
MULTICURVE( (0 0, 5 5), CIRCULARSTRING(4 0, 4 4, 8 4) )
POLYHEDRALSURFACE( ((0 0 0, 0 0 1, 0 1 1, 0 1 0, 0 0 0)),
                   ((0 0 0, 0 1 0, 1 1 0, 1 0 0, 0 0 0)),
                   ((0 0 0, 1 0 0, 1 0 1, 0 0 1, 0 0 0)),
                   ((1 1 0, 1 1 1, 1 0 1, 1 0 0, 1 1 0)),
                   ((0 1 0, 0 1 1, 1 1 1, 1 1 0, 0 1 0)),
                   ((0 0 1, 1 0 1, 1 1 1, 0 1 1, 0 0 1)) )
TRIANGLE ((0 0, 0 9, 9 0, 0 0))
TIN( ((0 0 0, 0 0 1, 0 1 0, 0 0 0)), ((0 0 0, 0 1 0, 1 1 0, 0 0 0)) )
```

###### grass.pygrass.vector.geometry.read_line

```python
read_line(feature_id, c_mapinfo, table=None, writeable=False, c_points=None, c_cats=None, is2D=True)
```

Return a geometry object given the feature id and the c_mapinfo.

###### grass.pygrass.vector.geometry.read_next_line

```python
read_next_line(c_mapinfo, table=None, writeable=False, c_points=None, c_cats=None, is2D=True)
```

Return the next geometry feature of a vector map.

###### grass.pygrass.vector.geometry.test_vector_name

```python
test_vector_name = 'geometry_doctest_map'
```

##### grass.pygrass.vector.mset

```python
mset = get_mapset_vector(test_vector_name, mapset='')
```

##### grass.pygrass.vector.sql

It is a collection of strings to avoid to repeat the code.

```
>>> SELECT.format(cols=", ".join(["cat", "area"]), tname="table")
'SELECT cat, area FROM table;'
>>> SELECT_WHERE.format(
...     cols=", ".join(["cat", "area"]), tname="table", condition="area>10000"
... )
'SELECT cat, area FROM table WHERE area>10000;'
```

**Attributes:**

- [**ADD_COL**](#grass.pygrass.vector.sql.ADD_COL) –
- [**CAST_COL**](#grass.pygrass.vector.sql.CAST_COL) –
- [**CREATE_TAB**](#grass.pygrass.vector.sql.CREATE_TAB) –
- [**DROP_COL**](#grass.pygrass.vector.sql.DROP_COL) –
- [**DROP_COL_SQLITE**](#grass.pygrass.vector.sql.DROP_COL_SQLITE) –
- [**DROP_TAB**](#grass.pygrass.vector.sql.DROP_TAB) –
- [**INSERT**](#grass.pygrass.vector.sql.INSERT) –
- [**PRAGMA**](#grass.pygrass.vector.sql.PRAGMA) –
- [**RENAME_COL**](#grass.pygrass.vector.sql.RENAME_COL) –
- [**RENAME_TAB**](#grass.pygrass.vector.sql.RENAME_TAB) –
- [**SELECT**](#grass.pygrass.vector.sql.SELECT) –
- [**SELECT_ORDERBY**](#grass.pygrass.vector.sql.SELECT_ORDERBY) –
- [**SELECT_WHERE**](#grass.pygrass.vector.sql.SELECT_WHERE) –
- [**UPDATE**](#grass.pygrass.vector.sql.UPDATE) –
- [**UPDATE_COL_WHERE**](#grass.pygrass.vector.sql.UPDATE_COL_WHERE) –
- [**UPDATE_WHERE**](#grass.pygrass.vector.sql.UPDATE_WHERE) –

###### grass.pygrass.vector.sql.ADD_COL

```python
ADD_COL = 'ALTER TABLE {tname} ADD COLUMN {cname} {ctype};'
```

###### grass.pygrass.vector.sql.CAST_COL

```python
CAST_COL = 'ALTER TABLE {tname} ALTER COLUMN {col} SET DATA TYPE {ctype};'
```

###### grass.pygrass.vector.sql.CREATE_TAB

```python
CREATE_TAB = 'CREATE TABLE {tname}({coldef})'
```

###### grass.pygrass.vector.sql.DROP_COL

```python
DROP_COL = 'ALTER TABLE {tname} DROP COLUMN {cname};'
```

###### grass.pygrass.vector.sql.DROP_COL_SQLITE

```python
DROP_COL_SQLITE = 'CREATE TEMPORARY TABLE {tname}_backup({coldef});\nINSERT INTO {tname}_backup SELECT {colnames} FROM {tname};\nDROP TABLE {tname};\nCREATE TABLE {tname}({coldef});\nINSERT INTO {tname} SELECT {colnames} FROM {tname}_backup;\nCREATE UNIQUE INDEX {tname}_cat ON {tname} ({keycol} );\nDROP TABLE {tname}_backup;'
```

###### grass.pygrass.vector.sql.DROP_TAB

```python
DROP_TAB = 'DROP TABLE {tname}'
```

###### grass.pygrass.vector.sql.INSERT

```python
INSERT = 'INSERT INTO {tname} VALUES ({values})'
```

###### grass.pygrass.vector.sql.PRAGMA

```python
PRAGMA = 'PRAGMA table_info({tname});'
```

###### grass.pygrass.vector.sql.RENAME_COL

```python
RENAME_COL = 'ALTER TABLE {tname} RENAME COLUMN {old_name} TO {new_name};'
```

###### grass.pygrass.vector.sql.RENAME_TAB

```python
RENAME_TAB = 'ALTER TABLE {old_name} RENAME TO {new_name};'
```

###### grass.pygrass.vector.sql.SELECT

```python
SELECT = 'SELECT {cols} FROM {tname};'
```

###### grass.pygrass.vector.sql.SELECT_ORDERBY

```python
SELECT_ORDERBY = 'SELECT {cols} FROM {tname} ORDER BY {orderby};'
```

###### grass.pygrass.vector.sql.SELECT_WHERE

```python
SELECT_WHERE = 'SELECT {cols} FROM {tname} WHERE {condition};'
```

###### grass.pygrass.vector.sql.UPDATE

```python
UPDATE = 'UPDATE {tname} SET {new_col} = {old_col};'
```

###### grass.pygrass.vector.sql.UPDATE_COL_WHERE

```python
UPDATE_COL_WHERE = 'UPDATE {tname} SET {new_col} = {old_col} WHERE {condition};'
```

###### grass.pygrass.vector.sql.UPDATE_WHERE

```python
UPDATE_WHERE = 'UPDATE {tname} SET {values} WHERE {condition};'
```

##### grass.pygrass.vector.table

Created on Wed Aug 8 15:29:21 2012

@author: pietro

**Classes:**

- [**Columns**](#grass.pygrass.vector.table.Columns) – Object to work with columns table.
- [**DBlinks**](#grass.pygrass.vector.table.DBlinks) – Interface containing link to the table DB.
- [**Filters**](#grass.pygrass.vector.table.Filters) – Help user to build a simple sql query.
- [**Link**](#grass.pygrass.vector.table.Link) – Define a Link between vector map and the attributes table.
- [**Table**](#grass.pygrass.vector.table.Table) – >>> import sqlite3

**Functions:**

- [**get_path**](#grass.pygrass.vector.table.get_path) – Return the full path to the database; replacing environment variable

**Attributes:**

- [**DRIVERS**](#grass.pygrass.vector.table.DRIVERS) –
- [**UNSUPPORTED_DRIVERS**](#grass.pygrass.vector.table.UNSUPPORTED_DRIVERS) –
- [**mset**](#grass.pygrass.vector.table.mset) –
- [**test_vector_name**](#grass.pygrass.vector.table.test_vector_name) –

###### grass.pygrass.vector.table.Columns

```python
Columns(tname, connection, key='cat')
```

Object to work with columns table.

It is possible to instantiate a Columns object given the table name and
the database connection.

For a sqlite table:

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > cols_sqlite = Columns(test_vector_name, sqlite3.connect(get_path(path)))
> > > cols_sqlite.tname
> > > 'table_doctest_map'

For a postgreSQL table:

> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.tname # doctest: +SKIP
> > > 'table_doctest_map' #doctest: +SKIP

**Functions:**

- [**add**](#grass.pygrass.vector.table.Columns.add) – Add a new column to the table.
- [**cast**](#grass.pygrass.vector.table.Columns.cast) – Change the column type.
- [**drop**](#grass.pygrass.vector.table.Columns.drop) – Drop a column from the table.
- [**is_pg**](#grass.pygrass.vector.table.Columns.is_pg) – Return True if is a psycopg connection.
- [**items**](#grass.pygrass.vector.table.Columns.items) – Return a list of tuple with column name and column type.
- [**names**](#grass.pygrass.vector.table.Columns.names) – Return a list with the column names.
- [**rename**](#grass.pygrass.vector.table.Columns.rename) – Rename a column of the table.
- [**sql_descr**](#grass.pygrass.vector.table.Columns.sql_descr) – Return a string with description of columns.
- [**types**](#grass.pygrass.vector.table.Columns.types) – Return a list with the column types.
- [**update_odict**](#grass.pygrass.vector.table.Columns.update_odict) – Read columns name and types from table and update the odict

**Attributes:**

- [**conn**](#grass.pygrass.vector.table.Columns.conn) –
- [**key**](#grass.pygrass.vector.table.Columns.key) –
- [**odict**](#grass.pygrass.vector.table.Columns.odict) –
- [**tname**](#grass.pygrass.vector.table.Columns.tname) –

####### grass.pygrass.vector.table.Columns.add

```python
add(col_name, col_type)
```

Add a new column to the table.

:param col_name: the name of column to add
:type col_name: str
:param col_type: the tipe of column to add
:type col_type: str

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > from grass.pygrass.utils import copy, remove
> > > copy(test_vector_name, "mycensus", "vect")
> > > cols_sqlite = Columns("mycensus", sqlite3.connect(get_path(path)))
> > > cols_sqlite.add(["n_pizza"], ["INT"])
> > > "n_pizza" in cols_sqlite
> > > True
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... "boundary_municp_pg", pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.add("n_pizza", "INT") # doctest: +SKIP
> > > "n_pizza" in cols_pg # doctest: +SKIP
> > > True
> > > remove("mycensus", "vect")

####### grass.pygrass.vector.table.Columns.cast

```python
cast(col_name, new_type)
```

Change the column type.

:param col_name: the name of column
:type col_name: str
:param new_type: the new type of column
:type new_type: str

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > from grass.pygrass.utils import copy, remove
> > > copy(test_vector_name, "mycensus", "vect")
> > > cols_sqlite = Columns("mycensus", sqlite3.connect(get_path(path)))
> > > cols_sqlite.add(["n_pizzas"], ["INT"])
> > > cols_sqlite.cast("n_pizzas", "float8") # doctest: +ELLIPSIS
> > > Traceback (most recent call last):
> > > ...
> > > grass.exceptions.DBError: SQLite does not support to cast columns.
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.cast("n_pizzas", "float8") # doctest: +SKIP
> > > cols_pg["n_pizzas"] # doctest: +SKIP
> > > 'float8'
> > > remove("mycensus", "vect")

.. warning ::

It is not possible to cast a column with sqlite

####### grass.pygrass.vector.table.Columns.conn

```python
conn = connection
```

####### grass.pygrass.vector.table.Columns.drop

```python
drop(col_name)
```

Drop a column from the table.

:param col_name: the name of column to remove
:type col_name: str

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > from grass.pygrass.utils import copy, remove
> > > copy(test_vector_name, "mycensus", "vect")
> > > cols_sqlite = Columns("mycensus", sqlite3.connect(get_path(path)))
> > > cols_sqlite.drop("name") # doctest: +ELLIPSIS
> > > "name" in cols_sqlite
> > > False

> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.drop("name") # doctest: +SKIP
> > > "name" in cols_pg # doctest: +SKIP
> > > False
> > > remove("mycensus", "vect")

####### grass.pygrass.vector.table.Columns.is_pg

```python
is_pg()
```

Return True if is a psycopg connection.

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > cols_sqlite = Columns(test_vector_name, sqlite3.connect(get_path(path)))
> > > cols_sqlite.is_pg()
> > > False
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.is_pg() # doctest: +SKIP
> > > True

####### grass.pygrass.vector.table.Columns.items

```python
items()
```

Return a list of tuple with column name and column type.

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > cols_sqlite = Columns(test_vector_name, sqlite3.connect(get_path(path)))
> > > cols_sqlite.items() # doctest: +ELLIPSIS
> > > [('cat', 'INTEGER'), ('name', 'varchar(50)'), ('value', 'double precision')]
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.items() # doctest: +ELLIPSIS +SKIP
> > > [('cat', 'INTEGER'), ('name', 'varchar(50)'), ('value', 'double precision')]

####### grass.pygrass.vector.table.Columns.key

```python
key = key
```

####### grass.pygrass.vector.table.Columns.names

```python
names(remove=None, unicod=True)
```

Return a list with the column names.
Remove it is used to remove a columns.

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > cols_sqlite = Columns(test_vector_name, sqlite3.connect(get_path(path)))
> > > cols_sqlite.names() # doctest: +ELLIPSIS
> > > ['cat', 'name', 'value']
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, # doctest: +SKIP
> > > ... pg.connect("host=localhost dbname=grassdb"),
> > > ... )
> > > cols_pg.names() # doctest: +ELLIPSIS +SKIP
> > > ['cat', 'name', 'value']

####### grass.pygrass.vector.table.Columns.odict

```python
odict = None
```

####### grass.pygrass.vector.table.Columns.rename

```python
rename(old_name, new_name)
```

Rename a column of the table.

:param old_name: the name of existing column
:type old_name: str
:param new_name: the name of new column
:type new_name: str

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > from grass.pygrass.utils import copy, remove
> > > copy(test_vector_name, "mycensus", "vect")
> > > cols_sqlite = Columns("mycensus", sqlite3.connect(get_path(path)))
> > > cols_sqlite.add(["n_pizza"], ["INT"])
> > > "n_pizza" in cols_sqlite
> > > True
> > > cols_sqlite.rename("n_pizza", "n_pizzas") # doctest: +ELLIPSIS
> > > "n_pizza" in cols_sqlite
> > > False
> > > "n_pizzas" in cols_sqlite
> > > True

> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.rename("n_pizza", "n_pizzas") # doctest: +SKIP
> > > "n_pizza" in cols_pg # doctest: +SKIP
> > > False
> > > "n_pizzas" in cols_pg # doctest: +SKIP
> > > True
> > > remove("mycensus", "vect")

####### grass.pygrass.vector.table.Columns.sql_descr

```python
sql_descr(remove=None)
```

Return a string with description of columns.
Remove it is used to remove a columns.

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > cols_sqlite = Columns(test_vector_name, sqlite3.connect(get_path(path)))
> > > cols_sqlite.sql_descr() # doctest: +ELLIPSIS
> > > 'cat INTEGER, name varchar(50), value double precision'
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.sql_descr() # doctest: +ELLIPSIS +SKIP
> > > 'cat INTEGER, name varchar(50), value double precision'

####### grass.pygrass.vector.table.Columns.tname

```python
tname = tname
```

####### grass.pygrass.vector.table.Columns.types

```python
types()
```

Return a list with the column types.

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > cols_sqlite = Columns(test_vector_name, sqlite3.connect(get_path(path)))
> > > cols_sqlite.types() # doctest: +ELLIPSIS
> > > ['INTEGER', 'varchar(50)', 'double precision']
> > > import psycopg2 as pg # doctest: +SKIP
> > > cols_pg = Columns(
> > > ... test_vector_name, pg.connect("host=localhost dbname=grassdb")
> > > ... ) # doctest: +SKIP
> > > cols_pg.types() # doctest: +ELLIPSIS +SKIP
> > > ['INTEGER', 'varchar(50)', 'double precision']

####### grass.pygrass.vector.table.Columns.update_odict

```python
update_odict()
```

Read columns name and types from table and update the odict
attribute.

###### grass.pygrass.vector.table.DBlinks

```python
DBlinks(c_mapinfo)
```

Interface containing link to the table DB.

> > > from grass.pygrass.vector import VectorTopo
> > > cens = VectorTopo(test_vector_name)
> > > cens.open(mode="r")
> > > dblinks = DBlinks(cens.c_mapinfo)
> > > dblinks
> > > DBlinks([Link(1, table_doctest_map, sqlite)])
> > > dblinks[0]
> > > Link(1, table_doctest_map, sqlite)
> > > dblinks[test_vector_name]
> > > Link(1, table_doctest_map, sqlite)
> > > cens.close()

**Functions:**

- [**add**](#grass.pygrass.vector.table.DBlinks.add) – Add a new link. Need to open vector map in write mode
- [**by_index**](#grass.pygrass.vector.table.DBlinks.by_index) – Return a Link object by index
- [**by_layer**](#grass.pygrass.vector.table.DBlinks.by_layer) – Return the chosen Link using the layer
- [**by_name**](#grass.pygrass.vector.table.DBlinks.by_name) – Return the chosen Link using the name
- [**from_name_to_num**](#grass.pygrass.vector.table.DBlinks.from_name_to_num) – Vect_get_field_number
- [**num_dblinks**](#grass.pygrass.vector.table.DBlinks.num_dblinks) – Return the number of DBlinks
- [**remove**](#grass.pygrass.vector.table.DBlinks.remove) – Remove a link. If force set to true remove also the table

**Attributes:**

- [**c_mapinfo**](#grass.pygrass.vector.table.DBlinks.c_mapinfo) –

####### grass.pygrass.vector.table.DBlinks.add

```python
add(link)
```

Add a new link. Need to open vector map in write mode

:param link: the Link to add to the DBlinks
:type link: a Link object

> > > from grass.pygrass.vector import VectorTopo
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open(mode="r")
> > > dblinks = DBlinks(test_vect.c_mapinfo)
> > > dblinks
> > > DBlinks([Link(1, table_doctest_map, sqlite)])
> > > link = Link(
> > > ... 2,
> > > ... "pg_link",
> > > ... test_vector_name,
> > > ... "cat",
> > > ... "host=localhost dbname=grassdb",
> > > ... "pg",
> > > ... ) # doctest: +SKIP
> > > dblinks.add(link) # doctest: +SKIP
> > > dblinks # doctest: +SKIP
> > > DBlinks([Link(1, table_doctest_map, sqlite)])

####### grass.pygrass.vector.table.DBlinks.by_index

```python
by_index(indx)
```

Return a Link object by index

:param indx: the index where add new point
:type indx: int

####### grass.pygrass.vector.table.DBlinks.by_layer

```python
by_layer(layer)
```

Return the chosen Link using the layer

:param layer: the number of layer
:type layer: int

####### grass.pygrass.vector.table.DBlinks.by_name

```python
by_name(name)
```

Return the chosen Link using the name

:param name: the name of Link
:type name: str

####### grass.pygrass.vector.table.DBlinks.c_mapinfo

```python
c_mapinfo = c_mapinfo
```

####### grass.pygrass.vector.table.DBlinks.from_name_to_num

```python
from_name_to_num(name)
```

Vect_get_field_number

####### grass.pygrass.vector.table.DBlinks.num_dblinks

```python
num_dblinks()
```

Return the number of DBlinks

####### grass.pygrass.vector.table.DBlinks.remove

```python
remove(key, force=False)
```

Remove a link. If force set to true remove also the table

:param key: the key of Link
:type key: str
:param force: if True remove also the table from database otherwise
only the link between table and vector
:type force: boole

> > > from grass.pygrass.vector import VectorTopo
> > > test_vect = VectorTopo(test_vector_name)
> > > test_vect.open(mode="r")
> > > dblinks = DBlinks(test_vect.c_mapinfo)
> > > dblinks
> > > DBlinks([Link(1, table_doctest_map, sqlite)])
> > > dblinks.remove("pg_link") # doctest: +SKIP
> > > dblinks # need to open vector map in write mode
> > > DBlinks([Link(1, table_doctest_map, sqlite)])

###### grass.pygrass.vector.table.DRIVERS

```python
DRIVERS = ('sqlite', 'pg')
```

###### grass.pygrass.vector.table.Filters

```python
Filters(tname)
```

Help user to build a simple sql query.

> > > filter = Filters("table")
> > > filter.get_sql()
> > > 'SELECT * FROM table;'
> > > filter.where("area\<10000").get_sql()
> > > 'SELECT * FROM table WHERE area\<10000;'
> > > filter.select("cat", "area").get_sql()
> > > 'SELECT cat, area FROM table WHERE area\<10000;'
> > > filter.order_by("area").limit(10).get_sql()
> > > 'SELECT cat, area FROM table WHERE area\<10000 ORDER BY area LIMIT 10;'

**Functions:**

- [**get_sql**](#grass.pygrass.vector.table.Filters.get_sql) – Return the SQL query
- [**group_by**](#grass.pygrass.vector.table.Filters.group_by) – Create the group by condition
- [**limit**](#grass.pygrass.vector.table.Filters.limit) – Create the limit condition
- [**order_by**](#grass.pygrass.vector.table.Filters.order_by) – Create the order by condition
- [**reset**](#grass.pygrass.vector.table.Filters.reset) – Clean internal variables
- [**select**](#grass.pygrass.vector.table.Filters.select) – Create the select query
- [**where**](#grass.pygrass.vector.table.Filters.where) – Create the where condition

**Attributes:**

- [**tname**](#grass.pygrass.vector.table.Filters.tname) –

####### grass.pygrass.vector.table.Filters.get_sql

```python
get_sql()
```

Return the SQL query

####### grass.pygrass.vector.table.Filters.group_by

```python
group_by(*groupby)
```

Create the group by condition

:param groupby: the name of column/s to group the result
:type groupby: str, list

####### grass.pygrass.vector.table.Filters.limit

```python
limit(number)
```

Create the limit condition

:param number: the number to limit the result
:type number: int

####### grass.pygrass.vector.table.Filters.order_by

```python
order_by(*orderby)
```

Create the order by condition

:param orderby: the name of column/s to order the result
:type orderby: str

####### grass.pygrass.vector.table.Filters.reset

```python
reset()
```

Clean internal variables

####### grass.pygrass.vector.table.Filters.select

```python
select(*args)
```

Create the select query

####### grass.pygrass.vector.table.Filters.tname

```python
tname = tname
```

####### grass.pygrass.vector.table.Filters.where

```python
where(condition)
```

Create the where condition

:param condition: the condition of where statement, for example
`cat = 1`
:type condition: str

###### grass.pygrass.vector.table.Link

```python
Link(layer=1, name=None, table=None, key='cat', database='$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db', driver='sqlite', c_fieldinfo=None)
```

Define a Link between vector map and the attributes table.

It is possible to define a Link object or given all the information
(layer, name, table name, key, database, driver):

> > > link = Link(
> > > ... 1,
> > > ... "link0",
> > > ... test_vector_name,
> > > ... "cat",
> > > ... "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db",
> > > ... "sqlite",
> > > ... )
> > > link.layer
> > > 1
> > > link.name
> > > 'link0'
> > > link.table_name
> > > 'table_doctest_map'
> > > link.key
> > > 'cat'
> > > link.database
> > > '$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'
> > > link.driver
> > > 'sqlite'
> > > link
> > > Link(1, link0, sqlite)

It is possible to change parameters with:

> > > link.driver = "pg" # doctest: +SKIP
> > > link.driver # doctest: +SKIP
> > > 'pg'
> > > link.driver = "postgres" # doctest: +ELLIPSIS +SKIP
> > > Traceback (most recent call last):
> > > ...
> > > TypeError: Driver not supported, use: sqlite, pg.
> > > link.driver # doctest: +SKIP
> > > 'pg'
> > > link.number = 0 # doctest: +ELLIPSIS +SKIP
> > > Traceback (most recent call last):
> > > ...
> > > TypeError: Number must be positive and greater than 0.

Or given a c_fieldinfo object that is a ctypes pointer to the field_info C
struct. ::

> > > link = Link(c_fieldinfo=ctypes.pointer(libvect.field_info()))

**Functions:**

- [**connection**](#grass.pygrass.vector.table.Link.connection) – Return a connection object.
- [**info**](#grass.pygrass.vector.table.Link.info) – Print information of the link.
- [**table**](#grass.pygrass.vector.table.Link.table) – Return a Table object.

**Attributes:**

- [**c_fieldinfo**](#grass.pygrass.vector.table.Link.c_fieldinfo) –
- [**database**](#grass.pygrass.vector.table.Link.database) –
- [**driver**](#grass.pygrass.vector.table.Link.driver) –
- [**key**](#grass.pygrass.vector.table.Link.key) –
- [**layer**](#grass.pygrass.vector.table.Link.layer) –
- [**name**](#grass.pygrass.vector.table.Link.name) –
- [**table_name**](#grass.pygrass.vector.table.Link.table_name) –

####### grass.pygrass.vector.table.Link.c_fieldinfo

```python
c_fieldinfo = c_fieldinfo
```

####### grass.pygrass.vector.table.Link.connection

```python
connection()
```

Return a connection object.

> > > link = Link(
> > > ... 1,
> > > ... "link0",
> > > ... test_vector_name,
> > > ... "cat",
> > > ... "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db",
> > > ... "sqlite",
> > > ... )
> > > conn = link.connection()
> > > cur = conn.cursor()
> > > link.table_name
> > > 'table_doctest_map'
> > > cur.execute(
> > > ... "SELECT cat, name, value from %s" % link.table_name
> > > ... ) # doctest: +ELLIPSIS
> > > \<sqlite3.Cursor object at ...>
> > > cur.fetchone() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
> > > (1, 'point', 1.0)
> > > cur.close()
> > > conn.close()

####### grass.pygrass.vector.table.Link.database

```python
database = property(fget=_get_database, fset=_set_database, doc='Set and obtain database value')
```

####### grass.pygrass.vector.table.Link.driver

```python
driver = property(fget=_get_driver, fset=_set_driver, doc='Set and obtain driver value. The drivers supported                       by PyGRASS are: SQLite and PostgreSQL')
```

####### grass.pygrass.vector.table.Link.info

```python
info()
```

Print information of the link.

> > > link = Link(
> > > ... 1,
> > > ... "link0",
> > > ... test_vector_name,
> > > ... "cat",
> > > ... "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db",
> > > ... "sqlite",
> > > ... )
> > > link.info()
> > > layer: 1
> > > name: link0
> > > table: table_doctest_map
> > > key: cat
> > > database: $GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db
> > > driver: sqlite

####### grass.pygrass.vector.table.Link.key

```python
key = property(fget=_get_key, fset=_set_key, doc='Set and obtain cat value')
```

####### grass.pygrass.vector.table.Link.layer

```python
layer = property(fget=_get_layer, fset=_set_layer, doc='Set and obtain layer number')
```

####### grass.pygrass.vector.table.Link.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set and obtain name vale')
```

####### grass.pygrass.vector.table.Link.table

```python
table()
```

Return a Table object.

> > > link = Link(
> > > ... 1,
> > > ... "link0",
> > > ... test_vector_name,
> > > ... "cat",
> > > ... "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db",
> > > ... "sqlite",
> > > ... )
> > > table = link.table()
> > > table.filters.select("cat", "name", "value")
> > > Filters('SELECT cat, name, value FROM table_doctest_map;')
> > > cur = table.execute()
> > > cur.fetchone()
> > > (1, 'point', 1.0)
> > > cur.close()

####### grass.pygrass.vector.table.Link.table_name

```python
table_name = property(fget=_get_table, fset=_set_table, doc='Set and obtain table name value')
```

###### grass.pygrass.vector.table.Table

```python
Table(name, connection, key='cat')
```

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/PERMANENT/sqlite/sqlite.db"
> > > tab_sqlite = Table(
> > > ... name=test_vector_name, connection=sqlite3.connect(get_path(path))
> > > ... )
> > > tab_sqlite.name
> > > 'table_doctest_map'
> > > import psycopg2 # doctest: +SKIP
> > > tab_pg = Table(
> > > ... test_vector_name, psycopg2.connect("host=localhost dbname=grassdb", "pg")
> > > ... ) # doctest: +SKIP
> > > tab_pg.columns # doctest: +ELLIPSIS +SKIP
> > > Columns([('cat', 'int4'), ...])

**Functions:**

- [**create**](#grass.pygrass.vector.table.Table.create) – Create a new table
- [**drop**](#grass.pygrass.vector.table.Table.drop) – Method to drop table from database
- [**execute**](#grass.pygrass.vector.table.Table.execute) – Execute SQL code from a given string or build with filters and
- [**exist**](#grass.pygrass.vector.table.Table.exist) – Return True if the table already exists in the DB, False otherwise
- [**insert**](#grass.pygrass.vector.table.Table.insert) – Insert a new row
- [**n_rows**](#grass.pygrass.vector.table.Table.n_rows) – Return the number of rows
- [**update**](#grass.pygrass.vector.table.Table.update) – Update a table row

**Attributes:**

- [**columns**](#grass.pygrass.vector.table.Table.columns) –
- [**conn**](#grass.pygrass.vector.table.Table.conn) –
- [**filters**](#grass.pygrass.vector.table.Table.filters) –
- [**key**](#grass.pygrass.vector.table.Table.key) –
- [**name**](#grass.pygrass.vector.table.Table.name) –

####### grass.pygrass.vector.table.Table.columns

```python
columns = Columns(self.name, self.conn, self.key)
```

####### grass.pygrass.vector.table.Table.conn

```python
conn = connection
```

####### grass.pygrass.vector.table.Table.create

```python
create(cols, name=None, overwrite=False, cursor=None)
```

Create a new table

:param cols:
:type cols:
:param name: the name of table to create, None for the name of Table object
:type name: str
:param overwrite: overwrite existing table
:type overwrite: bool
:param cursor: the cursor to connect, if None it use the cursor
of connection table object
:type cursor: Cursor object

####### grass.pygrass.vector.table.Table.drop

```python
drop(cursor=None, force=False)
```

Method to drop table from database

:param cursor: the cursor to connect, if None it use the cursor
of connection table object
:type cursor: Cursor object
:param force: True to remove the table, by default False to print advice
:type force: bool

####### grass.pygrass.vector.table.Table.execute

```python
execute(sql_code=None, cursor=None, many=False, values=None)
```

Execute SQL code from a given string or build with filters and
return a cursor object.

:param sql_code: the SQL code to execute, if not pass it use filters variable
:type sql_code: str
:param cursor: the cursor to connect, if None it use the cursor
of connection table object
:type cursor: Cursor object
:param many: True to run executemany function
:type many: bool
:param values: The values to substitute into sql_code string
:type values: list of tuple

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > tab_sqlite = Table(
> > > ... name=test_vector_name, connection=sqlite3.connect(get_path(path))
> > > ... )
> > > tab_sqlite.filters.select("cat", "name").order_by("value")
> > > Filters('SELECT cat, name FROM table_doctest_map ORDER BY value;')
> > > cur = tab_sqlite.execute()
> > > cur.fetchone() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
> > > (1, 'point')

####### grass.pygrass.vector.table.Table.exist

```python
exist(cursor=None)
```

Return True if the table already exists in the DB, False otherwise

:param cursor: the cursor to connect, if None it use the cursor
of connection table object

####### grass.pygrass.vector.table.Table.filters

```python
filters = Filters(self.name)
```

####### grass.pygrass.vector.table.Table.insert

```python
insert(values, cursor=None, many=False)
```

Insert a new row

:param values: a tuple of values to insert, it is possible to insert
more rows using a list of tuple and parameter `many`
:type values: tuple
:param cursor: the cursor to connect, if None it use the cursor
of connection table object
:type cursor: Cursor object
:param many: True to run executemany function
:type many: bool

####### grass.pygrass.vector.table.Table.key

```python
key = key
```

####### grass.pygrass.vector.table.Table.n_rows

```python
n_rows()
```

Return the number of rows

> > > import sqlite3
> > > from grass.pygrass.vector.table import get_path
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > tab_sqlite = Table(
> > > ... name=test_vector_name, connection=sqlite3.connect(get_path(path))
> > > ... )
> > > tab_sqlite.n_rows()
> > > 3

####### grass.pygrass.vector.table.Table.name

```python
name = property(fget=_get_name, fset=_set_name, doc='Set and obtain table name')
```

####### grass.pygrass.vector.table.Table.update

```python
update(key, values, cursor=None)
```

Update a table row

:param key: the rowid
:type key: int
:param values: the values to insert without row id.
For example if we have a table with four columns:
cat, c0, c1, c2 the values list should
containing only c0, c1, c2 values.
:type values: list
:param cursor: the cursor to connect, if None it use the cursor
of connection table object
:type cursor: Cursor object

###### grass.pygrass.vector.table.UNSUPPORTED_DRIVERS

```python
UNSUPPORTED_DRIVERS = ('ogr', 'dbf')
```

###### grass.pygrass.vector.table.get_path

```python
get_path(path, vect_name=None)
```

Return the full path to the database; replacing environment variable
with real values

:param path: The path with substitutional parameter
:param vect_name: The name of the vector map

> > > from grass.script.core import gisenv
> > > import os
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db"
> > > new_path = get_path(path)
> > > new_path2 = os.path.join(
> > > ... gisenv()["GISDBASE"],
> > > ... gisenv()["LOCATION_NAME"],
> > > ... gisenv()["MAPSET"],
> > > ... "sqlite",
> > > ... "sqlite.db",
> > > ... )
> > > new_path.replace("//", "/") == new_path2.replace("//", "/")
> > > True
> > > path = "$GISDBASE/$LOCATION_NAME/$MAPSET/vector/$MAP/sqlite.db"
> > > new_path = get_path(path, "test")
> > > new_path2 = os.path.join(
> > > ... gisenv()["GISDBASE"],
> > > ... gisenv()["LOCATION_NAME"],
> > > ... gisenv()["MAPSET"],
> > > ... "vector",
> > > ... "test",
> > > ... "sqlite.db",
> > > ... )
> > > new_path.replace("//", "/") == new_path2.replace("//", "/")
> > > True

###### grass.pygrass.vector.table.mset

```python
mset = get_mapset_vector(test_vector_name, mapset='')
```

###### grass.pygrass.vector.table.test_vector_name

```python
test_vector_name = 'table_doctest_map'
```

##### grass.pygrass.vector.test_vector_name

```python
test_vector_name = 'vector_doctest_map'
```

##### grass.pygrass.vector.vector_type

Created on Wed Jul 18 10:49:26 2012

@author: pietro

**Attributes:**

- [**MAPTYPE**](#grass.pygrass.vector.vector_type.MAPTYPE) –
- [**VTYPE**](#grass.pygrass.vector.vector_type.VTYPE) –

###### grass.pygrass.vector.vector_type.MAPTYPE

```python
MAPTYPE = {libvect.GV_FORMAT_NATIVE: 'native', libvect.GV_FORMAT_OGR: 'OGR', libvect.GV_FORMAT_OGR_DIRECT: 'OGR', libvect.GV_FORMAT_POSTGIS: 'PostGIS'}
```

###### grass.pygrass.vector.vector_type.VTYPE

```python
VTYPE = {'point': libvect.GV_POINT, 'line': libvect.GV_LINE, 'boundary': libvect.GV_BOUNDARY, 'centroid': libvect.GV_CENTROID, 'face': libvect.GV_FACE, 'kernel': libvect.GV_KERNEL, 'area': libvect.GV_AREA, 'volume': libvect.GV_VOLUME}
```

### grass.script

Python interface to launch GRASS GIS modules in scripts

**Modules:**

- [**array**](#grass.script.array) – Functions to use GRASS 2D and 3D rasters with NumPy.
- [**core**](#grass.script.core) – Core functions to be used in Python scripts.
- [**db**](#grass.script.db) – Database related functions to be used in Python scripts.
- [**imagery**](#grass.script.imagery) – Imagery related functions to be used in Python scripts.
- [**raster**](#grass.script.raster) – Raster related functions to be used in Python scripts.
- [**raster3d**](#grass.script.raster3d) – Raster3d related functions to be used in Python scripts.
- [**setup**](#grass.script.setup) – Setup, initialization, and clean-up functions
- [**task**](#grass.script.task) – Get interface description of GRASS commands
- [**utils**](#grass.script.utils) – Useful functions to be used in Python scripts.
- [**vector**](#grass.script.vector) – Vector related functions to be used in Python scripts.

**Classes:**

- [**KeyValue**](#grass.script.KeyValue) – A general-purpose key-value store.
- [**MaskManager**](#grass.script.MaskManager) – Context manager for setting and managing 2D raster mask.
- [**Popen**](#grass.script.Popen) –

**Functions:**

- [**append_node_pid**](#grass.script.append_node_pid) – Add node name and PID to a name (string)
- [**append_random**](#grass.script.append_random) – Add a random part to of a specified length to a name (string)
- [**append_uuid**](#grass.script.append_uuid) – Add UUID4 to a name (string)
- [**basename**](#grass.script.basename) – Remove leading directory components and an optional extension
- [**call**](#grass.script.call) –
- [**clock**](#grass.script.clock) – Return time counter to measure performance for chunks of code.
- [**compare_key_value_text_files**](#grass.script.compare_key_value_text_files) – Compare two key-value text files
- [**create_environment**](#grass.script.create_environment) – Creates environment to be passed in run_command for example.
- [**create_location**](#grass.script.create_location) –
- [**create_project**](#grass.script.create_project) – Create new project
- [**db_begin_transaction**](#grass.script.db_begin_transaction) – Begin transaction.
- [**db_commit_transaction**](#grass.script.db_commit_transaction) – Commit transaction.
- [**db_connection**](#grass.script.db_connection) – Return the current database connection parameters
- [**db_describe**](#grass.script.db_describe) – Return the list of columns for a database table
- [**db_select**](#grass.script.db_select) – Perform SQL select statement
- [**db_table_exist**](#grass.script.db_table_exist) – Check if table exists.
- [**db_table_in_vector**](#grass.script.db_table_in_vector) – Return the name of vector connected to the table.
- [**debug**](#grass.script.debug) – Display a debugging message using `g.message -d`.
- [**debug_level**](#grass.script.debug_level) –
- [**decode**](#grass.script.decode) – Decode bytes with default locale and return (unicode) string
- [**del_temp_region**](#grass.script.del_temp_region) – Unsets WIND_OVERRIDE and removes any region named by it.
- [**diff_files**](#grass.script.diff_files) – Diffs two text files and returns difference.
- [**encode**](#grass.script.encode) – Encode string with default locale and return bytes with that encoding
- [**error**](#grass.script.error) – Display an error message using `g.message -e`
- [**exec_command**](#grass.script.exec_command) – Interface to os.execvpe(), but with the make_command() interface.
- [**fatal**](#grass.script.fatal) – Display an error message using `g.message -e`, then abort or raise
- [**feed_command**](#grass.script.feed_command) – Passes all arguments to start_command(), but also adds
- [**find_file**](#grass.script.find_file) – Returns the output from running g.findfile as a
- [**find_program**](#grass.script.find_program) – Attempt to run a program, with optional arguments.
- [**float_or_dms**](#grass.script.float_or_dms) – Convert DMS to float.
- [**get_capture_stderr**](#grass.script.get_capture_stderr) – Return True if stderr is captured, False otherwise.
- [**get_commands**](#grass.script.get_commands) – Create list of available GRASS commands to use when parsing
- [**get_lib_path**](#grass.script.get_lib_path) – Return the path of the libname contained in the module.
- [**get_num_suffix**](#grass.script.get_num_suffix) – Returns formatted number with number of padding zeros
- [**get_raise_on_error**](#grass.script.get_raise_on_error) – Return True if a ScriptError exception is raised instead of calling
- [**get_real_command**](#grass.script.get_real_command) – Returns the real file command for a module (cmd)
- [**gisenv**](#grass.script.gisenv) – Returns the output from running g.gisenv (with no arguments), as a
- [**group_to_dict**](#grass.script.group_to_dict) – Create a dictionary to represent an imagery group with metadata.
- [**handle_errors**](#grass.script.handle_errors) – Error handler for :func:`run_command()` and similar functions
- [**info**](#grass.script.info) – Display an informational message using `g.message -i`
- [**legal_name**](#grass.script.legal_name) – Checks if the string contains only allowed characters.
- [**legalize_vector_name**](#grass.script.legalize_vector_name) – Make *name* usable for vectors, tables, and columns
- [**list_grouped**](#grass.script.list_grouped) – List of elements grouped by mapsets.
- [**list_pairs**](#grass.script.list_pairs) – List of elements as pairs
- [**list_strings**](#grass.script.list_strings) – List of elements as strings.
- [**locn_is_latlong**](#grass.script.locn_is_latlong) – Tests if location is lat/long. Value is obtained
- [**make_command**](#grass.script.make_command) – Return a list of strings suitable for use as the args parameter to
- [**mapcalc**](#grass.script.mapcalc) – Interface to r.mapcalc.
- [**mapcalc3d**](#grass.script.mapcalc3d) – Interface to r3.mapcalc.
- [**mapcalc_start**](#grass.script.mapcalc_start) – Interface to r.mapcalc, doesn't wait for it to finish, returns Popen object.
- [**mapsets**](#grass.script.mapsets) – List available mapsets
- [**message**](#grass.script.message) – Display a message using `g.message`
- [**natural_sort**](#grass.script.natural_sort) – Returns sorted list using natural sort
- [**naturally_sorted**](#grass.script.naturally_sorted) – Returns sorted list using natural sort
- [**overwrite**](#grass.script.overwrite) – Return True if existing files may be overwritten
- [**parse_color**](#grass.script.parse_color) – Parses the string "val" as a GRASS colour, which can be either one of
- [**parse_command**](#grass.script.parse_command) – Passes all arguments to read_command, then parses the output
- [**parse_key_val**](#grass.script.parse_key_val) – Parse a string into a dictionary, where entries are separated
- [**parser**](#grass.script.parser) – Interface to g.parser, intended to be run from the top-level, e.g.:
- [**percent**](#grass.script.percent) – Display a progress info message using `g.message -p`
- [**pipe_command**](#grass.script.pipe_command) – Passes all arguments to start_command(), but also adds
- [**popen_args_command**](#grass.script.popen_args_command) – Split tool name and parameters from Popen parameters
- [**raster3d_info**](#grass.script.raster3d_info) – Return information about a raster3d map (interface to `r3.info`).
- [**raster_history**](#grass.script.raster_history) – Set the command history for a raster map to the command used to
- [**raster_info**](#grass.script.raster_info) – Return information about a raster map (interface to
- [**raster_what**](#grass.script.raster_what) – Interface to r.what
- [**read_command**](#grass.script.read_command) – Passes all arguments to pipe_command, then waits for the process to
- [**region**](#grass.script.region) – Returns the output from running "g.region -gu", as a
- [**region_env**](#grass.script.region_env) – Returns region settings as a string which can used as
- [**run_command**](#grass.script.run_command) – Execute a module synchronously
- [**sanitize_mapset_environment**](#grass.script.sanitize_mapset_environment) – Remove environmental variables relevant only
- [**separator**](#grass.script.separator) – Returns separator from G_OPT_F_SEP appropriately converted
- [**set_capture_stderr**](#grass.script.set_capture_stderr) – Enable capturing standard error output of modules and print it.
- [**set_path**](#grass.script.set_path) – Set sys.path looking in the local directory GRASS directories.
- [**set_raise_on_error**](#grass.script.set_raise_on_error) – Define behaviour on fatal error (fatal() called)
- [**split**](#grass.script.split) – Same shlex.split() func on all OS platforms
- [**start_command**](#grass.script.start_command) – Returns a Popen object with the command created by make_command.
- [**tempdir**](#grass.script.tempdir) – Returns the name of a temporary dir, created with g.tempfile.
- [**tempfile**](#grass.script.tempfile) – Returns the name of a temporary file, created with g.tempfile.
- [**tempname**](#grass.script.tempname) – Generate a GRASS and SQL compliant random name starting with tmp\_
- [**text_to_string**](#grass.script.text_to_string) – Convert text to str. Useful when passing text into environments,
- [**try_remove**](#grass.script.try_remove) – Attempt to remove a file; no exception is generated if the
- [**try_rmdir**](#grass.script.try_rmdir) – Attempt to remove a directory; no exception is generated if the
- [**use_temp_region**](#grass.script.use_temp_region) – Copies the current region to a temporary region with "g.region save=",
- [**vector_columns**](#grass.script.vector_columns) – Return a dictionary (or a list) of the columns for the
- [**vector_db**](#grass.script.vector_db) – Return the database connection details for a vector map
- [**vector_db_select**](#grass.script.vector_db_select) – Get attribute data of selected vector map layer.
- [**vector_history**](#grass.script.vector_history) – Set the command history for a vector map to the command used to
- [**vector_info**](#grass.script.vector_info) – Return information about a vector map (interface to
- [**vector_info_topo**](#grass.script.vector_info_topo) – Return information about a vector map (interface to `v.info -t`).
- [**vector_layer_db**](#grass.script.vector_layer_db) – Return the database connection details for a vector map layer.
- [**vector_what**](#grass.script.vector_what) – Query vector map at given locations
- [**verbose**](#grass.script.verbose) – Display a verbose message using `g.message -v`
- [**verbosity**](#grass.script.verbosity) – Return the verbosity level selected by GRASS_VERBOSE
- [**version**](#grass.script.version) – Get GRASS version as dictionary
- [**warning**](#grass.script.warning) – Display a warning message using `g.message -w`
- [**write_command**](#grass.script.write_command) – Execute a module with standard input given by *stdin* parameter.

**Attributes:**

- [**PIPE**](#grass.script.PIPE) –
- [**named_colors**](#grass.script.named_colors) (<code>[dict](#dict)\[[str](#str), [tuple](#tuple)\[[float](#float), [float](#float), [float](#float)\]\]</code>) –

#### grass.script.KeyValue

Bases: <code>[dict](#dict)\[[str](#str), [VT](#grass.script.utils.VT)\]</code>

A general-purpose key-value store.

KeyValue is a subclass of dict, but also allows entries to be read and
written using attribute syntax. Example:

> > > reg = KeyValue()
> > > reg["north"] = 489
> > > reg.north
> > > 489
> > > reg.south = 205
> > > reg["south"]
> > > 205

The keys of KeyValue are strings. To use other key types, use other mapping types.
To use the attribute syntax, the keys must be valid Python attribute names.

#### grass.script.MaskManager

```python
MaskManager(mask_name=None, env=None, remove=None)
```

Context manager for setting and managing 2D raster mask.

The context manager makes it possible to have custom mask for the current process.
In the following example, we set the mask using _r.mask_ which creates a new
raster which represents the mask. The mask is deactivated at the end of the
context by the context manager and the raster is removed.

> > > with gs.MaskManager():
> > > ... gs.run_command("r.mask", raster="state_boundary")
> > > ... gs.parse_command("r.univar", map="elevation", format="json")

The _mask_name_ can be a name of an existing raster map and in that case,
that raster map is used directly as is. If the raster map does not exist,
the name will be used for the mask once it is created (with _r.mask_).

The following example uses an existing raster map directly as the mask.
The mask is disabled at the end of the context, but the raster map is not
removed.

> > > with gs.MaskManager(mask_name="state_boundary"):
> > > ... gs.parse_command("r.univar", map="elevation", format="json")

Note the difference between using the name of an existing raster map directly
and using *r.mask* to create a new mask. Both zeros and NULL values are used
to represent mask resulting in NULL cells, while *r.mask*
by default sets the mask in the way that only NULL values in the original raster
result in NULL cells.

If _mask_name_ is not provided, it generates a unique name using node (computer)
name, PID (current process ID), and unique ID (UUID).
In this case, the raster map representing the mask is removed if it exists at the
end of the context.
Optionally, the context manager can remove the raster map at the end of the context
when _remove_ is set to `True`.
The defaults for the removal of a mask raster are set to align with the two main use
cases which is creating the mask within the context and using an existing raster as
a mask.

Name of the raster mask is available as the _mask_name_ attribute and can be used to
directly create a mask (without the need to use *r.mask*). The following example
uses the attribute to create a mask directly by name. This is equivalent to the
basic case where a raster named `MASK` is created directly by the user in an
interactive session.

> > > with gs.MaskManager() as manager:
> > > ... gs.run_command(
> > > "r.mapcalc", expression=f"{manager.mask_name} = row() < col()"
> > > )
> > > ... gs.run_command(
> > > "r.mapcalc", expression=f"masked_elevation = elevation"
> > > )

In the background, this class manages the `GRASS_MASK` environment variable.
It modifies the current system environment or the one provided. It does not
create a copy internally. However, the modified environment is available as
the _env_ attribute for convenience and consistency with other managers
which provide this attribute.

The following code creates a copy of the global environment and lets the manager
modify it. The copy is then available as the _env_ attribute.

> > > with gs.MaskManager(env=os.environ.copy()) as manager:
> > > ... gs.run_command(
> > > ... "r.mapcalc",
> > > ... expression=f"{manager.mask_name} = row() < col()",
> > > ... env=manager.env,
> > > ... )
> > > ... gs.run_command(
> > > ... "r.mapcalc", expression=f"masked_elevation = elevation", env=manager.env
> > > ... )

**Attributes:**

- [**env**](#grass.script.MaskManager.env) –
- [**mask_name**](#grass.script.MaskManager.mask_name) –

Initializes the MaskManager.

:param mask_name: Name of the raster mask. Generated if not provided.
:param env: Environment to use. Defaults to modifying os.environ.
:param remove: If True, the raster mask will be removed when the context exits.
Defaults to True if the mask name is generated,
and False if a mask name is provided.

##### grass.script.MaskManager.env

```python
env = env if env is not None else os.environ
```

##### grass.script.MaskManager.mask_name

```python
mask_name = append_uuid(append_node_pid('mask'))
```

#### grass.script.PIPE

```python
PIPE = subprocess.PIPE
```

#### grass.script.Popen

```python
Popen(args, **kwargs)
```

Bases: <code>[Popen](#subprocess.Popen)</code>

#### grass.script.append_node_pid

```python
append_node_pid(name)
```

Add node name and PID to a name (string)

For the result to be unique, the name needs to be unique within a process.
Given that, the result will be unique enough for use in temporary maps
and other elements on single machine or an HPC cluster.

The returned string is a name usable for vectors, tables, and columns
(vector legal name) as long as provided argument *name* is.

> > > append_node_pid("tmp_raster_1")

..note::

```
Before you use this function for creating temporary files (i.e., normal
files on disk, not maps and other mapset elements), see functions
designed for it in the GRASS GIS or standard Python library. These
take care of collisions already on different levels.
```

#### grass.script.append_random

```python
append_random(name, suffix_length=None, total_length=None)
```

Add a random part to of a specified length to a name (string)

> > > append_random("tmp", 8)
> > > append_random("tmp", total_length=16)

..note::

```
Note that this will be influenced by the random seed set for the Python
random package.
```

..note::

```
See the note about creating temporary files in the
:func:`append_node_pid()` description.
```

#### grass.script.append_uuid

```python
append_uuid(name)
```

Add UUID4 to a name (string)

To generate a name of an temporary mapset element which is unique in a
system, use :func:`append_node_pid()` in a combination with a name unique
within your process.

To avoid collisions, never shorten the name obtained from this function.
A shortened UUID does not have the collision guarantees the full UUID has.

For a random name of a given shorter size, see :func:`append_random()`.

> > > append_uuid("tmp")

..note::

```
See the note about creating temporary files in the
:func:`append_node_pid()` description.
```

#### grass.script.array

Functions to use GRASS 2D and 3D rasters with NumPy.

Usage:

> > > import grass.script as gs
> > > from grass.script import array as garray
> > >
> > > # We create a temporary region that is only valid in this python session

... gs.use_temp_region()

> > > gs.run_command("g.region", n=80, e=120, t=60, s=0, w=0, b=0, res=20, res3=20)
> > >
> > > # Lets create a raster map numpy array

... # based at the current region settings
... map2d_1 = garray.array()

> > > # Write some data

... for y in range(map2d_1.shape[0]):
... for x in range(map2d_1.shape[1]):
... map2d_1[y, x] = y + x

> > > # Lets have a look at the array

... print(map2d_1)
\[[0. 1. 2. 3. 4. 5.]
[1. 2. 3. 4. 5. 6.]
[2. 3. 4. 5. 6. 7.]
[3. 4. 5. 6. 7. 8.]\]

> > > # This will write the numpy array as GRASS raster map

... # with name map2d_1
... map2d_1.write(mapname="map2d_1", overwrite=True)
0

> > > # We create a new array from raster map2d_1 to modify it

... map2d_2 = garray.array(mapname="map2d_1")

> > > # Don't do map2d_2 = map2d_1 % 3

... # because: this will overwrite the internal temporary filename
... map2d_2 %= 3

> > > # Show the result

... print(map2d_2)
\[[0. 1. 2. 0. 1. 2.]
[1. 2. 0. 1. 2. 0.]
[2. 0. 1. 2. 0. 1.]
[0. 1. 2. 0. 1. 2.]\]

> > > # Write the result as new raster map with name map2d_2

... map2d_2.write(mapname="map2d_2", overwrite=True)
0

> > > # Here we create a 3D raster map numpy array

... # based in the current region settings
... map3d_1 = garray.array3d()

> > > # Write some data

... # Note: the 3D array has map[depth][row][column] order
... for z in range(map3d_1.shape[0]):
... for y in range(map3d_1.shape[1]):
... for x in range(map3d_1.shape[2]):
... map3d_1[z, y, x] = z + y + x

> > > # Lets have a look at the 3D array

... print(map3d_1)
\[\[[ 0. 1. 2. 3. 4. 5.]
[ 1. 2. 3. 4. 5. 6.]
[ 2. 3. 4. 5. 6. 7.]
[ 3. 4. 5. 6. 7. 8.]\]
<BLANKLINE>
\[[ 1. 2. 3. 4. 5. 6.]
[ 2. 3. 4. 5. 6. 7.]
[ 3. 4. 5. 6. 7. 8.]
[ 4. 5. 6. 7. 8. 9.]\]
<BLANKLINE>
\[[ 2. 3. 4. 5. 6. 7.]
[ 3. 4. 5. 6. 7. 8.]
[ 4. 5. 6. 7. 8. 9.]
[ 5. 6. 7. 8. 9. 10.]\]\]

> > > # This will write the numpy array as GRASS 3D raster map

... # with name map3d_1
... map3d_1.write(mapname="map3d_1", overwrite=True)
0

> > > # We create a new 3D array from 3D raster map3d_1 to modify it

... map3d_2 = garray.array3d(mapname="map3d_1")

> > > # Don't do map3d_2 = map3d_1 % 3

... # because: this will overwrite the internal temporary filename
... map3d_2 %= 3

> > > # Show the result

... print(map3d_2)
\[\[[0. 1. 2. 0. 1. 2.]
[1. 2. 0. 1. 2. 0.]
[2. 0. 1. 2. 0. 1.]
[0. 1. 2. 0. 1. 2.]\]
<BLANKLINE>
\[[1. 2. 0. 1. 2. 0.]
[2. 0. 1. 2. 0. 1.]
[0. 1. 2. 0. 1. 2.]
[1. 2. 0. 1. 2. 0.]\]
<BLANKLINE>
\[[2. 0. 1. 2. 0. 1.]
[0. 1. 2. 0. 1. 2.]
[1. 2. 0. 1. 2. 0.]
[2. 0. 1. 2. 0. 1.]\]\]

> > > # Write the result as new 3D raster map with name map3d_2

... map3d_2.write(mapname="map3d_2", overwrite=True)
0

(C) 2010-2021 by Glynn Clements and the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements

**Classes:**

- [**array**](#grass.script.array.array) –
- [**array3d**](#grass.script.array.array3d) –

##### grass.script.array.array

Bases: <code>[memmap](#numpy.memmap)</code>

**Functions:**

- [**write**](#grass.script.array.array.write) – Write array into raster map

###### grass.script.array.array.write

```python
write(mapname, title=None, null=None, overwrite=None, quiet=None)
```

Write array into raster map

:param str mapname: name for raster map
:param str title: title for raster map
:param null: null value
:param bool overwrite: True for overwriting existing raster maps

:return: 0 on success
:return: non-zero code on failure

##### grass.script.array.array3d

Bases: <code>[memmap](#numpy.memmap)</code>

**Functions:**

- [**write**](#grass.script.array.array3d.write) – Write array into 3D raster map

###### grass.script.array.array3d.write

```python
write(mapname, null=None, overwrite=None, quiet=None)
```

Write array into 3D raster map

:param str mapname: name for 3D raster map
:param null: null value
:param bool overwrite: True for overwriting existing raster maps

:return: 0 on success
:return: non-zero code on failure

#### grass.script.basename

```python
basename(path, ext=None)
```

Remove leading directory components and an optional extension
from the specified path

:param str path: path
:param str ext: extension

#### grass.script.call

```python
call(*args, **kwargs)
```

#### grass.script.clock

```python
clock()
```

Return time counter to measure performance for chunks of code.
Should be used only as difference between the calls.

#### grass.script.compare_key_value_text_files

```python
compare_key_value_text_files(filename_a, filename_b, sep=':', val_sep=',', precision=1e-06, proj=False, units=False)
```

Compare two key-value text files

This method will print a warning in case keys that are present in the first
file are not present in the second one.
The comparison method tries to convert the values into their native format
(float, int or string) to allow correct comparison.

An example key-value text file may have this content:

::

```
a: Hello
b: 1.0
c: 1,2,3,4,5
d : hello,8,0.1
```

:param str filename_a: name of the first key-value text file
:param str filenmae_b: name of the second key-value text file
:param str sep: character that separates the keys and values, default is ":"
:param str val_sep: character that separates the values of a single key,
default is ","
:param double precision: precision with which the floating point values are compared
:param bool proj: True if it has to check some information about projection system
:param bool units: True if it has to check some information about units

:return: True if full or almost identical, False if different

#### grass.script.core

Core functions to be used in Python scripts.

Usage:

::

```
from grass.script import core as grass

grass.parser()
```

(C) 2008-2025 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements
.. sectionauthor:: Martin Landa \<landa.martin gmail.com>
.. sectionauthor:: Michael Barton \<michael.barton asu.edu>

**Classes:**

- [**Popen**](#grass.script.core.Popen) –

**Functions:**

- [**call**](#grass.script.core.call) –
- [**compare_key_value_text_files**](#grass.script.core.compare_key_value_text_files) – Compare two key-value text files
- [**create_environment**](#grass.script.core.create_environment) – Creates environment to be passed in run_command for example.
- [**create_location**](#grass.script.core.create_location) –
- [**create_project**](#grass.script.core.create_project) – Create new project
- [**debug**](#grass.script.core.debug) – Display a debugging message using `g.message -d`.
- [**debug_level**](#grass.script.core.debug_level) –
- [**del_temp_region**](#grass.script.core.del_temp_region) – Unsets WIND_OVERRIDE and removes any region named by it.
- [**error**](#grass.script.core.error) – Display an error message using `g.message -e`
- [**exec_command**](#grass.script.core.exec_command) – Interface to os.execvpe(), but with the make_command() interface.
- [**fatal**](#grass.script.core.fatal) – Display an error message using `g.message -e`, then abort or raise
- [**feed_command**](#grass.script.core.feed_command) – Passes all arguments to start_command(), but also adds
- [**find_file**](#grass.script.core.find_file) – Returns the output from running g.findfile as a
- [**find_program**](#grass.script.core.find_program) – Attempt to run a program, with optional arguments.
- [**get_capture_stderr**](#grass.script.core.get_capture_stderr) – Return True if stderr is captured, False otherwise.
- [**get_commands**](#grass.script.core.get_commands) – Create list of available GRASS commands to use when parsing
- [**get_raise_on_error**](#grass.script.core.get_raise_on_error) – Return True if a ScriptError exception is raised instead of calling
- [**get_real_command**](#grass.script.core.get_real_command) – Returns the real file command for a module (cmd)
- [**gisenv**](#grass.script.core.gisenv) – Returns the output from running g.gisenv (with no arguments), as a
- [**handle_errors**](#grass.script.core.handle_errors) – Error handler for :func:`run_command()` and similar functions
- [**info**](#grass.script.core.info) – Display an informational message using `g.message -i`
- [**legal_name**](#grass.script.core.legal_name) – Checks if the string contains only allowed characters.
- [**list_grouped**](#grass.script.core.list_grouped) – List of elements grouped by mapsets.
- [**list_pairs**](#grass.script.core.list_pairs) – List of elements as pairs
- [**list_strings**](#grass.script.core.list_strings) – List of elements as strings.
- [**locn_is_latlong**](#grass.script.core.locn_is_latlong) – Tests if location is lat/long. Value is obtained
- [**make_command**](#grass.script.core.make_command) – Return a list of strings suitable for use as the args parameter to
- [**mapsets**](#grass.script.core.mapsets) – List available mapsets
- [**message**](#grass.script.core.message) – Display a message using `g.message`
- [**overwrite**](#grass.script.core.overwrite) – Return True if existing files may be overwritten
- [**parse_color**](#grass.script.core.parse_color) – Parses the string "val" as a GRASS colour, which can be either one of
- [**parse_command**](#grass.script.core.parse_command) – Passes all arguments to read_command, then parses the output
- [**parser**](#grass.script.core.parser) – Interface to g.parser, intended to be run from the top-level, e.g.:
- [**percent**](#grass.script.core.percent) – Display a progress info message using `g.message -p`
- [**pipe_command**](#grass.script.core.pipe_command) – Passes all arguments to start_command(), but also adds
- [**popen_args_command**](#grass.script.core.popen_args_command) – Split tool name and parameters from Popen parameters
- [**read_command**](#grass.script.core.read_command) – Passes all arguments to pipe_command, then waits for the process to
- [**region**](#grass.script.core.region) – Returns the output from running "g.region -gu", as a
- [**region_env**](#grass.script.core.region_env) – Returns region settings as a string which can used as
- [**run_command**](#grass.script.core.run_command) – Execute a module synchronously
- [**sanitize_mapset_environment**](#grass.script.core.sanitize_mapset_environment) – Remove environmental variables relevant only
- [**set_capture_stderr**](#grass.script.core.set_capture_stderr) – Enable capturing standard error output of modules and print it.
- [**set_raise_on_error**](#grass.script.core.set_raise_on_error) – Define behaviour on fatal error (fatal() called)
- [**start_command**](#grass.script.core.start_command) – Returns a Popen object with the command created by make_command.
- [**tempdir**](#grass.script.core.tempdir) – Returns the name of a temporary dir, created with g.tempfile.
- [**tempfile**](#grass.script.core.tempfile) – Returns the name of a temporary file, created with g.tempfile.
- [**tempname**](#grass.script.core.tempname) – Generate a GRASS and SQL compliant random name starting with tmp\_
- [**use_temp_region**](#grass.script.core.use_temp_region) – Copies the current region to a temporary region with "g.region save=",
- [**verbose**](#grass.script.core.verbose) – Display a verbose message using `g.message -v`
- [**verbosity**](#grass.script.core.verbosity) – Return the verbosity level selected by GRASS_VERBOSE
- [**version**](#grass.script.core.version) – Get GRASS version as dictionary
- [**warning**](#grass.script.core.warning) – Display a warning message using `g.message -w`
- [**write_command**](#grass.script.core.write_command) – Execute a module with standard input given by *stdin* parameter.

**Attributes:**

- [**PIPE**](#grass.script.core.PIPE) –
- [**STDOUT**](#grass.script.core.STDOUT) –
- [**T**](#grass.script.core.T) –
- [**named_colors**](#grass.script.core.named_colors) (<code>[dict](#dict)\[[str](#str), [tuple](#tuple)\[[float](#float), [float](#float), [float](#float)\]\]</code>) –
- [**raise_on_error**](#grass.script.core.raise_on_error) –

##### grass.script.core.PIPE

```python
PIPE = subprocess.PIPE
```

##### grass.script.core.Popen

```python
Popen(args, **kwargs)
```

Bases: <code>[Popen](#subprocess.Popen)</code>

##### grass.script.core.STDOUT

```python
STDOUT = subprocess.STDOUT
```

##### grass.script.core.T

```python
T = TypeVar('T')
```

##### grass.script.core.call

```python
call(*args, **kwargs)
```

##### grass.script.core.compare_key_value_text_files

```python
compare_key_value_text_files(filename_a, filename_b, sep=':', val_sep=',', precision=1e-06, proj=False, units=False)
```

Compare two key-value text files

This method will print a warning in case keys that are present in the first
file are not present in the second one.
The comparison method tries to convert the values into their native format
(float, int or string) to allow correct comparison.

An example key-value text file may have this content:

::

```
a: Hello
b: 1.0
c: 1,2,3,4,5
d : hello,8,0.1
```

:param str filename_a: name of the first key-value text file
:param str filenmae_b: name of the second key-value text file
:param str sep: character that separates the keys and values, default is ":"
:param str val_sep: character that separates the values of a single key,
default is ","
:param double precision: precision with which the floating point values are compared
:param bool proj: True if it has to check some information about projection system
:param bool units: True if it has to check some information about units

:return: True if full or almost identical, False if different

##### grass.script.core.create_environment

```python
create_environment(gisdbase, location, mapset, env=None)
```

Creates environment to be passed in run_command for example.
Returns tuple with temporary file path and the environment. The user
of this function is responsible for deleting the file.

##### grass.script.core.create_location

```python
create_location(*args, **kwargs)
```

##### grass.script.core.create_project

```python
create_project(path, name=None, epsg=None, proj4=None, filename=None, wkt=None, datum=None, datum_trans=None, desc=None, overwrite=False)
```

Create new project

Raise ScriptError on error.

:param str path: path to GRASS database or project; if path to database, project
name must be specified with name parameter
:param str name: project name to create
:param epsg: if given create new project based on EPSG code
:param proj4: if given create new project based on Proj4 definition
:param str filename: if given create new project based on georeferenced file
:param str wkt: if given create new project based on WKT definition
(can be path to PRJ file or WKT string)
:param datum: GRASS format datum code
:param datum_trans: datum transformation parameters (used for epsg and proj4)
:param desc: description of the project (creates MYNAME file)
:param bool overwrite: True to overwrite project if exists (WARNING:
ALL DATA from existing project ARE DELETED!)

##### grass.script.core.debug

```python
debug(msg, debug=1, env=None)
```

Display a debugging message using `g.message -d`.

The visibility of a debug message at runtime is controlled by
setting the corresponding DEBUG level with `g.gisenv set="DEBUG=X"`
(with `X` set to the debug level specified in the function call).

:param str msg: debugging message to be displayed
:param str debug: debug level (0-5) with the following recommended levels:
Use 1 for messages generated once of few times,
3 for messages generated for each raster row or vector line,
5 for messages generated for each raster cell or vector point.
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.debug_level

```python
debug_level(force=False)
```

##### grass.script.core.del_temp_region

```python
del_temp_region()
```

Unsets WIND_OVERRIDE and removes any region named by it.

##### grass.script.core.error

```python
error(msg, env=None)
```

Display an error message using `g.message -e`

This function does not end the execution of the program.
The right action after the error is up to the caller.
For error handling using the standard mechanism use :func:`fatal()`.

:param str msg: error message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.exec_command

```python
exec_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, env=None, **kwargs)
```

Interface to os.execvpe(), but with the make_command() interface.

:param str prog: GRASS module
:param str flags: flags to be used (given as a string)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param env: dictionary with system environment variables (`os.environ` by default)
:param list kwargs: module's parameters

##### grass.script.core.fatal

```python
fatal(msg, env=None)
```

Display an error message using `g.message -e`, then abort or raise

Raises exception when module global raise_on_error is 'True', abort
(calls exit) otherwise.
Use :func:`set_raise_on_error()` to set the behavior.

:param str msg: error message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.feed_command

```python
feed_command(*args, **kwargs)
```

Passes all arguments to start_command(), but also adds
"stdin = PIPE". Returns the Popen object.

:param list args: list of unnamed arguments (see start_command() for details)
:param list kwargs: list of named arguments (see start_command() for details)

:return: Popen object

##### grass.script.core.find_file

```python
find_file(name, element='cell', mapset=None, env=None)
```

Returns the output from running g.findfile as a
dictionary.

Elements in g.findfile refer to mapset directories. However, in
parts of the code, different element terms like rast, raster, or rast3d
are used. For convenience the function translates such element types
to respective mapset elements. Current translations are:
"rast": "cell",
"raster": "cell",
"rast3d": "grid3",
"raster3d": "grid3",
"raster_3d": "grid3",

Example:

> > > result = find_file("elevation", element="cell")
> > > print(result["fullname"])
> > > elevation@PERMANENT
> > > print(result["file"]) # doctest: +ELLIPSIS
> > > /.../PERMANENT/cell/elevation
> > > result = find_file("elevation", element="raster")
> > > print(result["fullname"])
> > > elevation@PERMANENT
> > > print(result["file"]) # doctest: +ELLIPSIS
> > > /.../PERMANENT/cell/elevation

:param str name: file name
:param str element: element type (default 'cell')
:param str mapset: mapset name (default all mapsets in search path)
:param env: environment

:return: parsed output of g.findfile

##### grass.script.core.find_program

```python
find_program(pgm, *args)
```

Attempt to run a program, with optional arguments.

You must call the program in a way that will return a successful
exit code. For GRASS modules this means you need to pass it some
valid CLI option, like "--help". For other programs a common
valid do-little option is usually "--version".

Example:

> > > find_program("r.sun", "--help")
> > > True
> > > find_program("ls", "--version")
> > > True

:param str pgm: program name
:param args: list of arguments

:return: False if the attempt failed due to a missing executable
or non-zero return code
:return: True otherwise

##### grass.script.core.get_capture_stderr

```python
get_capture_stderr()
```

Return True if stderr is captured, False otherwise.

See set_capture_stderr().

##### grass.script.core.get_commands

```python
get_commands(*, env=None)
```

Create list of available GRASS commands to use when parsing
string from the command line

:return: list of commands (set) and directory of scripts (collected
by extension - MS Windows only)

> > > cmds = list(get_commands()[0])
> > > cmds.sort()
> > > cmds[:5]
> > > ['d.barscale', 'd.colorlist', 'd.colortable', 'd.correlate', 'd.erase']

##### grass.script.core.get_raise_on_error

```python
get_raise_on_error()
```

Return True if a ScriptError exception is raised instead of calling
sys.exit(1) in case a fatal error was invoked with fatal()

##### grass.script.core.get_real_command

```python
get_real_command(cmd)
```

Returns the real file command for a module (cmd)

For Python scripts on MS Windows it returns full path to the script
and adds a '.py' extension.
For other cases it just returns a module (name).
So, you can just use this function for all without further check.

> > > get_real_command("g.region")
> > > 'g.region'

:param cmd: the command

##### grass.script.core.gisenv

```python
gisenv(env=None)
```

Returns the output from running g.gisenv (with no arguments), as a
dictionary. Example:

> > > env = gisenv()
> > > print(env["GISDBASE"]) # doctest: +SKIP
> > > /opt/grass-data

:param env: dictionary with system environment variables (`os.environ` by default)
:return: list of GRASS variables

##### grass.script.core.handle_errors

```python
handle_errors(returncode, result, args, kwargs)
```

Error handler for :func:`run_command()` and similar functions

The functions which are using this function to handle errors,
can be typically called with an *errors* parameter.
This function can handle one of the following values: raise,
fatal, status, exit, and ignore. The value raise is a default.

If returncode is 0, *result* is returned, unless
`errors="status"` is set.

If *kwargs* dictionary contains key `errors`, the value is used
to determine the return value and the behavior on error.
The value `errors="raise"` is a default in which case a
`CalledModuleError` exception is raised.

For `errors="fatal"`, the function calls :func:`fatal()`
which has its own rules on what happens next.

For `errors="status"`, the *returncode* will be returned.
This is useful, e.g., for cases when the exception-based error
handling mechanism is not desirable or the return code has some
meaning not necessarily interpreted as an error by the caller.

For `errors="exit"`, `sys.exit()` is called with the
*returncode*, so it behaves similarly to a Bash script with
`set -e`. No additional error message or exception is produced.
This might be useful for a simple script where error message
produced by the called module provides sufficient information about
what happened to the end user.

Finally, for `errors="ignore"`, the value of *result* will be
passed in any case regardless of the *returncode*.

##### grass.script.core.info

```python
info(msg, env=None)
```

Display an informational message using `g.message -i`

:param str msg: informational message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.legal_name

```python
legal_name(s)
```

Checks if the string contains only allowed characters.

This is the Python implementation of :func:`G_legal_filename()` function.

..note::

```
It is not clear when exactly use this function, but it might be
useful anyway for checking map names and column names.
```

##### grass.script.core.list_grouped

```python
list_grouped(type, pattern=None, check_search_path=True, exclude=None, flag='', env=None)
```

List of elements grouped by mapsets.

Returns the output from running g.list, as a dictionary where the
keys are mapset names and the values are lists of maps in that
mapset. Example:

> > > list_grouped("vect", pattern="*roads*")["PERMANENT"]
> > > ['railroads', 'roadsmajor']

:param str type: element type (raster, vector, raster_3d, region, ...)
or list of elements
:param str pattern: pattern string
:param str check_search_path: True to add mapsets for the search path
with no found elements
:param str exclude: pattern string to exclude maps from the research
:param str flag: pattern type: 'r' (basic regexp), 'e' (extended regexp),
or '' (glob pattern)
:param env: environment

:return: directory of mapsets/elements

##### grass.script.core.list_pairs

```python
list_pairs(type, pattern=None, mapset=None, exclude=None, flag='', env=None)
```

List of elements as pairs

Returns the output from running g.list, as a list of
(name, mapset) pairs

:param str type: element type (raster, vector, raster_3d, region, ...)
:param str pattern: pattern string
:param str mapset: mapset name (if not given use search path)
:param str exclude: pattern string to exclude maps from the research
:param str flag: pattern type: 'r' (basic regexp), 'e' (extended regexp),
or '' (glob pattern)
:param env: environment

:return: list of elements

##### grass.script.core.list_strings

```python
list_strings(type, pattern=None, mapset=None, exclude=None, flag='', env=None)
```

List of elements as strings.

Returns the output from running g.list, as a list of qualified
names.

:param str type: element type (raster, vector, raster_3d, region, ...)
:param str pattern: pattern string
:param str mapset: mapset name (if not given use search path)
:param str exclude: pattern string to exclude maps from the research
:param str flag: pattern type: 'r' (basic regexp), 'e' (extended regexp),
or '' (glob pattern)
:param env: environment

:return: list of elements

##### grass.script.core.locn_is_latlong

```python
locn_is_latlong(env=None)
```

Tests if location is lat/long. Value is obtained
by checking the "g.region -pu" projection code.

:return: True for a lat/long region, False otherwise

##### grass.script.core.make_command

```python
make_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, errors=None, **options)
```

Return a list of strings suitable for use as the args parameter to
Popen() or call(). Example:

> > > make_command("g.message", flags="w", message="this is a warning")
> > > ['g.message', '-w', 'message=this is a warning']

:param str prog: GRASS module
:param str flags: flags to be used (given as a string)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param options: module's parameters

:return: list of arguments

##### grass.script.core.mapsets

```python
mapsets(search_path=False, env=None)
```

List available mapsets

:param bool search_path: True to list mapsets only in search path

:return: list of mapsets

##### grass.script.core.message

```python
message(msg, flag=None, env=None)
```

Display a message using `g.message`

:param str msg: message to be displayed
:param str flag: flags (given as string)
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.named_colors

```python
named_colors: dict[str, tuple[float, float, float]] = {'white': (1.0, 1.0, 1.0), 'black': (0.0, 0.0, 0.0), 'red': (1.0, 0.0, 0.0), 'green': (0.0, 1.0, 0.0), 'blue': (0.0, 0.0, 1.0), 'yellow': (1.0, 1.0, 0.0), 'magenta': (1.0, 0.0, 1.0), 'cyan': (0.0, 1.0, 1.0), 'aqua': (0.0, 0.75, 0.75), 'grey': (0.75, 0.75, 0.75), 'gray': (0.75, 0.75, 0.75), 'orange': (1.0, 0.5, 0.0), 'brown': (0.75, 0.5, 0.25), 'purple': (0.5, 0.0, 1.0), 'violet': (0.5, 0.0, 1.0), 'indigo': (0.0, 0.5, 1.0)}
```

##### grass.script.core.overwrite

```python
overwrite()
```

Return True if existing files may be overwritten

##### grass.script.core.parse_color

```python
parse_color(val, dflt=None)
```

Parses the string "val" as a GRASS colour, which can be either one of
the named colours or an R:G:B tuple e.g. 255:255:255. Returns an
(r,g,b) triple whose components are floating point values between 0
and 1. Example:

> > > parse_color("red")
> > > (1.0, 0.0, 0.0)
> > > parse_color("255:0:0")
> > > (1.0, 0.0, 0.0)

:param val: color value
:param dflt: default color value

:return: tuple RGB

##### grass.script.core.parse_command

```python
parse_command(*args, **kwargs)
```

Passes all arguments to read_command, then parses the output
by default with parse_key_val().

If the command has parameter <em>format</em> and is called with
<em>format=json</em>, the output will be parsed into a dictionary.
Similarly, with <em>format=csv</em> the output will be parsed into
a list of lists (CSV rows).

::

```
parse_command("v.db.select", ..., format="json")
```

Custom parsing function can be optionally given by <em>parse</em> parameter
including its arguments, e.g.

::

```
parse_command(..., parse=(gs.parse_key_val, {"sep": ":"}))
```

Parameter <em>delimiter</em> is deprecated.

:param args: list of unnamed arguments (see start_command() for details)
:param kwargs: list of named arguments (see start_command() for details)

:return: parsed module output

##### grass.script.core.parser

```python
parser()
```

Interface to g.parser, intended to be run from the top-level, e.g.:

::

```
if __name__ == "__main__":
    options, flags = grass.parser()
    main()
```

Thereafter, the global variables "options" and "flags" will be
dictionaries containing option/flag values, keyed by lower-case
option/flag names. The values in "options" are strings, those in
"flags" are Python booleans.

Overview table of parser standard options:
https://grass.osgeo.org/grass-devel/manuals/parser_standard_options.html

##### grass.script.core.percent

```python
percent(i, n, s, env=None)
```

Display a progress info message using `g.message -p`

::

```
message(_("Percent complete..."))
n = 100
for i in range(n):
    percent(i, n, 1)
percent(1, 1, 1)
```

:param int i: current item
:param int n: total number of items
:param int s: increment size
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.pipe_command

```python
pipe_command(*args, **kwargs)
```

Passes all arguments to start_command(), but also adds
"stdout = PIPE". Returns the Popen object.

> > > p = pipe_command("g.gisenv")
> > > print(p) # doctest: +ELLIPSIS
> > > \<....Popen object at 0x...>
> > > print(p.communicate()[0]) # doctest: +SKIP
> > > GISDBASE='/opt/grass-data';
> > > LOCATION_NAME='spearfish60';
> > > MAPSET='glynn';
> > > GUI='text';
> > > MONITOR='x0';

:param list args: list of unnamed arguments (see start_command() for details)
:param list kwargs: list of named arguments (see start_command() for details)

:return: Popen object

##### grass.script.core.popen_args_command

```python
popen_args_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, **kwargs)
```

Split tool name and parameters from Popen parameters

Does the splitting based on known Popen parameter names, and then does the
transformation from Python parameters to a list of command line arguments
for Popen.

##### grass.script.core.raise_on_error

```python
raise_on_error = False
```

##### grass.script.core.read_command

```python
read_command(*args, **kwargs)
```

Passes all arguments to pipe_command, then waits for the process to
complete, returning its stdout (i.e. similar to shell `backticks`).

The behavior on error can be changed using *errors* parameter
which is passed to the :func:`handle_errors()` function.

:param list args: list of unnamed arguments (see start_command() for details)
:param list kwargs: list of named arguments (see start_command() for details)

:return: stdout

##### grass.script.core.region

```python
region(region3d=False, complete=False, env=None)
```

Returns the output from running "g.region -gu", as a
dictionary. Example:

:param bool region3d: True to get 3D region
:param bool complete:
:param env: dictionary with system environment variables (`os.environ` by default)

> > > curent_region = region()
> > >
> > > # obtain n, s, e and w values
> > >
> > > \[curent_region[key] for key in "nsew"\] # doctest: +ELLIPSIS
> > > [..., ..., ..., ...]
> > >
> > > # obtain ns and ew resolutions
> > >
> > > (curent_region["nsres"], curent_region["ewres"]) # doctest: +ELLIPSIS
> > > (..., ...)

:return: dictionary of region values

##### grass.script.core.region_env

```python
region_env(region3d=False, flags=None, env=None, **kwargs)
```

Returns region settings as a string which can used as
GRASS_REGION environmental variable.

If no 'kwargs' are given then the current region is used. Note
that this function doesn't modify the current region!

See also :func:`use_temp_region()` for alternative method how to define
temporary region used for raster-based computation.

:param region3d: True to get 3D region
:param flags: for example 'a'
:param env: dictionary with system environment variables (`os.environ` by default)
:param kwargs: g.region's parameters like 'raster', 'vector' or 'region'

::

```
os.environ["GRASS_REGION"] = grass.region_env(region="detail")
grass.mapcalc("map=1", overwrite=True)
os.environ.pop("GRASS_REGION")
```

:return: string with region values
:return: empty string on error

##### grass.script.core.run_command

```python
run_command(*args, **kwargs)
```

Execute a module synchronously

This function passes all arguments to `start_command()`,
then waits for the process to complete. It is similar to
`subprocess.check_call()`, but with the :func:`make_command()`
interface. By default, an exception is raised in case of a non-zero
return code by default.

> > > run_command("g.region", raster="elevation")

See :func:`start_command()` for details about parameters and usage.

The behavior on error can be changed using *errors* parameter
which is passed to the :func:`handle_errors()` function.

:param \*args: unnamed arguments passed to :func:`start_command()`
:param \*\*kwargs: named arguments passed to :func:`start_command()`
:param str errors: passed to :func:`handle_errors()`

.. versionchanged:: 8.0
Before 8.0, the function was returning 0 when no error occurred
for backward compatibility with code which was checking that
value. Now the function returns None, unless `errors="status"`
is specified.
.. versionchanged:: 7.2
In 7.0.0, this function was returning the error code. However,
it was rarely checked especially outside of the core code.
Additionally, :func:`read_command()` needed a mechanism to
report errors as it was used more and more in context which
required error handling, Thus, exceptions were introduced as a
more expected default behavior for Python programmers. The
change was backported to 7.0 series.

:raises: `CalledModuleError` when module returns non-zero return code

##### grass.script.core.sanitize_mapset_environment

```python
sanitize_mapset_environment(env)
```

Remove environmental variables relevant only
for a specific mapset. This should be called
when a copy of environment is used with a different mapset.

##### grass.script.core.set_capture_stderr

```python
set_capture_stderr(capture=True)
```

Enable capturing standard error output of modules and print it.

By default, standard error output (stderr) of child processes shows
in the same place as output of the parent process. This may not
always be the same place as `sys.stderr` is written.
After calling this function, functions in the `grass.script`
package will capture the stderr of child processes and pass it
to `sys.stderr` if there is an error.

.. note::

```
This is advantageous for interactive shells such as the one in GUI
and interactive notebooks such as Jupyter Notebook.
```

The capturing can be applied only in certain cases, for example
in case of run_command() it is applied because run_command() nor
its callers do not handle the streams, however feed_command()
cannot do capturing because its callers handle the streams.

The previous state is returned. Passing `False` disables the
capturing.

.. versionadded:: 7.4

##### grass.script.core.set_raise_on_error

```python
set_raise_on_error(raise_exp=True)
```

Define behaviour on fatal error (fatal() called)

:param bool raise_exp: True to raise ScriptError instead of calling
sys.exit(1) in fatal()

:return: current status

##### grass.script.core.start_command

```python
start_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, **kwargs)
```

Returns a Popen object with the command created by make_command.
Accepts any of the arguments which Popen() accepts apart from "args"
and "shell".

> > > p = start_command("g.gisenv", stdout=subprocess.PIPE)
> > > print(p) # doctest: +ELLIPSIS
> > > \<...Popen object at 0x...>
> > > print(p.communicate()[0]) # doctest: +SKIP
> > > GISDBASE='/opt/grass-data';
> > > LOCATION_NAME='spearfish60';
> > > MAPSET='glynn';
> > > GUI='text';
> > > MONITOR='x0';

If the module parameter is the same as Python keyword, add
underscore at the end of the parameter. For example, use
`lambda_=1.6` instead of `lambda=1.6`.

:param str prog: GRASS module
:param str flags: flags to be used (given as a string)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param kwargs: module's parameters

:return: Popen object

##### grass.script.core.tempdir

```python
tempdir(env=None)
```

Returns the name of a temporary dir, created with g.tempfile.

##### grass.script.core.tempfile

```python
tempfile(create=True, env=None)
```

Returns the name of a temporary file, created with g.tempfile.

:param bool create: True to create a file
:param env: environment

:return: path to a tmp file

##### grass.script.core.tempname

```python
tempname(length, lowercase=False)
```

Generate a GRASS and SQL compliant random name starting with tmp\_
followed by a random part of length "length"

:param int length: length of the random part of the name to generate
:param bool lowercase: use only lowercase characters to generate name
:returns: String with a random name of length "length" starting with a letter
:rtype: str

:Example:

> > > tempname(12)
> > > 'tmp_MxMa1kAS13s9'

.. seealso:: functions :func:`append_uuid()`, :func:`append_random()`

##### grass.script.core.use_temp_region

```python
use_temp_region()
```

Copies the current region to a temporary region with "g.region save=",
then sets WIND_OVERRIDE to refer to that region. Installs an atexit
handler to delete the temporary region upon termination.

##### grass.script.core.verbose

```python
verbose(msg, env=None)
```

Display a verbose message using `g.message -v`

:param str msg: verbose message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.verbosity

```python
verbosity()
```

Return the verbosity level selected by GRASS_VERBOSE

Currently, there are 5 levels of verbosity:
-1 nothing will be printed (also fatal errors and warnings will be discarded)

0 only errors and warnings are printed, triggered by "--q" or "--quiet" flag.

1 progress information (percent) and important messages will be printed

2 all messages will be printed

3 also verbose messages will be printed. Triggered by "--v" or "--verbose" flag.

##### grass.script.core.version

```python
version()
```

Get GRASS version as dictionary

::

```
>>> print(version())
{'proj4': '4.8.0', 'geos': '3.3.5', 'libgis_revision': '52468',
 'libgis_date': '2012-07-27 22:53:30 +0200 (Fri, 27 Jul 2012)',
 'version': '7.0.svn', 'date': '2012', 'gdal': '2.0dev',
 'revision': '53670'}
```

##### grass.script.core.warning

```python
warning(msg, env=None)
```

Display a warning message using `g.message -w`

:param str msg: warning message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

##### grass.script.core.write_command

```python
write_command(*args, **kwargs)
```

Execute a module with standard input given by *stdin* parameter.

Passes all arguments to `feed_command()`, with the string specified
by the *stdin* argument fed to the process' standard input.

> > > write_command(
> > > ... "v.in.ascii",
> > > ... input="-",
> > > ... stdin="%s|%s" % (635818.8, 221342.4),
> > > ... output="view_point",
> > > ... )
> > > 0

See `start_command()` for details about parameters and usage.

The behavior on error can be changed using *errors* parameter
which is passed to the :func:`handle_errors()` function.

:param \*args: unnamed arguments passed to `start_command()`
:param \*\*kwargs: named arguments passed to `start_command()`

:returns: 0 with default parameters for backward compatibility only

:raises: `CalledModuleError` when module returns non-zero return code

#### grass.script.create_environment

```python
create_environment(gisdbase, location, mapset, env=None)
```

Creates environment to be passed in run_command for example.
Returns tuple with temporary file path and the environment. The user
of this function is responsible for deleting the file.

#### grass.script.create_location

```python
create_location(*args, **kwargs)
```

#### grass.script.create_project

```python
create_project(path, name=None, epsg=None, proj4=None, filename=None, wkt=None, datum=None, datum_trans=None, desc=None, overwrite=False)
```

Create new project

Raise ScriptError on error.

:param str path: path to GRASS database or project; if path to database, project
name must be specified with name parameter
:param str name: project name to create
:param epsg: if given create new project based on EPSG code
:param proj4: if given create new project based on Proj4 definition
:param str filename: if given create new project based on georeferenced file
:param str wkt: if given create new project based on WKT definition
(can be path to PRJ file or WKT string)
:param datum: GRASS format datum code
:param datum_trans: datum transformation parameters (used for epsg and proj4)
:param desc: description of the project (creates MYNAME file)
:param bool overwrite: True to overwrite project if exists (WARNING:
ALL DATA from existing project ARE DELETED!)

#### grass.script.db

Database related functions to be used in Python scripts.

Usage:

::

```
from grass.script import db as grass

grass.db_describe(table)
...
```

(C) 2008-2015 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements
.. sectionauthor:: Martin Landa \<landa.martin gmail.com>

**Functions:**

- [**db_begin_transaction**](#grass.script.db.db_begin_transaction) – Begin transaction.
- [**db_commit_transaction**](#grass.script.db.db_commit_transaction) – Commit transaction.
- [**db_connection**](#grass.script.db.db_connection) – Return the current database connection parameters
- [**db_describe**](#grass.script.db.db_describe) – Return the list of columns for a database table
- [**db_select**](#grass.script.db.db_select) – Perform SQL select statement
- [**db_table_exist**](#grass.script.db.db_table_exist) – Check if table exists.
- [**db_table_in_vector**](#grass.script.db.db_table_in_vector) – Return the name of vector connected to the table.

##### grass.script.db.db_begin_transaction

```python
db_begin_transaction(driver)
```

Begin transaction.

:return: SQL command as string

##### grass.script.db.db_commit_transaction

```python
db_commit_transaction(driver)
```

Commit transaction.

:return: SQL command as string

##### grass.script.db.db_connection

```python
db_connection(force=False, env=None)
```

Return the current database connection parameters
(interface to `db.connect -g`). Example:

> > > db_connection()
> > > {'group': '', 'schema': '', 'driver': 'sqlite', 'database': '$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'}

:param force True to set up default DB connection if not defined
:param env: environment

:return: parsed output of db.connect

##### grass.script.db.db_describe

```python
db_describe(table, env=None, **args)
```

Return the list of columns for a database table
(interface to `db.describe -c`). Example:

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_describe("myfirestations") # doctest: +ELLIPSIS
> > > {'nrows': 71, 'cols': \[['cat', 'INTEGER', '20'], ... 'ncols': 22}
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str table: table name
:param list args:
:param env: environment

:return: parsed module output

##### grass.script.db.db_select

```python
db_select(sql=None, filename=None, table=None, env=None, **args)
```

Perform SQL select statement

Note: one of <em>sql</em>, <em>filename</em>, or <em>table</em>
arguments must be provided.

Examples:

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_select(sql="SELECT cat,CITY FROM myfirestations WHERE cat < 4")
> > > (('1', 'Morrisville'), ('2', 'Morrisville'), ('3', 'Apex'))

Simplified usage (it performs <tt>SELECT * FROM myfirestations</tt>.)

> > > db_select(table="myfirestations") # doctest: +ELLIPSIS
> > > (('1', '24', 'Morrisville #3', ... 'HS2A', '1.37'))
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str sql: SQL statement to perform (or None)
:param str filename: name of file with SQL statements (or None)
:param str table: name of table to query (or None)
:param str args: see *db.select* arguments
:param env: environment

##### grass.script.db.db_table_exist

```python
db_table_exist(table, env=None, **args)
```

Check if table exists.

If no driver or database are given, then default settings is used
(check db_connection()).

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_table_exist("myfirestations")
> > > True
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str table: table name
:param args:
:param env: environment

:return: True for success, False otherwise

##### grass.script.db.db_table_in_vector

```python
db_table_in_vector(table, mapset='.', env=None)
```

Return the name of vector connected to the table.
By default it check only in the current mapset, because the same table
name could be used also in other mapset by other vector.
It returns None if no vectors are connected to the table.

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_table_in_vector("myfirestations")
> > > ['myfirestations@user1']
> > > db_table_in_vector("mfirestations")
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str table: name of table to query
:param env: environment

#### grass.script.db_begin_transaction

```python
db_begin_transaction(driver)
```

Begin transaction.

:return: SQL command as string

#### grass.script.db_commit_transaction

```python
db_commit_transaction(driver)
```

Commit transaction.

:return: SQL command as string

#### grass.script.db_connection

```python
db_connection(force=False, env=None)
```

Return the current database connection parameters
(interface to `db.connect -g`). Example:

> > > db_connection()
> > > {'group': '', 'schema': '', 'driver': 'sqlite', 'database': '$GISDBASE/$LOCATION_NAME/$MAPSET/sqlite/sqlite.db'}

:param force True to set up default DB connection if not defined
:param env: environment

:return: parsed output of db.connect

#### grass.script.db_describe

```python
db_describe(table, env=None, **args)
```

Return the list of columns for a database table
(interface to `db.describe -c`). Example:

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_describe("myfirestations") # doctest: +ELLIPSIS
> > > {'nrows': 71, 'cols': \[['cat', 'INTEGER', '20'], ... 'ncols': 22}
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str table: table name
:param list args:
:param env: environment

:return: parsed module output

#### grass.script.db_select

```python
db_select(sql=None, filename=None, table=None, env=None, **args)
```

Perform SQL select statement

Note: one of <em>sql</em>, <em>filename</em>, or <em>table</em>
arguments must be provided.

Examples:

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_select(sql="SELECT cat,CITY FROM myfirestations WHERE cat < 4")
> > > (('1', 'Morrisville'), ('2', 'Morrisville'), ('3', 'Apex'))

Simplified usage (it performs <tt>SELECT * FROM myfirestations</tt>.)

> > > db_select(table="myfirestations") # doctest: +ELLIPSIS
> > > (('1', '24', 'Morrisville #3', ... 'HS2A', '1.37'))
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str sql: SQL statement to perform (or None)
:param str filename: name of file with SQL statements (or None)
:param str table: name of table to query (or None)
:param str args: see *db.select* arguments
:param env: environment

#### grass.script.db_table_exist

```python
db_table_exist(table, env=None, **args)
```

Check if table exists.

If no driver or database are given, then default settings is used
(check db_connection()).

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_table_exist("myfirestations")
> > > True
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str table: table name
:param args:
:param env: environment

:return: True for success, False otherwise

#### grass.script.db_table_in_vector

```python
db_table_in_vector(table, mapset='.', env=None)
```

Return the name of vector connected to the table.
By default it check only in the current mapset, because the same table
name could be used also in other mapset by other vector.
It returns None if no vectors are connected to the table.

> > > run_command("g.copy", vector="firestations,myfirestations")
> > > 0
> > > db_table_in_vector("myfirestations")
> > > ['myfirestations@user1']
> > > db_table_in_vector("mfirestations")
> > > run_command("g.remove", flags="f", type="vector", name="myfirestations")
> > > 0

:param str table: name of table to query
:param env: environment

#### grass.script.debug

```python
debug(msg, debug=1, env=None)
```

Display a debugging message using `g.message -d`.

The visibility of a debug message at runtime is controlled by
setting the corresponding DEBUG level with `g.gisenv set="DEBUG=X"`
(with `X` set to the debug level specified in the function call).

:param str msg: debugging message to be displayed
:param str debug: debug level (0-5) with the following recommended levels:
Use 1 for messages generated once of few times,
3 for messages generated for each raster row or vector line,
5 for messages generated for each raster cell or vector point.
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.debug_level

```python
debug_level(force=False)
```

#### grass.script.decode

```python
decode(bytes_, encoding=None)
```

Decode bytes with default locale and return (unicode) string

No-op if parameter is not bytes (assumed unicode string).

:param bytes bytes\_: the bytes to decode
:param encoding: encoding to be used, default value is None

## Example

> > > decode(b"SÃ¼dtirol")
> > > u'Südtirol'
> > > decode("Südtirol")
> > > u'Südtirol'
> > > decode(1234)
> > > u'1234'

#### grass.script.del_temp_region

```python
del_temp_region()
```

Unsets WIND_OVERRIDE and removes any region named by it.

#### grass.script.diff_files

```python
diff_files(filename_a, filename_b)
```

Diffs two text files and returns difference.

:param str filename_a: first file path
:param str filename_b: second file path

:return: list of strings

#### grass.script.encode

```python
encode(string, encoding=None)
```

Encode string with default locale and return bytes with that encoding

No-op if parameter is bytes (assumed already encoded).
This ensures garbage in, garbage out.

:param string: the string to encode
:param encoding: encoding to be used, default value is None

## Example

> > > encode(b"SÃ¼dtirol")
> > > b'SÃ¼dtirol'
> > > decode("Südtirol")
> > > b'SÃ¼dtirol'
> > > decode(1234)
> > > b'1234'

#### grass.script.error

```python
error(msg, env=None)
```

Display an error message using `g.message -e`

This function does not end the execution of the program.
The right action after the error is up to the caller.
For error handling using the standard mechanism use :func:`fatal()`.

:param str msg: error message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.exec_command

```python
exec_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, env=None, **kwargs)
```

Interface to os.execvpe(), but with the make_command() interface.

:param str prog: GRASS module
:param str flags: flags to be used (given as a string)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param env: dictionary with system environment variables (`os.environ` by default)
:param list kwargs: module's parameters

#### grass.script.fatal

```python
fatal(msg, env=None)
```

Display an error message using `g.message -e`, then abort or raise

Raises exception when module global raise_on_error is 'True', abort
(calls exit) otherwise.
Use :func:`set_raise_on_error()` to set the behavior.

:param str msg: error message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.feed_command

```python
feed_command(*args, **kwargs)
```

Passes all arguments to start_command(), but also adds
"stdin = PIPE". Returns the Popen object.

:param list args: list of unnamed arguments (see start_command() for details)
:param list kwargs: list of named arguments (see start_command() for details)

:return: Popen object

#### grass.script.find_file

```python
find_file(name, element='cell', mapset=None, env=None)
```

Returns the output from running g.findfile as a
dictionary.

Elements in g.findfile refer to mapset directories. However, in
parts of the code, different element terms like rast, raster, or rast3d
are used. For convenience the function translates such element types
to respective mapset elements. Current translations are:
"rast": "cell",
"raster": "cell",
"rast3d": "grid3",
"raster3d": "grid3",
"raster_3d": "grid3",

Example:

> > > result = find_file("elevation", element="cell")
> > > print(result["fullname"])
> > > elevation@PERMANENT
> > > print(result["file"]) # doctest: +ELLIPSIS
> > > /.../PERMANENT/cell/elevation
> > > result = find_file("elevation", element="raster")
> > > print(result["fullname"])
> > > elevation@PERMANENT
> > > print(result["file"]) # doctest: +ELLIPSIS
> > > /.../PERMANENT/cell/elevation

:param str name: file name
:param str element: element type (default 'cell')
:param str mapset: mapset name (default all mapsets in search path)
:param env: environment

:return: parsed output of g.findfile

#### grass.script.find_program

```python
find_program(pgm, *args)
```

Attempt to run a program, with optional arguments.

You must call the program in a way that will return a successful
exit code. For GRASS modules this means you need to pass it some
valid CLI option, like "--help". For other programs a common
valid do-little option is usually "--version".

Example:

> > > find_program("r.sun", "--help")
> > > True
> > > find_program("ls", "--version")
> > > True

:param str pgm: program name
:param args: list of arguments

:return: False if the attempt failed due to a missing executable
or non-zero return code
:return: True otherwise

#### grass.script.float_or_dms

```python
float_or_dms(s)
```

Convert DMS to float.

> > > round(float_or_dms("26:45:30"), 5)
> > > 26.75833
> > > round(float_or_dms("26:0:0.1"), 5)
> > > 26.00003

:param s: DMS value

:return: float value

#### grass.script.get_capture_stderr

```python
get_capture_stderr()
```

Return True if stderr is captured, False otherwise.

See set_capture_stderr().

#### grass.script.get_commands

```python
get_commands(*, env=None)
```

Create list of available GRASS commands to use when parsing
string from the command line

:return: list of commands (set) and directory of scripts (collected
by extension - MS Windows only)

> > > cmds = list(get_commands()[0])
> > > cmds.sort()
> > > cmds[:5]
> > > ['d.barscale', 'd.colorlist', 'd.colortable', 'd.correlate', 'd.erase']

#### grass.script.get_lib_path

```python
get_lib_path(modname, libname=None)
```

Return the path of the libname contained in the module.

#### grass.script.get_num_suffix

```python
get_num_suffix(number, max_number)
```

Returns formatted number with number of padding zeros
depending on maximum number, used for creating suffix for data series.
Does not include the suffix separator.

:param number: number to be formatted as map suffix
:param max_number: maximum number of the series to get number of digits

> > > get_num_suffix(10, 1000)
> > > '0010'
> > > get_num_suffix(10, 10)
> > > '10'

#### grass.script.get_raise_on_error

```python
get_raise_on_error()
```

Return True if a ScriptError exception is raised instead of calling
sys.exit(1) in case a fatal error was invoked with fatal()

#### grass.script.get_real_command

```python
get_real_command(cmd)
```

Returns the real file command for a module (cmd)

For Python scripts on MS Windows it returns full path to the script
and adds a '.py' extension.
For other cases it just returns a module (name).
So, you can just use this function for all without further check.

> > > get_real_command("g.region")
> > > 'g.region'

:param cmd: the command

#### grass.script.gisenv

```python
gisenv(env=None)
```

Returns the output from running g.gisenv (with no arguments), as a
dictionary. Example:

> > > env = gisenv()
> > > print(env["GISDBASE"]) # doctest: +SKIP
> > > /opt/grass-data

:param env: dictionary with system environment variables (`os.environ` by default)
:return: list of GRASS variables

#### grass.script.group_to_dict

```python
group_to_dict(imagery_group_name, subgroup=None, dict_keys='semantic_labels', dict_values='map_names', fill_semantic_label=True, env=None)
```

Create a dictionary to represent an imagery group with metadata.

Depending on the dict_keys option, the returned dictionary uses either
the names of the raster maps ("map_names"), their row indices in the group
("indices") or their associated semantic_labels ("semantic_labels") as keys.
The default is to use semantic_labels. Note that map metadata
of the maps in the group have to be read to get the semantic label,
in addition to the group file. The same metadata is read when the
"metadata" is requested as dict_values. Other supported dict_values
are "map_names" (default), "semantic_labels", or "indices".

The function can also operate on the level of subgroups. In case a
non-existing (or empty sub-group) is requested a warning is printed
and an empty dictionary is returned (following the behavior of i.group).

Example::

> > > run_command("g.copy", raster="lsat7_2000_10,lsat7_2000_10")
> > > run_command("r.support", raster="lsat7_2000_10", semantic_label="L8_1")
> > > run_command("g.copy", raster="lsat7_2000_20,lsat7_2000_20")
> > > run_command("r.support", raster="lsat7_2000_20", semantic_label="L8_2")
> > > run_command("g.copy", raster="lsat7_2000_30,lsat7_2000_30")
> > > run_command("r.support", raster="lsat7_2000_30", semantic_label="L8_3")
> > > run_command("i.group", group="L8_group",
> > > input="lsat7_2000_10,lsat7_2000_20,lsat7_2000_30")
> > > group_to_dict("L8_group") # doctest: +ELLIPSIS
> > > {"L8_1": "lsat7_2000_10", ... "L8_3": "lsat7_2000_30"}
> > > run_command("g.remove", flags="f", type="group", name="L8_group")
> > > run_command("g.remove", flags="f", type="raster",
> > > name="lsat7_2000_10,lsat7_2000_20,lsat7_2000_30")

:param str imagery_group_name: Name of the imagery group to process (or None)
:param str subgroup: Name of the imagery sub-group to process (or None)
:param str dict_keys: What to use as key for dictionary. It can be either
"semantic_labels" (default), "map_names" or "indices"
:param str dict_values: What to use as values for dictionary. It can be either
"map_names" (default), "semanic_labels", "indices" or
"metadata" (to return dictionaries with full map metadata)
:param bool fill_semantic_label: If maps in a group do not have a semantic
label, their index in the group is used
instead (default). Otherwise None / "none"
is used.
:param dict env: Environment to use when parsing the imagery group

:return: dictionary representing an imagery group with it's maps and their
semantic labels, row indices in the group, or metadata
:rtype: dict

#### grass.script.handle_errors

```python
handle_errors(returncode, result, args, kwargs)
```

Error handler for :func:`run_command()` and similar functions

The functions which are using this function to handle errors,
can be typically called with an *errors* parameter.
This function can handle one of the following values: raise,
fatal, status, exit, and ignore. The value raise is a default.

If returncode is 0, *result* is returned, unless
`errors="status"` is set.

If *kwargs* dictionary contains key `errors`, the value is used
to determine the return value and the behavior on error.
The value `errors="raise"` is a default in which case a
`CalledModuleError` exception is raised.

For `errors="fatal"`, the function calls :func:`fatal()`
which has its own rules on what happens next.

For `errors="status"`, the *returncode* will be returned.
This is useful, e.g., for cases when the exception-based error
handling mechanism is not desirable or the return code has some
meaning not necessarily interpreted as an error by the caller.

For `errors="exit"`, `sys.exit()` is called with the
*returncode*, so it behaves similarly to a Bash script with
`set -e`. No additional error message or exception is produced.
This might be useful for a simple script where error message
produced by the called module provides sufficient information about
what happened to the end user.

Finally, for `errors="ignore"`, the value of *result* will be
passed in any case regardless of the *returncode*.

#### grass.script.imagery

Imagery related functions to be used in Python scripts.

Usage:

::

```
import grass.script as gs

gs.imagery.group_to_dict(imagery_group)
...
```

(C) 2024 by Stefan Blumentrath and the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Stefan Blumentrath

**Functions:**

- [**group_to_dict**](#grass.script.imagery.group_to_dict) – Create a dictionary to represent an imagery group with metadata.

##### grass.script.imagery.group_to_dict

```python
group_to_dict(imagery_group_name, subgroup=None, dict_keys='semantic_labels', dict_values='map_names', fill_semantic_label=True, env=None)
```

Create a dictionary to represent an imagery group with metadata.

Depending on the dict_keys option, the returned dictionary uses either
the names of the raster maps ("map_names"), their row indices in the group
("indices") or their associated semantic_labels ("semantic_labels") as keys.
The default is to use semantic_labels. Note that map metadata
of the maps in the group have to be read to get the semantic label,
in addition to the group file. The same metadata is read when the
"metadata" is requested as dict_values. Other supported dict_values
are "map_names" (default), "semantic_labels", or "indices".

The function can also operate on the level of subgroups. In case a
non-existing (or empty sub-group) is requested a warning is printed
and an empty dictionary is returned (following the behavior of i.group).

Example::

> > > run_command("g.copy", raster="lsat7_2000_10,lsat7_2000_10")
> > > run_command("r.support", raster="lsat7_2000_10", semantic_label="L8_1")
> > > run_command("g.copy", raster="lsat7_2000_20,lsat7_2000_20")
> > > run_command("r.support", raster="lsat7_2000_20", semantic_label="L8_2")
> > > run_command("g.copy", raster="lsat7_2000_30,lsat7_2000_30")
> > > run_command("r.support", raster="lsat7_2000_30", semantic_label="L8_3")
> > > run_command("i.group", group="L8_group",
> > > input="lsat7_2000_10,lsat7_2000_20,lsat7_2000_30")
> > > group_to_dict("L8_group") # doctest: +ELLIPSIS
> > > {"L8_1": "lsat7_2000_10", ... "L8_3": "lsat7_2000_30"}
> > > run_command("g.remove", flags="f", type="group", name="L8_group")
> > > run_command("g.remove", flags="f", type="raster",
> > > name="lsat7_2000_10,lsat7_2000_20,lsat7_2000_30")

:param str imagery_group_name: Name of the imagery group to process (or None)
:param str subgroup: Name of the imagery sub-group to process (or None)
:param str dict_keys: What to use as key for dictionary. It can be either
"semantic_labels" (default), "map_names" or "indices"
:param str dict_values: What to use as values for dictionary. It can be either
"map_names" (default), "semanic_labels", "indices" or
"metadata" (to return dictionaries with full map metadata)
:param bool fill_semantic_label: If maps in a group do not have a semantic
label, their index in the group is used
instead (default). Otherwise None / "none"
is used.
:param dict env: Environment to use when parsing the imagery group

:return: dictionary representing an imagery group with it's maps and their
semantic labels, row indices in the group, or metadata
:rtype: dict

#### grass.script.info

```python
info(msg, env=None)
```

Display an informational message using `g.message -i`

:param str msg: informational message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.legal_name

```python
legal_name(s)
```

Checks if the string contains only allowed characters.

This is the Python implementation of :func:`G_legal_filename()` function.

..note::

```
It is not clear when exactly use this function, but it might be
useful anyway for checking map names and column names.
```

#### grass.script.legalize_vector_name

```python
legalize_vector_name(name, fallback_prefix='x')
```

Make *name* usable for vectors, tables, and columns

The returned string is a name usable for vectors, tables, and columns,
i.e., it is a vector legal name which is a string containing only
lowercase and uppercase ASCII letters, digits, and underscores.

Invalid characters are replaced by underscores.
If the name starts with an invalid character, the name is prefixed with
*fallback_prefix*. This increases the length of the resulting name by the
length of the prefix.

The *fallback_prefix* can be empty which is useful when the *name* is later
used as a suffix for some other valid name.

ValueError is raised when provided *name* is empty or *fallback_prefix*
does not start with a valid character.

#### grass.script.list_grouped

```python
list_grouped(type, pattern=None, check_search_path=True, exclude=None, flag='', env=None)
```

List of elements grouped by mapsets.

Returns the output from running g.list, as a dictionary where the
keys are mapset names and the values are lists of maps in that
mapset. Example:

> > > list_grouped("vect", pattern="*roads*")["PERMANENT"]
> > > ['railroads', 'roadsmajor']

:param str type: element type (raster, vector, raster_3d, region, ...)
or list of elements
:param str pattern: pattern string
:param str check_search_path: True to add mapsets for the search path
with no found elements
:param str exclude: pattern string to exclude maps from the research
:param str flag: pattern type: 'r' (basic regexp), 'e' (extended regexp),
or '' (glob pattern)
:param env: environment

:return: directory of mapsets/elements

#### grass.script.list_pairs

```python
list_pairs(type, pattern=None, mapset=None, exclude=None, flag='', env=None)
```

List of elements as pairs

Returns the output from running g.list, as a list of
(name, mapset) pairs

:param str type: element type (raster, vector, raster_3d, region, ...)
:param str pattern: pattern string
:param str mapset: mapset name (if not given use search path)
:param str exclude: pattern string to exclude maps from the research
:param str flag: pattern type: 'r' (basic regexp), 'e' (extended regexp),
or '' (glob pattern)
:param env: environment

:return: list of elements

#### grass.script.list_strings

```python
list_strings(type, pattern=None, mapset=None, exclude=None, flag='', env=None)
```

List of elements as strings.

Returns the output from running g.list, as a list of qualified
names.

:param str type: element type (raster, vector, raster_3d, region, ...)
:param str pattern: pattern string
:param str mapset: mapset name (if not given use search path)
:param str exclude: pattern string to exclude maps from the research
:param str flag: pattern type: 'r' (basic regexp), 'e' (extended regexp),
or '' (glob pattern)
:param env: environment

:return: list of elements

#### grass.script.locn_is_latlong

```python
locn_is_latlong(env=None)
```

Tests if location is lat/long. Value is obtained
by checking the "g.region -pu" projection code.

:return: True for a lat/long region, False otherwise

#### grass.script.make_command

```python
make_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, errors=None, **options)
```

Return a list of strings suitable for use as the args parameter to
Popen() or call(). Example:

> > > make_command("g.message", flags="w", message="this is a warning")
> > > ['g.message', '-w', 'message=this is a warning']

:param str prog: GRASS module
:param str flags: flags to be used (given as a string)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param options: module's parameters

:return: list of arguments

#### grass.script.mapcalc

```python
mapcalc(exp, quiet=False, superquiet=False, verbose=False, overwrite=False, seed=None, env=None, **kwargs)
```

Interface to r.mapcalc.

:param str exp: expression
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param seed: an integer used to seed the random-number generator for the
rand() function, or 'auto' to generate a random seed
:param dict env: dictionary of environment variables for child process
:param kwargs:

#### grass.script.mapcalc3d

```python
mapcalc3d(exp, quiet=False, superquiet=False, verbose=False, overwrite=False, seed=None, env=None, **kwargs)
```

Interface to r3.mapcalc.

:param str exp: expression
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param seed: an integer used to seed the random-number generator for the
rand() function, or 'auto' to generate a random seed
:param dict env: dictionary of environment variables for child process
:param kwargs:

#### grass.script.mapcalc_start

```python
mapcalc_start(exp, quiet=False, superquiet=False, verbose=False, overwrite=False, seed=None, env=None, **kwargs)
```

Interface to r.mapcalc, doesn't wait for it to finish, returns Popen object.

> > > output = "newele"
> > > input = "elevation"
> > > expr1 = '"%s" = "%s" * 10' % (output, input)
> > > expr2 = "..." # etc.
> > >
> > > # launch the jobs:
> > >
> > > p1 = mapcalc_start(expr1)
> > > p2 = mapcalc_start(expr2)
> > >
> > > # wait for them to finish:
> > >
> > > p1.wait()
> > > 0
> > > p2.wait()
> > > 1
> > > run_command("g.remove", flags="f", type="raster", name=output)

:param str exp: expression
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param seed: an integer used to seed the random-number generator for the
rand() function, or 'auto' to generate a random seed
:param dict env: dictionary of environment variables for child process
:param kwargs:

:return: Popen object

#### grass.script.mapsets

```python
mapsets(search_path=False, env=None)
```

List available mapsets

:param bool search_path: True to list mapsets only in search path

:return: list of mapsets

#### grass.script.message

```python
message(msg, flag=None, env=None)
```

Display a message using `g.message`

:param str msg: message to be displayed
:param str flag: flags (given as string)
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.named_colors

```python
named_colors: dict[str, tuple[float, float, float]] = {'white': (1.0, 1.0, 1.0), 'black': (0.0, 0.0, 0.0), 'red': (1.0, 0.0, 0.0), 'green': (0.0, 1.0, 0.0), 'blue': (0.0, 0.0, 1.0), 'yellow': (1.0, 1.0, 0.0), 'magenta': (1.0, 0.0, 1.0), 'cyan': (0.0, 1.0, 1.0), 'aqua': (0.0, 0.75, 0.75), 'grey': (0.75, 0.75, 0.75), 'gray': (0.75, 0.75, 0.75), 'orange': (1.0, 0.5, 0.0), 'brown': (0.75, 0.5, 0.25), 'purple': (0.5, 0.0, 1.0), 'violet': (0.5, 0.0, 1.0), 'indigo': (0.0, 0.5, 1.0)}
```

#### grass.script.natural_sort

```python
natural_sort(items)
```

Returns sorted list using natural sort
(deprecated, use naturally_sorted)

#### grass.script.naturally_sorted

```python
naturally_sorted(items, key=None)
```

Returns sorted list using natural sort

#### grass.script.overwrite

```python
overwrite()
```

Return True if existing files may be overwritten

#### grass.script.parse_color

```python
parse_color(val, dflt=None)
```

Parses the string "val" as a GRASS colour, which can be either one of
the named colours or an R:G:B tuple e.g. 255:255:255. Returns an
(r,g,b) triple whose components are floating point values between 0
and 1. Example:

> > > parse_color("red")
> > > (1.0, 0.0, 0.0)
> > > parse_color("255:0:0")
> > > (1.0, 0.0, 0.0)

:param val: color value
:param dflt: default color value

:return: tuple RGB

#### grass.script.parse_command

```python
parse_command(*args, **kwargs)
```

Passes all arguments to read_command, then parses the output
by default with parse_key_val().

If the command has parameter <em>format</em> and is called with
<em>format=json</em>, the output will be parsed into a dictionary.
Similarly, with <em>format=csv</em> the output will be parsed into
a list of lists (CSV rows).

::

```
parse_command("v.db.select", ..., format="json")
```

Custom parsing function can be optionally given by <em>parse</em> parameter
including its arguments, e.g.

::

```
parse_command(..., parse=(gs.parse_key_val, {"sep": ":"}))
```

Parameter <em>delimiter</em> is deprecated.

:param args: list of unnamed arguments (see start_command() for details)
:param kwargs: list of named arguments (see start_command() for details)

:return: parsed module output

#### grass.script.parse_key_val

```python
parse_key_val(s, sep='=', dflt=None, val_type=None, vsep=None)
```

Parse a string into a dictionary, where entries are separated
by newlines and the key and value are separated by `sep` (default: `=`)

> > > parse_key_val("min=20\\nmax=50") == {"min": "20", "max": "50"}
> > > True
> > > parse_key_val("min=20\\nmax=50", val_type=float) == {"min": 20, "max": 50}
> > > True

:param s: string to be parsed
:param sep: key/value separator
:param dflt: default value to be used
:param val_type: value type (None for no cast)
:param vsep: vertical separator (default is Python 'universal newlines' approach)

:return: parsed input (dictionary of keys/values)

#### grass.script.parser

```python
parser()
```

Interface to g.parser, intended to be run from the top-level, e.g.:

::

```
if __name__ == "__main__":
    options, flags = grass.parser()
    main()
```

Thereafter, the global variables "options" and "flags" will be
dictionaries containing option/flag values, keyed by lower-case
option/flag names. The values in "options" are strings, those in
"flags" are Python booleans.

Overview table of parser standard options:
https://grass.osgeo.org/grass-devel/manuals/parser_standard_options.html

#### grass.script.percent

```python
percent(i, n, s, env=None)
```

Display a progress info message using `g.message -p`

::

```
message(_("Percent complete..."))
n = 100
for i in range(n):
    percent(i, n, 1)
percent(1, 1, 1)
```

:param int i: current item
:param int n: total number of items
:param int s: increment size
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.pipe_command

```python
pipe_command(*args, **kwargs)
```

Passes all arguments to start_command(), but also adds
"stdout = PIPE". Returns the Popen object.

> > > p = pipe_command("g.gisenv")
> > > print(p) # doctest: +ELLIPSIS
> > > \<....Popen object at 0x...>
> > > print(p.communicate()[0]) # doctest: +SKIP
> > > GISDBASE='/opt/grass-data';
> > > LOCATION_NAME='spearfish60';
> > > MAPSET='glynn';
> > > GUI='text';
> > > MONITOR='x0';

:param list args: list of unnamed arguments (see start_command() for details)
:param list kwargs: list of named arguments (see start_command() for details)

:return: Popen object

#### grass.script.popen_args_command

```python
popen_args_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, **kwargs)
```

Split tool name and parameters from Popen parameters

Does the splitting based on known Popen parameter names, and then does the
transformation from Python parameters to a list of command line arguments
for Popen.

#### grass.script.raster

Raster related functions to be used in Python scripts.

Usage:

::

```
from grass.script import raster as grass

grass.raster_history(map)
```

(C) 2008-2011 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements
.. sectionauthor:: Martin Landa \<landa.martin gmail.com>

**Classes:**

- [**MaskManager**](#grass.script.raster.MaskManager) – Context manager for setting and managing 2D raster mask.

**Functions:**

- [**mapcalc**](#grass.script.raster.mapcalc) – Interface to r.mapcalc.
- [**mapcalc_start**](#grass.script.raster.mapcalc_start) – Interface to r.mapcalc, doesn't wait for it to finish, returns Popen object.
- [**raster_history**](#grass.script.raster.raster_history) – Set the command history for a raster map to the command used to
- [**raster_info**](#grass.script.raster.raster_info) – Return information about a raster map (interface to
- [**raster_what**](#grass.script.raster.raster_what) – Interface to r.what

##### grass.script.raster.MaskManager

```python
MaskManager(mask_name=None, env=None, remove=None)
```

Context manager for setting and managing 2D raster mask.

The context manager makes it possible to have custom mask for the current process.
In the following example, we set the mask using _r.mask_ which creates a new
raster which represents the mask. The mask is deactivated at the end of the
context by the context manager and the raster is removed.

> > > with gs.MaskManager():
> > > ... gs.run_command("r.mask", raster="state_boundary")
> > > ... gs.parse_command("r.univar", map="elevation", format="json")

The _mask_name_ can be a name of an existing raster map and in that case,
that raster map is used directly as is. If the raster map does not exist,
the name will be used for the mask once it is created (with _r.mask_).

The following example uses an existing raster map directly as the mask.
The mask is disabled at the end of the context, but the raster map is not
removed.

> > > with gs.MaskManager(mask_name="state_boundary"):
> > > ... gs.parse_command("r.univar", map="elevation", format="json")

Note the difference between using the name of an existing raster map directly
and using *r.mask* to create a new mask. Both zeros and NULL values are used
to represent mask resulting in NULL cells, while *r.mask*
by default sets the mask in the way that only NULL values in the original raster
result in NULL cells.

If _mask_name_ is not provided, it generates a unique name using node (computer)
name, PID (current process ID), and unique ID (UUID).
In this case, the raster map representing the mask is removed if it exists at the
end of the context.
Optionally, the context manager can remove the raster map at the end of the context
when _remove_ is set to `True`.
The defaults for the removal of a mask raster are set to align with the two main use
cases which is creating the mask within the context and using an existing raster as
a mask.

Name of the raster mask is available as the _mask_name_ attribute and can be used to
directly create a mask (without the need to use *r.mask*). The following example
uses the attribute to create a mask directly by name. This is equivalent to the
basic case where a raster named `MASK` is created directly by the user in an
interactive session.

> > > with gs.MaskManager() as manager:
> > > ... gs.run_command(
> > > "r.mapcalc", expression=f"{manager.mask_name} = row() < col()"
> > > )
> > > ... gs.run_command(
> > > "r.mapcalc", expression=f"masked_elevation = elevation"
> > > )

In the background, this class manages the `GRASS_MASK` environment variable.
It modifies the current system environment or the one provided. It does not
create a copy internally. However, the modified environment is available as
the _env_ attribute for convenience and consistency with other managers
which provide this attribute.

The following code creates a copy of the global environment and lets the manager
modify it. The copy is then available as the _env_ attribute.

> > > with gs.MaskManager(env=os.environ.copy()) as manager:
> > > ... gs.run_command(
> > > ... "r.mapcalc",
> > > ... expression=f"{manager.mask_name} = row() < col()",
> > > ... env=manager.env,
> > > ... )
> > > ... gs.run_command(
> > > ... "r.mapcalc", expression=f"masked_elevation = elevation", env=manager.env
> > > ... )

**Attributes:**

- [**env**](#grass.script.raster.MaskManager.env) –
- [**mask_name**](#grass.script.raster.MaskManager.mask_name) –

Initializes the MaskManager.

:param mask_name: Name of the raster mask. Generated if not provided.
:param env: Environment to use. Defaults to modifying os.environ.
:param remove: If True, the raster mask will be removed when the context exits.
Defaults to True if the mask name is generated,
and False if a mask name is provided.

###### grass.script.raster.MaskManager.env

```python
env = env if env is not None else os.environ
```

###### grass.script.raster.MaskManager.mask_name

```python
mask_name = append_uuid(append_node_pid('mask'))
```

##### grass.script.raster.mapcalc

```python
mapcalc(exp, quiet=False, superquiet=False, verbose=False, overwrite=False, seed=None, env=None, **kwargs)
```

Interface to r.mapcalc.

:param str exp: expression
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param seed: an integer used to seed the random-number generator for the
rand() function, or 'auto' to generate a random seed
:param dict env: dictionary of environment variables for child process
:param kwargs:

##### grass.script.raster.mapcalc_start

```python
mapcalc_start(exp, quiet=False, superquiet=False, verbose=False, overwrite=False, seed=None, env=None, **kwargs)
```

Interface to r.mapcalc, doesn't wait for it to finish, returns Popen object.

> > > output = "newele"
> > > input = "elevation"
> > > expr1 = '"%s" = "%s" * 10' % (output, input)
> > > expr2 = "..." # etc.
> > >
> > > # launch the jobs:
> > >
> > > p1 = mapcalc_start(expr1)
> > > p2 = mapcalc_start(expr2)
> > >
> > > # wait for them to finish:
> > >
> > > p1.wait()
> > > 0
> > > p2.wait()
> > > 1
> > > run_command("g.remove", flags="f", type="raster", name=output)

:param str exp: expression
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param seed: an integer used to seed the random-number generator for the
rand() function, or 'auto' to generate a random seed
:param dict env: dictionary of environment variables for child process
:param kwargs:

:return: Popen object

##### grass.script.raster.raster_history

```python
raster_history(map, overwrite=False, env=None)
```

Set the command history for a raster map to the command used to
invoke the script (interface to `r.support`).

:param str map: map name
:param env: environment

:return: True on success
:return: False on failure

##### grass.script.raster.raster_info

```python
raster_info(map, env=None)
```

Return information about a raster map (interface to
`r.info -gre`). Example:

> > > raster_info("elevation") # doctest: +ELLIPSIS
> > > {'creator': '"helena"', 'cols': '1500' ... 'south': 215000.0}

:param str map: map name
:param env: environment

:return: parsed raster info

##### grass.script.raster.raster_what

```python
raster_what(map, coord, env=None, localized=False)
```

Interface to r.what

> > > raster_what("elevation", \[[640000, 228000]\])
> > > [{'elevation': {'color': '255:214:000', 'label': '', 'value': '102.479'}}]

:param str map: the map name
:param list coord: a list of list containing all the point that you want to query
:param env:

#### grass.script.raster3d

Raster3d related functions to be used in Python scripts.

Usage:

::

```
from grass.script import raster3d as grass

grass.raster3d_info(map)
```

(C) 2008-2016 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements
.. sectionauthor:: Martin Landa \<landa.martin gmail.com>
.. sectionauthor:: Soeren Gebbert \<soeren.gebbert gmail.com>

**Functions:**

- [**mapcalc3d**](#grass.script.raster3d.mapcalc3d) – Interface to r3.mapcalc.
- [**raster3d_info**](#grass.script.raster3d.raster3d_info) – Return information about a raster3d map (interface to `r3.info`).

##### grass.script.raster3d.mapcalc3d

```python
mapcalc3d(exp, quiet=False, superquiet=False, verbose=False, overwrite=False, seed=None, env=None, **kwargs)
```

Interface to r3.mapcalc.

:param str exp: expression
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param seed: an integer used to seed the random-number generator for the
rand() function, or 'auto' to generate a random seed
:param dict env: dictionary of environment variables for child process
:param kwargs:

##### grass.script.raster3d.raster3d_info

```python
raster3d_info(map, env=None)
```

Return information about a raster3d map (interface to `r3.info`).

Example:

> > > mapcalc3d("volume = row() + col() + depth()")
> > > raster3d_info("volume") # doctest: +ELLIPSIS
> > > {'vertical_units': '"units"', 'tbres': 1.0, ... 'south': 185000.0}
> > > run_command("g.remove", flags="f", type="raster_3d", name="volume")
> > > 0

:param str map: map name
:param env: environment

:return: parsed raster3d info

#### grass.script.raster3d_info

```python
raster3d_info(map, env=None)
```

Return information about a raster3d map (interface to `r3.info`).

Example:

> > > mapcalc3d("volume = row() + col() + depth()")
> > > raster3d_info("volume") # doctest: +ELLIPSIS
> > > {'vertical_units': '"units"', 'tbres': 1.0, ... 'south': 185000.0}
> > > run_command("g.remove", flags="f", type="raster_3d", name="volume")
> > > 0

:param str map: map name
:param env: environment

:return: parsed raster3d info

#### grass.script.raster_history

```python
raster_history(map, overwrite=False, env=None)
```

Set the command history for a raster map to the command used to
invoke the script (interface to `r.support`).

:param str map: map name
:param env: environment

:return: True on success
:return: False on failure

#### grass.script.raster_info

```python
raster_info(map, env=None)
```

Return information about a raster map (interface to
`r.info -gre`). Example:

> > > raster_info("elevation") # doctest: +ELLIPSIS
> > > {'creator': '"helena"', 'cols': '1500' ... 'south': 215000.0}

:param str map: map name
:param env: environment

:return: parsed raster info

#### grass.script.raster_what

```python
raster_what(map, coord, env=None, localized=False)
```

Interface to r.what

> > > raster_what("elevation", \[[640000, 228000]\])
> > > [{'elevation': {'color': '255:214:000', 'label': '', 'value': '102.479'}}]

:param str map: the map name
:param list coord: a list of list containing all the point that you want to query
:param env:

#### grass.script.read_command

```python
read_command(*args, **kwargs)
```

Passes all arguments to pipe_command, then waits for the process to
complete, returning its stdout (i.e. similar to shell `backticks`).

The behavior on error can be changed using *errors* parameter
which is passed to the :func:`handle_errors()` function.

:param list args: list of unnamed arguments (see start_command() for details)
:param list kwargs: list of named arguments (see start_command() for details)

:return: stdout

#### grass.script.region

```python
region(region3d=False, complete=False, env=None)
```

Returns the output from running "g.region -gu", as a
dictionary. Example:

:param bool region3d: True to get 3D region
:param bool complete:
:param env: dictionary with system environment variables (`os.environ` by default)

> > > curent_region = region()
> > >
> > > # obtain n, s, e and w values
> > >
> > > \[curent_region[key] for key in "nsew"\] # doctest: +ELLIPSIS
> > > [..., ..., ..., ...]
> > >
> > > # obtain ns and ew resolutions
> > >
> > > (curent_region["nsres"], curent_region["ewres"]) # doctest: +ELLIPSIS
> > > (..., ...)

:return: dictionary of region values

#### grass.script.region_env

```python
region_env(region3d=False, flags=None, env=None, **kwargs)
```

Returns region settings as a string which can used as
GRASS_REGION environmental variable.

If no 'kwargs' are given then the current region is used. Note
that this function doesn't modify the current region!

See also :func:`use_temp_region()` for alternative method how to define
temporary region used for raster-based computation.

:param region3d: True to get 3D region
:param flags: for example 'a'
:param env: dictionary with system environment variables (`os.environ` by default)
:param kwargs: g.region's parameters like 'raster', 'vector' or 'region'

::

```
os.environ["GRASS_REGION"] = grass.region_env(region="detail")
grass.mapcalc("map=1", overwrite=True)
os.environ.pop("GRASS_REGION")
```

:return: string with region values
:return: empty string on error

#### grass.script.run_command

```python
run_command(*args, **kwargs)
```

Execute a module synchronously

This function passes all arguments to `start_command()`,
then waits for the process to complete. It is similar to
`subprocess.check_call()`, but with the :func:`make_command()`
interface. By default, an exception is raised in case of a non-zero
return code by default.

> > > run_command("g.region", raster="elevation")

See :func:`start_command()` for details about parameters and usage.

The behavior on error can be changed using *errors* parameter
which is passed to the :func:`handle_errors()` function.

:param \*args: unnamed arguments passed to :func:`start_command()`
:param \*\*kwargs: named arguments passed to :func:`start_command()`
:param str errors: passed to :func:`handle_errors()`

.. versionchanged:: 8.0
Before 8.0, the function was returning 0 when no error occurred
for backward compatibility with code which was checking that
value. Now the function returns None, unless `errors="status"`
is specified.
.. versionchanged:: 7.2
In 7.0.0, this function was returning the error code. However,
it was rarely checked especially outside of the core code.
Additionally, :func:`read_command()` needed a mechanism to
report errors as it was used more and more in context which
required error handling, Thus, exceptions were introduced as a
more expected default behavior for Python programmers. The
change was backported to 7.0 series.

:raises: `CalledModuleError` when module returns non-zero return code

#### grass.script.sanitize_mapset_environment

```python
sanitize_mapset_environment(env)
```

Remove environmental variables relevant only
for a specific mapset. This should be called
when a copy of environment is used with a different mapset.

#### grass.script.separator

```python
separator(sep)
```

Returns separator from G_OPT_F_SEP appropriately converted
to character.

> > > separator("pipe")
> > > '|'
> > > separator("comma")
> > > ','

If the string does not match any of the separator keywords,
it is returned as is:

> > > separator(", ")
> > > ', '

:param str separator: character or separator keyword

:return: separator character

#### grass.script.set_capture_stderr

```python
set_capture_stderr(capture=True)
```

Enable capturing standard error output of modules and print it.

By default, standard error output (stderr) of child processes shows
in the same place as output of the parent process. This may not
always be the same place as `sys.stderr` is written.
After calling this function, functions in the `grass.script`
package will capture the stderr of child processes and pass it
to `sys.stderr` if there is an error.

.. note::

```
This is advantageous for interactive shells such as the one in GUI
and interactive notebooks such as Jupyter Notebook.
```

The capturing can be applied only in certain cases, for example
in case of run_command() it is applied because run_command() nor
its callers do not handle the streams, however feed_command()
cannot do capturing because its callers handle the streams.

The previous state is returned. Passing `False` disables the
capturing.

.. versionadded:: 7.4

#### grass.script.set_path

```python
set_path(modulename, dirname=None, path='.')
```

Set sys.path looking in the local directory GRASS directories.

:param modulename: string with the name of the GRASS module
:param dirname: string with the directory name containing the python
libraries, default None
:param path: string with the path to reach the dirname locally.

## Example

"set_path" example working locally with the source code of a module
(r.green) calling the function with all the parameters. Below it is
reported the directory structure on the r.green module.

::

```
grass_prompt> pwd
~/Download/r.green/r.green.hydro/r.green.hydro.financial

grass_prompt> tree ../../../r.green
../../../r.green
|-- ...
|-- libgreen
|   |-- pyfile1.py
|   +-- pyfile2.py
+-- r.green.hydro
   |-- Makefile
   |-- libhydro
   |   |-- pyfile1.py
   |   +-- pyfile2.py
   |-- r.green.hydro.*
   +-- r.green.hydro.financial
       |-- Makefile
       |-- ...
       +-- r.green.hydro.financial.py

21 directories, 125 files
```

in the source code the function is called with the following parameters: ::

```
set_path("r.green", "libhydro", "..")
set_path("r.green", "libgreen", os.path.join("..", ".."))
```

when we are executing the module: r.green.hydro.financial locally from
the command line: ::

```
grass_prompt> python r.green.hydro.financial.py --ui
```

In this way we are executing the local code even if the module was already
installed as grass-addons and it is available in GRASS standards path.

The function is checking if the dirname is provided and if the
directory exists and it is available using the path
provided as third parameter, if yes add the path to sys.path to be
importable, otherwise it will check on GRASS GIS standard paths.

#### grass.script.set_raise_on_error

```python
set_raise_on_error(raise_exp=True)
```

Define behaviour on fatal error (fatal() called)

:param bool raise_exp: True to raise ScriptError instead of calling
sys.exit(1) in fatal()

:return: current status

#### grass.script.setup

Setup, initialization, and clean-up functions

Functions can be used in Python scripts to setup a GRASS environment
and session without using grassXY.

Usage::

```
import os
import sys
import subprocess

# define GRASS Database
# add your path to grassdata (GRASS GIS database) directory
gisdb = "~/grassdata"
# the following path is the default path on MS Windows
# gisdb = "~/Documents/grassdata"

# specify (existing) Location and Mapset
location = "nc_spm_08"
mapset = "user1"

# path to the GRASS GIS launch script
# we assume that the GRASS GIS start script is available and on PATH
# query GRASS itself for its GISBASE
# (with fixes for specific platforms)
# needs to be edited by the user
executable = "grass"
if sys.platform.startswith("win"):
    # MS Windows
    executable = r"C:\OSGeo4W\bin\grass.bat"
    # uncomment when using standalone WinGRASS installer
    # executable = r'C:\Program Files (x86)\GRASS GIS <version>\grass.bat'
    # this can be skipped if GRASS executable is added to PATH
elif sys.platform == "darwin":
    # Mac OS X
    version = "@GRASS_VERSION_MAJOR@.@GRASS_VERSION_MINOR@"
    executable = f"/Applications/GRASS-{version}.app/Contents/Resources/bin/grass"

# query GRASS GIS itself for its Python package path
grass_cmd = [executable, "--config", "python_path"]
process = subprocess.run(grass_cmd, check=True, text=True, stdout=subprocess.PIPE)

# define GRASS-Python environment
sys.path.append(process.stdout.strip())

# import (some) GRASS Python bindings
import grass.script as gs

# launch session
session = gs.setup.init(gisdb, location, mapset)

# example calls
gs.message("Current GRASS GIS 8 environment:")
print(gs.gisenv())

gs.message("Available raster maps:")
for rast in gs.list_strings(type="raster"):
    print(rast)

gs.message("Available vector maps:")
for vect in gs.list_strings(type="vector"):
    print(vect)

# clean up at the end
session.finish()
```

(C) 2010-2025 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

@author Martin Landa \<landa.martin gmail.com>
@author Vaclav Petras <wenzeslaus gmail.com>
@author Markus Metz

**Classes:**

- [**SessionHandle**](#grass.script.setup.SessionHandle) – Object used to manage GRASS sessions.

**Functions:**

- [**call**](#grass.script.setup.call) – Wrapper for subprocess.call to deal with platform-specific issues
- [**clean_default_db**](#grass.script.setup.clean_default_db) – Clean (vacuum) the default db if it is SQLite
- [**clean_temp**](#grass.script.setup.clean_temp) – Clean mapset temporary directory
- [**finish**](#grass.script.setup.finish) – Terminate the GRASS session and clean up
- [**get_install_path**](#grass.script.setup.get_install_path) – Get path to GRASS installation usable for setup of environmental variables.
- [**init**](#grass.script.setup.init) – Initialize system variables to run GRASS modules
- [**set_gui_path**](#grass.script.setup.set_gui_path) – Insert wxPython GRASS path to sys.path.
- [**setup_runtime_env**](#grass.script.setup.setup_runtime_env) – Setup the runtime environment.
- [**write_gisrc**](#grass.script.setup.write_gisrc) – Write the `gisrc` file and return its path.

**Attributes:**

- [**MACOS**](#grass.script.setup.MACOS) –
- [**VERSION_MAJOR**](#grass.script.setup.VERSION_MAJOR) –
- [**VERSION_MINOR**](#grass.script.setup.VERSION_MINOR) –
- [**WINDOWS**](#grass.script.setup.WINDOWS) –

##### grass.script.setup.MACOS

```python
MACOS = sys.platform.startswith('darwin')
```

##### grass.script.setup.SessionHandle

```python
SessionHandle(*, env, active=True, locked=False)
```

Object used to manage GRASS sessions.

Do not create objects of this class directly. Use the *init* function
to get a session object.

Basic usage::

```
# ... setup sys.path before import as needed

import grass.script as gs

session = gs.setup.init("~/grassdata/nc_spm_08/user1")

# ... use GRASS modules here

# end the session
session.finish()
```

Context manager usage::

```
# ... setup sys.path before import as needed

import grass.script as gs

with gs.setup.init("~/grassdata/nc_spm_08/user1"):
    # ... use GRASS modules here
# session ends automatically here
```

The example above is modifying the global, process environment (`os.environ`).
If you don't want to modify the global environment, use the _env_ parameter
for the _init_ function to modify the provided environment instead.
This environment is then available as an attribute of the session object.
The attribute then needs to be passed to all calls of GRASS
tools and functions that wrap them.
Context manager usage with custom environment::

```
# ... setup sys.path before import as needed

import grass.script as gs

with gs.setup.init("~/grassdata/nc_spm_08/user1", env=os.environ.copy()):
    # ... use GRASS modules here with env parameter
    gs.run_command("g.region", flags="p", env=session.env)
# session ends automatically here, global environment was never modified
```

**Functions:**

- [**finish**](#grass.script.setup.SessionHandle.finish) – Finish the session.

**Attributes:**

- [**active**](#grass.script.setup.SessionHandle.active) – True if session is active (not finished)
- [**env**](#grass.script.setup.SessionHandle.env) –

###### grass.script.setup.SessionHandle.active

```python
active
```

True if session is active (not finished)

###### grass.script.setup.SessionHandle.env

```python
env
```

###### grass.script.setup.SessionHandle.finish

```python
finish()
```

Finish the session.

If not used as a context manager, call explicitly to clean and close the mapset
and finish the session. No GRASS modules can be called afterwards.

##### grass.script.setup.VERSION_MAJOR

```python
VERSION_MAJOR = '@GRASS_VERSION_MAJOR@'
```

##### grass.script.setup.VERSION_MINOR

```python
VERSION_MINOR = '@GRASS_VERSION_MINOR@'
```

##### grass.script.setup.WINDOWS

```python
WINDOWS = sys.platform.startswith('win')
```

##### grass.script.setup.call

```python
call(cmd, **kwargs)
```

Wrapper for subprocess.call to deal with platform-specific issues

##### grass.script.setup.clean_default_db

```python
clean_default_db(*, modified_after=None, env=None, gis_env=None)
```

Clean (vacuum) the default db if it is SQLite

When *modified_after* is set, database is cleaned only when it was modified
since the *modified_after* time.

##### grass.script.setup.clean_temp

```python
clean_temp(env=None)
```

Clean mapset temporary directory

##### grass.script.setup.finish

```python
finish(*, env=None, start_time=None, unlock=False)
```

Terminate the GRASS session and clean up

GRASS commands can no longer be used after this function has been
called

Basic usage::
import grass.script as gs

```
gs.setup.finish()
```

The function is not completely symmetrical with :func:`init` because it only
closes the mapset, but doesn't undo the runtime environment setup.

When *start_time* is set, it might be used to determine cleaning procedures.
Currently, it is used to do SQLite database vacuum only when database was modified
since the session started.

The function does not check whether the mapset is locked or not, but *unlock* can be
provided to unlock the mapset.

##### grass.script.setup.get_install_path

```python
get_install_path(path=None)
```

Get path to GRASS installation usable for setup of environmental variables.

The function tries to determine path tp GRASS GIS installation so that the
returned path can be used for setup of environmental variable for GRASS runtime.
If the search fails, None is returned.

By default, the resulting path is derived relatively from the location of the
Python package (specifically this module) in the file system. This derived path
is returned only if it has subdirectories called `bin` and `lib`.
If the parameter or certain environmental variables are set, the following
attempts are made to find the path.

If *path* is provided and it is an existing executable, the executable is queried
for the path. Otherwise, provided *path* is returned as is.

If *path* is not provided, the GISBASE environmental variable is used as the path
if it exists. If GRASSBIN environmental variable exists and it is an existing
executable, the executable is queried for the path.

If *path* is not provided and no relevant environmental variables are set, the
default relative path search is performed.
If that fails and executable called `grass` exists, it is queried for the path.
None is returned if all the attempts failed.

If an existing executable is called as a subprocess is called during the search
and it fails, the CalledProcessError exception is propagated from the subprocess
call.

##### grass.script.setup.init

```python
init(path, location=None, mapset=None, *, grass_path=None, env=None, lock=False, timeout=0, force_unlock=False)
```

Initialize system variables to run GRASS modules

This function is for running GRASS GIS without starting it with the
standard main executable grass. No GRASS modules shall be called before
call of this function but any module or user script can be called
afterwards because a GRASS session has been set up. GRASS Python
libraries are usable as well in general but the ones using C
libraries through `ctypes` are not (which is caused by library
path not being updated for the current process which is a common
operating system limitation).

When the path or specified mapset does not exist, ValueError is raised.

The :func:`get_install_path` function is used to determine where
the rest of GRASS files is installed. The *grass_path* parameter is
passed to it if provided. If the path cannot be determined,
ValueError is raised. Exceptions from the underlying function are propagated.

To create a GRASS session a session file (aka gisrc file) is created.
The session object returned by this function will take care of deleting it
as long as the object is used as a context manager or the *finish* method
of the object is called explicitly. Using methods of the session object is
preferred over calling the function :func:`finish`.

Basic usage::

```
# ... setup GISBASE and sys.path before import
import grass.script as gs

session = gs.setup.init(
    "~/grassdata/nc_spm_08/user1",
    grass_path="/usr/lib/grass",
)
# ... use GRASS modules here
# end the session
session.finish()
```

The returned object is a context manager, so the `with` statement can be used to
ensure that the session is finished (closed) at the end::

```
# ... setup sys.path before import
import grass.script as gs
with gs.setup.init("~/grassdata/nc_spm_08/user1")
    # ... use GRASS modules here
```

A mapset can be locked which will prevent other session from locking it. A timeout can be
specified to allow concurrent processes to wait for the lock to be released::

```
with gs.setup.init("~/grassdata/nc_spm_08/user1", lock=True, timeout=30):
    # ... use GRASS tools here
```

:param path: path to GRASS database
:param location: location name
:param mapset: mapset within given location (default: 'PERMANENT')
:param grass_path: path to GRASS installation or executable

:returns: reference to a session handle object which is a context manager

##### grass.script.setup.set_gui_path

```python
set_gui_path()
```

Insert wxPython GRASS path to sys.path.

##### grass.script.setup.setup_runtime_env

```python
setup_runtime_env(gisbase=None, *, env=None)
```

Setup the runtime environment.

Modifies environment so that GRASS modules can run. It does not setup a session,
but only the system environment to execute commands.

Modifies the environment provided with _env_. If _env_ is not
provided, modifies the global environment (os.environ). Pass a copy of the
environment if you don't want the source environment modified.

If _gisbase_ is not provided, a heuristic is used to find the path to GRASS
installation (see the :func:`get_install_path` function for details).

##### grass.script.setup.write_gisrc

```python
write_gisrc(dbase, location, mapset)
```

Write the `gisrc` file and return its path.

#### grass.script.split

```python
split(s)
```

Same shlex.split() func on all OS platforms

We don't use parameter posix=True on the OS MS Windows due to incorrectly
splitting command line parameters:

e.g. d.vect where="cat < 10"

is split incorrectly as follows:

'where="cat', '\<', '10"'

Should be:

'where=cat < 10'

:param str s: cmd string

return list: cmd list

#### grass.script.start_command

```python
start_command(prog, flags='', overwrite=False, quiet=False, verbose=False, superquiet=False, **kwargs)
```

Returns a Popen object with the command created by make_command.
Accepts any of the arguments which Popen() accepts apart from "args"
and "shell".

> > > p = start_command("g.gisenv", stdout=subprocess.PIPE)
> > > print(p) # doctest: +ELLIPSIS
> > > \<...Popen object at 0x...>
> > > print(p.communicate()[0]) # doctest: +SKIP
> > > GISDBASE='/opt/grass-data';
> > > LOCATION_NAME='spearfish60';
> > > MAPSET='glynn';
> > > GUI='text';
> > > MONITOR='x0';

If the module parameter is the same as Python keyword, add
underscore at the end of the parameter. For example, use
`lambda_=1.6` instead of `lambda=1.6`.

:param str prog: GRASS module
:param str flags: flags to be used (given as a string)
:param bool overwrite: True to enable overwriting the output (<tt>--o</tt>)
:param bool quiet: True to run quietly (<tt>--q</tt>)
:param bool superquiet: True to run extra quietly (<tt>--qq</tt>)
:param bool verbose: True to run verbosely (<tt>--v</tt>)
:param kwargs: module's parameters

:return: Popen object

#### grass.script.task

Get interface description of GRASS commands

Based on gui/wxpython/gui_modules/menuform.py

Usage:

::

```
from grass.script import task as gtask

gtask.command_info("r.info")
```

(C) 2011 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Martin Landa \<landa.martin gmail.com>

**Classes:**

- [**grassTask**](#grass.script.task.grassTask) – This class holds the structures needed for filling by the parser
- [**processTask**](#grass.script.task.processTask) – A ElementTree handler for the --interface-description output,

**Functions:**

- [**cmdlist_to_tuple**](#grass.script.task.cmdlist_to_tuple) – Convert command list to tuple for run_command() and others
- [**cmdstring_to_tuple**](#grass.script.task.cmdstring_to_tuple) – Convert command string to tuple for run_command() and others
- [**cmdtuple_to_list**](#grass.script.task.cmdtuple_to_list) – Convert command tuple to list.
- [**command_info**](#grass.script.task.command_info) – Returns meta information for any GRASS command as dictionary
- [**convert_xml_to_utf8**](#grass.script.task.convert_xml_to_utf8) –
- [**get_interface_description**](#grass.script.task.get_interface_description) – Returns the XML description for the GRASS cmd (force text encoding to
- [**parse_interface**](#grass.script.task.parse_interface) – Parse interface of given GRASS module

**Attributes:**

- [**ETREE_EXCEPTIONS**](#grass.script.task.ETREE_EXCEPTIONS) –

##### grass.script.task.ETREE_EXCEPTIONS

```python
ETREE_EXCEPTIONS = (ET.ParseError, expat.ExpatError)
```

##### grass.script.task.cmdlist_to_tuple

```python
cmdlist_to_tuple(cmd)
```

Convert command list to tuple for run_command() and others

:param list cmd: GRASS command to be converted

:return: command as tuple

##### grass.script.task.cmdstring_to_tuple

```python
cmdstring_to_tuple(cmd)
```

Convert command string to tuple for run_command() and others

:param str cmd: command to be converted

:return: command as tuple

##### grass.script.task.cmdtuple_to_list

```python
cmdtuple_to_list(cmd)
```

Convert command tuple to list.

:param tuple cmd: GRASS command to be converted

:return: command in list

##### grass.script.task.command_info

```python
command_info(cmd)
```

Returns meta information for any GRASS command as dictionary
with entries for description, keywords, usage, flags, and
parameters, e.g.

> > > command_info("g.tempfile") # doctest: +NORMALIZE_WHITESPACE
> > > {'keywords': ['general', 'support'], 'params': \[{'gisprompt': False,
> > > 'multiple': False, 'name': 'pid', 'guidependency': '', 'default': '',
> > > 'age': None, 'required': True, 'value': '', 'label': '', 'guisection': '',
> > > 'key_desc': [], 'values': [], 'values_desc': [], 'prompt': None,
> > > 'hidden': False, 'element': None, 'type': 'integer', 'description':
> > > 'Process id to use when naming the tempfile'}\], 'flags': \[{'description':
> > > "Dry run - don't create a file, just prints it's file name", 'value':
> > > False, 'label': '', 'guisection': '', 'suppress_required': False,
> > > 'hidden': False, 'name': 'd'}, {'description': 'Print usage summary',
> > > 'value': False, 'label': '', 'guisection': '', 'suppress_required': False,
> > > 'hidden': False, 'name': 'help'}, {'description': 'Verbose module output',
> > > 'value': False, 'label': '', 'guisection': '', 'suppress_required': False,
> > > 'hidden': False, 'name': 'verbose'}, {'description': 'Quiet module output',
> > > 'value': False, 'label': '', 'guisection': '', 'suppress_required': False,
> > > 'hidden': False, 'name': 'quiet'}\], 'description': "Creates a temporary
> > > file and prints it's file name.", 'usage': 'g.tempfile pid=integer [--help]
> > > [--verbose] [--quiet]'}

> > > command_info("v.buffer")
> > > ['vector', 'geometry', 'buffer']

:param str cmd: the command to query

##### grass.script.task.convert_xml_to_utf8

```python
convert_xml_to_utf8(xml_text)
```

##### grass.script.task.get_interface_description

```python
get_interface_description(cmd)
```

Returns the XML description for the GRASS cmd (force text encoding to
"utf-8").

The DTD must be located in $GISBASE/gui/xml/grass-interface.dtd,
otherwise the parser will not succeed.

:param cmd: command (name of GRASS module)

##### grass.script.task.grassTask

```python
grassTask(path=None, blackList=None)
```

This class holds the structures needed for filling by the parser

Parameter blackList is a dictionary with fixed structure, eg.

::

```
blackList = {
    "items": {"d.legend": {"flags": ["m"], "params": []}},
    "enabled": True,
}
```

:param str path: full path
:param blackList: hide some options in the GUI (dictionary)

**Functions:**

- [**define_first**](#grass.script.task.grassTask.define_first) – Define first parameter
- [**get_cmd**](#grass.script.task.grassTask.get_cmd) – Produce an array of command name and arguments for feeding
- [**get_cmd_error**](#grass.script.task.grassTask.get_cmd_error) – Get error string produced by get_cmd(ignoreErrors = False)
- [**get_description**](#grass.script.task.grassTask.get_description) – Get module's description
- [**get_error_msg**](#grass.script.task.grassTask.get_error_msg) – Get error message ('' for no error)
- [**get_flag**](#grass.script.task.grassTask.get_flag) – Find and return a flag by name
- [**get_keywords**](#grass.script.task.grassTask.get_keywords) – Get module's keywords
- [**get_list_flags**](#grass.script.task.grassTask.get_list_flags) – Get list of flags
- [**get_list_params**](#grass.script.task.grassTask.get_list_params) – Get list of parameters
- [**get_name**](#grass.script.task.grassTask.get_name) – Get task name
- [**get_options**](#grass.script.task.grassTask.get_options) – Get options
- [**get_param**](#grass.script.task.grassTask.get_param) – Find and return a param by name
- [**has_required**](#grass.script.task.grassTask.has_required) – Check if command has at least one required parameter
- [**set_flag**](#grass.script.task.grassTask.set_flag) – Enable / disable flag.
- [**set_options**](#grass.script.task.grassTask.set_options) – Set flags and parameters
- [**set_param**](#grass.script.task.grassTask.set_param) – Set param value/values.

**Attributes:**

- [**blackList**](#grass.script.task.grassTask.blackList) –
- [**description**](#grass.script.task.grassTask.description) –
- [**errorMsg**](#grass.script.task.grassTask.errorMsg) –
- [**firstParam**](#grass.script.task.grassTask.firstParam) –
- [**flags**](#grass.script.task.grassTask.flags) –
- [**keywords**](#grass.script.task.grassTask.keywords) –
- [**label**](#grass.script.task.grassTask.label) –
- [**name**](#grass.script.task.grassTask.name) –
- [**params**](#grass.script.task.grassTask.params) –
- [**path**](#grass.script.task.grassTask.path) –

###### grass.script.task.grassTask.blackList

```python
blackList = blackList
```

###### grass.script.task.grassTask.define_first

```python
define_first()
```

Define first parameter

:return: name of first parameter

###### grass.script.task.grassTask.description

```python
description = ''
```

###### grass.script.task.grassTask.errorMsg

```python
errorMsg = ''
```

###### grass.script.task.grassTask.firstParam

```python
firstParam = None
```

###### grass.script.task.grassTask.flags

```python
flags = []
```

###### grass.script.task.grassTask.get_cmd

```python
get_cmd(ignoreErrors=False, ignoreRequired=False, ignoreDefault=True)
```

Produce an array of command name and arguments for feeding
into some execve-like command processor.

:param bool ignoreErrors: True to return whatever has been built so
far, even though it would not be a correct
command for GRASS
:param bool ignoreRequired: True to ignore required flags, otherwise
'@\<required@>' is shown
:param bool ignoreDefault: True to ignore parameters with default values

###### grass.script.task.grassTask.get_cmd_error

```python
get_cmd_error()
```

Get error string produced by get_cmd(ignoreErrors = False)

:return: list of errors

###### grass.script.task.grassTask.get_description

```python
get_description(full=True)
```

Get module's description

:param bool full: True for label + desc

###### grass.script.task.grassTask.get_error_msg

```python
get_error_msg()
```

Get error message ('' for no error)

###### grass.script.task.grassTask.get_flag

```python
get_flag(aFlag)
```

Find and return a flag by name

Raises ValueError when the flag is not found.

:param str aFlag: name of the flag

###### grass.script.task.grassTask.get_keywords

```python
get_keywords()
```

Get module's keywords

###### grass.script.task.grassTask.get_list_flags

```python
get_list_flags(element='name')
```

Get list of flags

:param str element: element name

###### grass.script.task.grassTask.get_list_params

```python
get_list_params(element='name')
```

Get list of parameters

:param str element: element name

###### grass.script.task.grassTask.get_name

```python
get_name()
```

Get task name

###### grass.script.task.grassTask.get_options

```python
get_options()
```

Get options

###### grass.script.task.grassTask.get_param

```python
get_param(value, element='name', raiseError=True)
```

Find and return a param by name

:param value: param's value
:param str element: element name
:param bool raiseError: True for raise on error

###### grass.script.task.grassTask.has_required

```python
has_required()
```

Check if command has at least one required parameter

###### grass.script.task.grassTask.keywords

```python
keywords = []
```

###### grass.script.task.grassTask.label

```python
label = ''
```

###### grass.script.task.grassTask.name

```python
name = _('unknown')
```

###### grass.script.task.grassTask.params

```python
params = []
```

###### grass.script.task.grassTask.path

```python
path = path
```

###### grass.script.task.grassTask.set_flag

```python
set_flag(aFlag, aValue, element='value')
```

Enable / disable flag.

###### grass.script.task.grassTask.set_options

```python
set_options(opts)
```

Set flags and parameters

:param opts list of flags and parameters

###### grass.script.task.grassTask.set_param

```python
set_param(aParam, aValue, element='value')
```

Set param value/values.

##### grass.script.task.parse_interface

```python
parse_interface(name, parser=processTask, blackList=None)
```

Parse interface of given GRASS module

The *name* is either GRASS module name (of a module on path) or
a full or relative path to an executable.

:param str name: name of GRASS module to be parsed
:param parser:
:param blackList:

##### grass.script.task.processTask

```python
processTask(tree, task=None, blackList=None)
```

A ElementTree handler for the --interface-description output,
as defined in grass-interface.dtd. Extend or modify this and the
DTD if the XML output of GRASS' parser is extended or modified.

:param tree: root tree node
:param task: grassTask instance or None
:param blackList: list of flags/params to hide

:return: grassTask instance

**Functions:**

- [**get_task**](#grass.script.task.processTask.get_task) – Get grassTask instance

**Attributes:**

- [**root**](#grass.script.task.processTask.root) –
- [**task**](#grass.script.task.processTask.task) –

###### grass.script.task.processTask.get_task

```python
get_task()
```

Get grassTask instance

###### grass.script.task.processTask.root

```python
root = tree
```

###### grass.script.task.processTask.task

```python
task = task
```

#### grass.script.tempdir

```python
tempdir(env=None)
```

Returns the name of a temporary dir, created with g.tempfile.

#### grass.script.tempfile

```python
tempfile(create=True, env=None)
```

Returns the name of a temporary file, created with g.tempfile.

:param bool create: True to create a file
:param env: environment

:return: path to a tmp file

#### grass.script.tempname

```python
tempname(length, lowercase=False)
```

Generate a GRASS and SQL compliant random name starting with tmp\_
followed by a random part of length "length"

:param int length: length of the random part of the name to generate
:param bool lowercase: use only lowercase characters to generate name
:returns: String with a random name of length "length" starting with a letter
:rtype: str

:Example:

> > > tempname(12)
> > > 'tmp_MxMa1kAS13s9'

.. seealso:: functions :func:`append_uuid()`, :func:`append_random()`

#### grass.script.text_to_string

```python
text_to_string(text, encoding=None)
```

Convert text to str. Useful when passing text into environments,
in Python 2 it needs to be bytes on Windows, in Python 3 in needs unicode.

#### grass.script.try_remove

```python
try_remove(path)
```

Attempt to remove a file; no exception is generated if the
attempt fails.

:param str path: path to file to remove

#### grass.script.try_rmdir

```python
try_rmdir(path)
```

Attempt to remove a directory; no exception is generated if the
attempt fails.

:param str path: path to directory to remove

#### grass.script.use_temp_region

```python
use_temp_region()
```

Copies the current region to a temporary region with "g.region save=",
then sets WIND_OVERRIDE to refer to that region. Installs an atexit
handler to delete the temporary region upon termination.

#### grass.script.utils

Useful functions to be used in Python scripts.

Usage:

::

```
from grass.script import utils as gutils
```

(C) 2014-2016 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements
.. sectionauthor:: Martin Landa \<landa.martin gmail.com>
.. sectionauthor:: Anna Petrasova <kratochanna gmail.com>

**Classes:**

- [**KeyValue**](#grass.script.utils.KeyValue) – A general-purpose key-value store.

**Functions:**

- [**append_node_pid**](#grass.script.utils.append_node_pid) – Add node name and PID to a name (string)
- [**append_random**](#grass.script.utils.append_random) – Add a random part to of a specified length to a name (string)
- [**append_uuid**](#grass.script.utils.append_uuid) – Add UUID4 to a name (string)
- [**basename**](#grass.script.utils.basename) – Remove leading directory components and an optional extension
- [**clock**](#grass.script.utils.clock) – Return time counter to measure performance for chunks of code.
- [**decode**](#grass.script.utils.decode) – Decode bytes with default locale and return (unicode) string
- [**diff_files**](#grass.script.utils.diff_files) – Diffs two text files and returns difference.
- [**encode**](#grass.script.utils.encode) – Encode string with default locale and return bytes with that encoding
- [**float_or_dms**](#grass.script.utils.float_or_dms) – Convert DMS to float.
- [**get_lib_path**](#grass.script.utils.get_lib_path) – Return the path of the libname contained in the module.
- [**get_num_suffix**](#grass.script.utils.get_num_suffix) – Returns formatted number with number of padding zeros
- [**legalize_vector_name**](#grass.script.utils.legalize_vector_name) – Make *name* usable for vectors, tables, and columns
- [**natural_sort**](#grass.script.utils.natural_sort) – Returns sorted list using natural sort
- [**naturally_sort**](#grass.script.utils.naturally_sort) – Sorts lists using natural sort
- [**naturally_sorted**](#grass.script.utils.naturally_sorted) – Returns sorted list using natural sort
- [**parse_key_val**](#grass.script.utils.parse_key_val) – Parse a string into a dictionary, where entries are separated
- [**separator**](#grass.script.utils.separator) – Returns separator from G_OPT_F_SEP appropriately converted
- [**set_path**](#grass.script.utils.set_path) – Set sys.path looking in the local directory GRASS directories.
- [**split**](#grass.script.utils.split) – Same shlex.split() func on all OS platforms
- [**text_to_string**](#grass.script.utils.text_to_string) – Convert text to str. Useful when passing text into environments,
- [**try_remove**](#grass.script.utils.try_remove) – Attempt to remove a file; no exception is generated if the
- [**try_rmdir**](#grass.script.utils.try_rmdir) – Attempt to remove a directory; no exception is generated if the

**Attributes:**

- [**T**](#grass.script.utils.T) –
- [**VT**](#grass.script.utils.VT) –

##### grass.script.utils.KeyValue

Bases: <code>[dict](#dict)\[[str](#str), [VT](#grass.script.utils.VT)\]</code>

A general-purpose key-value store.

KeyValue is a subclass of dict, but also allows entries to be read and
written using attribute syntax. Example:

> > > reg = KeyValue()
> > > reg["north"] = 489
> > > reg.north
> > > 489
> > > reg.south = 205
> > > reg["south"]
> > > 205

The keys of KeyValue are strings. To use other key types, use other mapping types.
To use the attribute syntax, the keys must be valid Python attribute names.

##### grass.script.utils.T

```python
T = TypeVar('T')
```

##### grass.script.utils.VT

```python
VT = TypeVar('VT')
```

##### grass.script.utils.append_node_pid

```python
append_node_pid(name)
```

Add node name and PID to a name (string)

For the result to be unique, the name needs to be unique within a process.
Given that, the result will be unique enough for use in temporary maps
and other elements on single machine or an HPC cluster.

The returned string is a name usable for vectors, tables, and columns
(vector legal name) as long as provided argument *name* is.

> > > append_node_pid("tmp_raster_1")

..note::

```
Before you use this function for creating temporary files (i.e., normal
files on disk, not maps and other mapset elements), see functions
designed for it in the GRASS GIS or standard Python library. These
take care of collisions already on different levels.
```

##### grass.script.utils.append_random

```python
append_random(name, suffix_length=None, total_length=None)
```

Add a random part to of a specified length to a name (string)

> > > append_random("tmp", 8)
> > > append_random("tmp", total_length=16)

..note::

```
Note that this will be influenced by the random seed set for the Python
random package.
```

..note::

```
See the note about creating temporary files in the
:func:`append_node_pid()` description.
```

##### grass.script.utils.append_uuid

```python
append_uuid(name)
```

Add UUID4 to a name (string)

To generate a name of an temporary mapset element which is unique in a
system, use :func:`append_node_pid()` in a combination with a name unique
within your process.

To avoid collisions, never shorten the name obtained from this function.
A shortened UUID does not have the collision guarantees the full UUID has.

For a random name of a given shorter size, see :func:`append_random()`.

> > > append_uuid("tmp")

..note::

```
See the note about creating temporary files in the
:func:`append_node_pid()` description.
```

##### grass.script.utils.basename

```python
basename(path, ext=None)
```

Remove leading directory components and an optional extension
from the specified path

:param str path: path
:param str ext: extension

##### grass.script.utils.clock

```python
clock()
```

Return time counter to measure performance for chunks of code.
Should be used only as difference between the calls.

##### grass.script.utils.decode

```python
decode(bytes_, encoding=None)
```

Decode bytes with default locale and return (unicode) string

No-op if parameter is not bytes (assumed unicode string).

:param bytes bytes\_: the bytes to decode
:param encoding: encoding to be used, default value is None

## Example

> > > decode(b"SÃ¼dtirol")
> > > u'Südtirol'
> > > decode("Südtirol")
> > > u'Südtirol'
> > > decode(1234)
> > > u'1234'

##### grass.script.utils.diff_files

```python
diff_files(filename_a, filename_b)
```

Diffs two text files and returns difference.

:param str filename_a: first file path
:param str filename_b: second file path

:return: list of strings

##### grass.script.utils.encode

```python
encode(string, encoding=None)
```

Encode string with default locale and return bytes with that encoding

No-op if parameter is bytes (assumed already encoded).
This ensures garbage in, garbage out.

:param string: the string to encode
:param encoding: encoding to be used, default value is None

## Example

> > > encode(b"SÃ¼dtirol")
> > > b'SÃ¼dtirol'
> > > decode("Südtirol")
> > > b'SÃ¼dtirol'
> > > decode(1234)
> > > b'1234'

##### grass.script.utils.float_or_dms

```python
float_or_dms(s)
```

Convert DMS to float.

> > > round(float_or_dms("26:45:30"), 5)
> > > 26.75833
> > > round(float_or_dms("26:0:0.1"), 5)
> > > 26.00003

:param s: DMS value

:return: float value

##### grass.script.utils.get_lib_path

```python
get_lib_path(modname, libname=None)
```

Return the path of the libname contained in the module.

##### grass.script.utils.get_num_suffix

```python
get_num_suffix(number, max_number)
```

Returns formatted number with number of padding zeros
depending on maximum number, used for creating suffix for data series.
Does not include the suffix separator.

:param number: number to be formatted as map suffix
:param max_number: maximum number of the series to get number of digits

> > > get_num_suffix(10, 1000)
> > > '0010'
> > > get_num_suffix(10, 10)
> > > '10'

##### grass.script.utils.legalize_vector_name

```python
legalize_vector_name(name, fallback_prefix='x')
```

Make *name* usable for vectors, tables, and columns

The returned string is a name usable for vectors, tables, and columns,
i.e., it is a vector legal name which is a string containing only
lowercase and uppercase ASCII letters, digits, and underscores.

Invalid characters are replaced by underscores.
If the name starts with an invalid character, the name is prefixed with
*fallback_prefix*. This increases the length of the resulting name by the
length of the prefix.

The *fallback_prefix* can be empty which is useful when the *name* is later
used as a suffix for some other valid name.

ValueError is raised when provided *name* is empty or *fallback_prefix*
does not start with a valid character.

##### grass.script.utils.natural_sort

```python
natural_sort(items)
```

Returns sorted list using natural sort
(deprecated, use naturally_sorted)

##### grass.script.utils.naturally_sort

```python
naturally_sort(items, key=None)
```

Sorts lists using natural sort

##### grass.script.utils.naturally_sorted

```python
naturally_sorted(items, key=None)
```

Returns sorted list using natural sort

##### grass.script.utils.parse_key_val

```python
parse_key_val(s, sep='=', dflt=None, val_type=None, vsep=None)
```

Parse a string into a dictionary, where entries are separated
by newlines and the key and value are separated by `sep` (default: `=`)

> > > parse_key_val("min=20\\nmax=50") == {"min": "20", "max": "50"}
> > > True
> > > parse_key_val("min=20\\nmax=50", val_type=float) == {"min": 20, "max": 50}
> > > True

:param s: string to be parsed
:param sep: key/value separator
:param dflt: default value to be used
:param val_type: value type (None for no cast)
:param vsep: vertical separator (default is Python 'universal newlines' approach)

:return: parsed input (dictionary of keys/values)

##### grass.script.utils.separator

```python
separator(sep)
```

Returns separator from G_OPT_F_SEP appropriately converted
to character.

> > > separator("pipe")
> > > '|'
> > > separator("comma")
> > > ','

If the string does not match any of the separator keywords,
it is returned as is:

> > > separator(", ")
> > > ', '

:param str separator: character or separator keyword

:return: separator character

##### grass.script.utils.set_path

```python
set_path(modulename, dirname=None, path='.')
```

Set sys.path looking in the local directory GRASS directories.

:param modulename: string with the name of the GRASS module
:param dirname: string with the directory name containing the python
libraries, default None
:param path: string with the path to reach the dirname locally.

## Example

"set_path" example working locally with the source code of a module
(r.green) calling the function with all the parameters. Below it is
reported the directory structure on the r.green module.

::

```
grass_prompt> pwd
~/Download/r.green/r.green.hydro/r.green.hydro.financial

grass_prompt> tree ../../../r.green
../../../r.green
|-- ...
|-- libgreen
|   |-- pyfile1.py
|   +-- pyfile2.py
+-- r.green.hydro
   |-- Makefile
   |-- libhydro
   |   |-- pyfile1.py
   |   +-- pyfile2.py
   |-- r.green.hydro.*
   +-- r.green.hydro.financial
       |-- Makefile
       |-- ...
       +-- r.green.hydro.financial.py

21 directories, 125 files
```

in the source code the function is called with the following parameters: ::

```
set_path("r.green", "libhydro", "..")
set_path("r.green", "libgreen", os.path.join("..", ".."))
```

when we are executing the module: r.green.hydro.financial locally from
the command line: ::

```
grass_prompt> python r.green.hydro.financial.py --ui
```

In this way we are executing the local code even if the module was already
installed as grass-addons and it is available in GRASS standards path.

The function is checking if the dirname is provided and if the
directory exists and it is available using the path
provided as third parameter, if yes add the path to sys.path to be
importable, otherwise it will check on GRASS GIS standard paths.

##### grass.script.utils.split

```python
split(s)
```

Same shlex.split() func on all OS platforms

We don't use parameter posix=True on the OS MS Windows due to incorrectly
splitting command line parameters:

e.g. d.vect where="cat < 10"

is split incorrectly as follows:

'where="cat', '\<', '10"'

Should be:

'where=cat < 10'

:param str s: cmd string

return list: cmd list

##### grass.script.utils.text_to_string

```python
text_to_string(text, encoding=None)
```

Convert text to str. Useful when passing text into environments,
in Python 2 it needs to be bytes on Windows, in Python 3 in needs unicode.

##### grass.script.utils.try_remove

```python
try_remove(path)
```

Attempt to remove a file; no exception is generated if the
attempt fails.

:param str path: path to file to remove

##### grass.script.utils.try_rmdir

```python
try_rmdir(path)
```

Attempt to remove a directory; no exception is generated if the
attempt fails.

:param str path: path to directory to remove

#### grass.script.vector

Vector related functions to be used in Python scripts.

Usage:

::

```
from grass.script import vector as grass

grass.vector_db(map)
```

(C) 2008-2010 by the GRASS Development Team
This program is free software under the GNU General Public
License (>=v2). Read the file COPYING that comes with GRASS
for details.

.. sectionauthor:: Glynn Clements
.. sectionauthor:: Martin Landa \<landa.martin gmail.com>

**Functions:**

- [**vector_columns**](#grass.script.vector.vector_columns) – Return a dictionary (or a list) of the columns for the
- [**vector_db**](#grass.script.vector.vector_db) – Return the database connection details for a vector map
- [**vector_db_select**](#grass.script.vector.vector_db_select) – Get attribute data of selected vector map layer.
- [**vector_history**](#grass.script.vector.vector_history) – Set the command history for a vector map to the command used to
- [**vector_info**](#grass.script.vector.vector_info) – Return information about a vector map (interface to
- [**vector_info_topo**](#grass.script.vector.vector_info_topo) – Return information about a vector map (interface to `v.info -t`).
- [**vector_layer_db**](#grass.script.vector.vector_layer_db) – Return the database connection details for a vector map layer.
- [**vector_what**](#grass.script.vector.vector_what) – Query vector map at given locations

**Attributes:**

- [**json**](#grass.script.vector.json) –
- [**orderedDict**](#grass.script.vector.orderedDict) –

##### grass.script.vector.json

```python
json = None
```

##### grass.script.vector.orderedDict

```python
orderedDict = None
```

##### grass.script.vector.vector_columns

```python
vector_columns(map, layer=None, getDict=True, env=None, **kwargs)
```

Return a dictionary (or a list) of the columns for the
database table connected to a vector map (interface to `v.info -c`).

> > > vector_columns("geology", getDict=True) # doctest: +NORMALIZE_WHITESPACE
> > > {'PERIMETER': {'index': 2, 'type': 'DOUBLE PRECISION'}, 'GEOL250\_':
> > > {'index': 3, 'type': 'INTEGER'}, 'SHAPE_area': {'index': 6, 'type':
> > > 'DOUBLE PRECISION'}, 'onemap_pro': {'index': 1, 'type': 'DOUBLE
> > > PRECISION'}, 'SHAPE_len': {'index': 7, 'type': 'DOUBLE PRECISION'},
> > > 'cat': {'index': 0, 'type': 'INTEGER'}, 'GEOL250_ID': {'index': 4, 'type':
> > > 'INTEGER'}, 'GEO_NAME': {'index': 5, 'type': 'CHARACTER'}}

> > > vector_columns("geology", getDict=False) # doctest: +NORMALIZE_WHITESPACE
> > > \['cat',
> > > 'onemap_pro',
> > > 'PERIMETER',
> > > 'GEOL250\_',
> > > 'GEOL250_ID',
> > > 'GEO_NAME',
> > > 'SHAPE_area',
> > > 'SHAPE_len'\]

:param str map: map name
:param layer: layer number or name (None for all layers)
:param bool getDict: True to return dictionary of columns otherwise list
of column names is returned
:param kwargs: (v.info's arguments)
:param env: environment

:return: dictionary/list of columns

##### grass.script.vector.vector_db

```python
vector_db(map, env=None, **kwargs)
```

Return the database connection details for a vector map
(interface to `v.db.connect -g`). Example:

> > > vector_db("geology") # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
> > > {1: {'layer': 1, ... 'table': 'geology'}}

:param str map: vector map
:param kwargs: other v.db.connect's arguments
:param env: environment

:return: dictionary

##### grass.script.vector.vector_db_select

```python
vector_db_select(map, layer=1, env=None, **kwargs)
```

Get attribute data of selected vector map layer.

Function returns list of columns and dictionary of values ordered by
key column value. Example:

> > > print(vector_db_select("geology")["columns"])
> > > ['cat', 'onemap_pro', 'PERIMETER', 'GEOL250\_', 'GEOL250_ID', 'GEO_NAME', 'SHAPE_area', 'SHAPE_len']
> > > print(vector_db_select("geology")["values"][3])
> > > ['3', '579286.875', '3335.55835', '4', '3', 'Zml', '579286.829631', '3335.557182']
> > > print(vector_db_select("geology", columns="GEO_NAME")["values"][3])
> > > ['Zml']

:param str map: map name
:param int layer: layer number
:param kwargs: v.db.select options
:param env: environment

:return: dictionary ('columns' and 'values')

##### grass.script.vector.vector_history

```python
vector_history(map, replace=False, env=None)
```

Set the command history for a vector map to the command used to
invoke the script (interface to `v.support`).

:param str map: mapname
:param bool replace: Replace command line instead of appending it
:param env: environment

:return: v.support output

##### grass.script.vector.vector_info

```python
vector_info(map, layer=1, env=None)
```

Return information about a vector map (interface to
`v.info`). Example:

> > > vector_info("geology") # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
> > > {'comment': '', 'projection': 'Lambert Conformal Conic' ... 'south': 10875.8272320917}

:param str map: map name
:param int layer: layer number
:param env: environment

:return: parsed vector info

##### grass.script.vector.vector_info_topo

```python
vector_info_topo(map, layer=1, env=None)
```

Return information about a vector map (interface to `v.info -t`).

Example:

> > > vector_info_topo("geology") # doctest: +NORMALIZE_WHITESPACE
> > > {'lines': 0, 'centroids': 1832, 'boundaries': 3649, 'points': 0,
> > > 'primitives': 5481, 'islands': 907, 'nodes': 2724, 'map3d': False,
> > > 'areas': 1832}

:param str map: map name
:param int layer: layer number
:param env: environment

:return: parsed output

##### grass.script.vector.vector_layer_db

```python
vector_layer_db(map, layer, env=None)
```

Return the database connection details for a vector map layer.
If db connection for given layer is not defined, fatal() is called.

:param str map: map name
:param layer: layer number
:param env: environment

:return: parsed output

##### grass.script.vector.vector_what

```python
vector_what(map, coord, distance=0.0, ttype=None, encoding=None, skip_attributes=False, layer=None, multiple=False, env=None)
```

Query vector map at given locations

To query one vector map at one location

::

```
print grass.vector_what(map='archsites', coord=(595743, 4925281),
                        distance=250)

[{'Category': 8, 'Map': 'archsites', 'Layer': 1, 'Key_column': 'cat',
  'Database': '/home/martin/grassdata/spearfish60/PERMANENT/dbf/',
  'Mapset': 'PERMANENT', 'Driver': 'dbf',
  'Attributes': {'str1': 'No_Name', 'cat': '8'},
  'Table': 'archsites', 'Type': 'Point', 'Id': 8}]
```

To query one vector map with multiple layers (no additional parameters
required)

::

```
for q in grass.vector_what(map='some_map', distance=100.0,
                           coord=(596532.357143,4920486.21429)):
    print q['Map'], q['Layer'], q['Attributes']

new_bug_sites 1 {'str1': 'Beetle_site', 'GRASSRGB': '', 'cat': '80'}
new_bug_sites 2 {'cat': '80'}
```

To query more vector maps at one location

::

```
for q in grass.vector_what(map=('archsites', 'roads'),
                           coord=(595743, 4925281), distance=250):
    print q['Map'], q['Attributes']

archsites {'str1': 'No_Name', 'cat': '8'}
roads {'label': 'interstate', 'cat': '1'}
```

To query one vector map at more locations

::

```
for q in grass.vector_what(map='archsites', distance=250,
                           coord=[(595743, 4925281), (597950, 4918898)]):
    print q['Map'], q['Attributes']

archsites {'str1': 'No_Name', 'cat': '8'}
archsites {'str1': 'Bob_Miller', 'cat': '22'}
```

:param map: vector map(s) to query given as string or list/tuple
:param coord: coordinates of query given as tuple (easting, northing) or
list of tuples
:param distance: query threshold distance (in map units)
:param ttype: list of topology types (default of v.what are point, line,
area, face)
:param encoding: attributes encoding
:param skip_attributes: True to skip querying attributes
:param layer: layer number or list of layers (one for each vector),
if None, all layers (-1) are used
:param multiple: find multiple features within threshold distance
:param env: environment

:return: parsed list

#### grass.script.vector_columns

```python
vector_columns(map, layer=None, getDict=True, env=None, **kwargs)
```

Return a dictionary (or a list) of the columns for the
database table connected to a vector map (interface to `v.info -c`).

> > > vector_columns("geology", getDict=True) # doctest: +NORMALIZE_WHITESPACE
> > > {'PERIMETER': {'index': 2, 'type': 'DOUBLE PRECISION'}, 'GEOL250\_':
> > > {'index': 3, 'type': 'INTEGER'}, 'SHAPE_area': {'index': 6, 'type':
> > > 'DOUBLE PRECISION'}, 'onemap_pro': {'index': 1, 'type': 'DOUBLE
> > > PRECISION'}, 'SHAPE_len': {'index': 7, 'type': 'DOUBLE PRECISION'},
> > > 'cat': {'index': 0, 'type': 'INTEGER'}, 'GEOL250_ID': {'index': 4, 'type':
> > > 'INTEGER'}, 'GEO_NAME': {'index': 5, 'type': 'CHARACTER'}}

> > > vector_columns("geology", getDict=False) # doctest: +NORMALIZE_WHITESPACE
> > > \['cat',
> > > 'onemap_pro',
> > > 'PERIMETER',
> > > 'GEOL250\_',
> > > 'GEOL250_ID',
> > > 'GEO_NAME',
> > > 'SHAPE_area',
> > > 'SHAPE_len'\]

:param str map: map name
:param layer: layer number or name (None for all layers)
:param bool getDict: True to return dictionary of columns otherwise list
of column names is returned
:param kwargs: (v.info's arguments)
:param env: environment

:return: dictionary/list of columns

#### grass.script.vector_db

```python
vector_db(map, env=None, **kwargs)
```

Return the database connection details for a vector map
(interface to `v.db.connect -g`). Example:

> > > vector_db("geology") # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
> > > {1: {'layer': 1, ... 'table': 'geology'}}

:param str map: vector map
:param kwargs: other v.db.connect's arguments
:param env: environment

:return: dictionary

#### grass.script.vector_db_select

```python
vector_db_select(map, layer=1, env=None, **kwargs)
```

Get attribute data of selected vector map layer.

Function returns list of columns and dictionary of values ordered by
key column value. Example:

> > > print(vector_db_select("geology")["columns"])
> > > ['cat', 'onemap_pro', 'PERIMETER', 'GEOL250\_', 'GEOL250_ID', 'GEO_NAME', 'SHAPE_area', 'SHAPE_len']
> > > print(vector_db_select("geology")["values"][3])
> > > ['3', '579286.875', '3335.55835', '4', '3', 'Zml', '579286.829631', '3335.557182']
> > > print(vector_db_select("geology", columns="GEO_NAME")["values"][3])
> > > ['Zml']

:param str map: map name
:param int layer: layer number
:param kwargs: v.db.select options
:param env: environment

:return: dictionary ('columns' and 'values')

#### grass.script.vector_history

```python
vector_history(map, replace=False, env=None)
```

Set the command history for a vector map to the command used to
invoke the script (interface to `v.support`).

:param str map: mapname
:param bool replace: Replace command line instead of appending it
:param env: environment

:return: v.support output

#### grass.script.vector_info

```python
vector_info(map, layer=1, env=None)
```

Return information about a vector map (interface to
`v.info`). Example:

> > > vector_info("geology") # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
> > > {'comment': '', 'projection': 'Lambert Conformal Conic' ... 'south': 10875.8272320917}

:param str map: map name
:param int layer: layer number
:param env: environment

:return: parsed vector info

#### grass.script.vector_info_topo

```python
vector_info_topo(map, layer=1, env=None)
```

Return information about a vector map (interface to `v.info -t`).

Example:

> > > vector_info_topo("geology") # doctest: +NORMALIZE_WHITESPACE
> > > {'lines': 0, 'centroids': 1832, 'boundaries': 3649, 'points': 0,
> > > 'primitives': 5481, 'islands': 907, 'nodes': 2724, 'map3d': False,
> > > 'areas': 1832}

:param str map: map name
:param int layer: layer number
:param env: environment

:return: parsed output

#### grass.script.vector_layer_db

```python
vector_layer_db(map, layer, env=None)
```

Return the database connection details for a vector map layer.
If db connection for given layer is not defined, fatal() is called.

:param str map: map name
:param layer: layer number
:param env: environment

:return: parsed output

#### grass.script.vector_what

```python
vector_what(map, coord, distance=0.0, ttype=None, encoding=None, skip_attributes=False, layer=None, multiple=False, env=None)
```

Query vector map at given locations

To query one vector map at one location

::

```
print grass.vector_what(map='archsites', coord=(595743, 4925281),
                        distance=250)

[{'Category': 8, 'Map': 'archsites', 'Layer': 1, 'Key_column': 'cat',
  'Database': '/home/martin/grassdata/spearfish60/PERMANENT/dbf/',
  'Mapset': 'PERMANENT', 'Driver': 'dbf',
  'Attributes': {'str1': 'No_Name', 'cat': '8'},
  'Table': 'archsites', 'Type': 'Point', 'Id': 8}]
```

To query one vector map with multiple layers (no additional parameters
required)

::

```
for q in grass.vector_what(map='some_map', distance=100.0,
                           coord=(596532.357143,4920486.21429)):
    print q['Map'], q['Layer'], q['Attributes']

new_bug_sites 1 {'str1': 'Beetle_site', 'GRASSRGB': '', 'cat': '80'}
new_bug_sites 2 {'cat': '80'}
```

To query more vector maps at one location

::

```
for q in grass.vector_what(map=('archsites', 'roads'),
                           coord=(595743, 4925281), distance=250):
    print q['Map'], q['Attributes']

archsites {'str1': 'No_Name', 'cat': '8'}
roads {'label': 'interstate', 'cat': '1'}
```

To query one vector map at more locations

::

```
for q in grass.vector_what(map='archsites', distance=250,
                           coord=[(595743, 4925281), (597950, 4918898)]):
    print q['Map'], q['Attributes']

archsites {'str1': 'No_Name', 'cat': '8'}
archsites {'str1': 'Bob_Miller', 'cat': '22'}
```

:param map: vector map(s) to query given as string or list/tuple
:param coord: coordinates of query given as tuple (easting, northing) or
list of tuples
:param distance: query threshold distance (in map units)
:param ttype: list of topology types (default of v.what are point, line,
area, face)
:param encoding: attributes encoding
:param skip_attributes: True to skip querying attributes
:param layer: layer number or list of layers (one for each vector),
if None, all layers (-1) are used
:param multiple: find multiple features within threshold distance
:param env: environment

:return: parsed list

#### grass.script.verbose

```python
verbose(msg, env=None)
```

Display a verbose message using `g.message -v`

:param str msg: verbose message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.verbosity

```python
verbosity()
```

Return the verbosity level selected by GRASS_VERBOSE

Currently, there are 5 levels of verbosity:
-1 nothing will be printed (also fatal errors and warnings will be discarded)

0 only errors and warnings are printed, triggered by "--q" or "--quiet" flag.

1 progress information (percent) and important messages will be printed

2 all messages will be printed

3 also verbose messages will be printed. Triggered by "--v" or "--verbose" flag.

#### grass.script.version

```python
version()
```

Get GRASS version as dictionary

::

```
>>> print(version())
{'proj4': '4.8.0', 'geos': '3.3.5', 'libgis_revision': '52468',
 'libgis_date': '2012-07-27 22:53:30 +0200 (Fri, 27 Jul 2012)',
 'version': '7.0.svn', 'date': '2012', 'gdal': '2.0dev',
 'revision': '53670'}
```

#### grass.script.warning

```python
warning(msg, env=None)
```

Display a warning message using `g.message -w`

:param str msg: warning message to be displayed
:param env: dictionary with system environment variables (`os.environ` by default)

#### grass.script.write_command

```python
write_command(*args, **kwargs)
```

Execute a module with standard input given by *stdin* parameter.

Passes all arguments to `feed_command()`, with the string specified
by the *stdin* argument fed to the process' standard input.

> > > write_command(
> > > ... "v.in.ascii",
> > > ... input="-",
> > > ... stdin="%s|%s" % (635818.8, 221342.4),
> > > ... output="view_point",
> > > ... )
> > > 0

See `start_command()` for details about parameters and usage.

The behavior on error can be changed using *errors* parameter
which is passed to the :func:`handle_errors()` function.

:param \*args: unnamed arguments passed to `start_command()`
:param \*\*kwargs: named arguments passed to `start_command()`

:returns: 0 with default parameters for backward compatibility only

:raises: `CalledModuleError` when module returns non-zero return code

### grass.semantic_label

**Modules:**

- [**reader**](#grass.semantic_label.reader) –

**Classes:**

- [**SemanticLabelReader**](#grass.semantic_label.SemanticLabelReader) – Semantic label reader
- [**SemanticLabelReaderError**](#grass.semantic_label.SemanticLabelReaderError) –

#### grass.semantic_label.SemanticLabelReader

```python
SemanticLabelReader()
```

Semantic label reader

**Functions:**

- [**find_file**](#grass.semantic_label.SemanticLabelReader.find_file) – Find file by semantic label.
- [**get_bands**](#grass.semantic_label.SemanticLabelReader.get_bands) – Get list of band identifiers.
- [**print_info**](#grass.semantic_label.SemanticLabelReader.print_info) – Prints semantic label information to stdout.

##### grass.semantic_label.SemanticLabelReader.find_file

```python
find_file(semantic_label)
```

Find file by semantic label.

Match is case-insensitive.

:param str semantic_label: semantic label identifier to search for (eg. S2_1)

:return str: file basename if found or None

##### grass.semantic_label.SemanticLabelReader.get_bands

```python
get_bands()
```

Get list of band identifiers.

:return list: list of valid band identifiers

##### grass.semantic_label.SemanticLabelReader.print_info

```python
print_info(shortcut=None, band=None, semantic_label=None, extended=False)
```

Prints semantic label information to stdout.

Can be filtered by semantic label identifier.

:param str shortcut: shortcut to filter (eg. S2) or None
:param str band: band (eg. 1) or None
:param str semantic_label: semantic_label filter (eg. S2_8A) or None
:param bool extended: print also extended metadata

#### grass.semantic_label.SemanticLabelReaderError

Bases: <code>[Exception](#Exception)</code>

#### grass.semantic_label.reader

**Classes:**

- [**SemanticLabelReader**](#grass.semantic_label.reader.SemanticLabelReader) – Semantic label reader
- [**SemanticLabelReaderError**](#grass.semantic_label.reader.SemanticLabelReaderError) –

##### grass.semantic_label.reader.SemanticLabelReader

```python
SemanticLabelReader()
```

Semantic label reader

**Functions:**

- [**find_file**](#grass.semantic_label.reader.SemanticLabelReader.find_file) – Find file by semantic label.
- [**get_bands**](#grass.semantic_label.reader.SemanticLabelReader.get_bands) – Get list of band identifiers.
- [**print_info**](#grass.semantic_label.reader.SemanticLabelReader.print_info) – Prints semantic label information to stdout.

###### grass.semantic_label.reader.SemanticLabelReader.find_file

```python
find_file(semantic_label)
```

Find file by semantic label.

Match is case-insensitive.

:param str semantic_label: semantic label identifier to search for (eg. S2_1)

:return str: file basename if found or None

###### grass.semantic_label.reader.SemanticLabelReader.get_bands

```python
get_bands()
```

Get list of band identifiers.

:return list: list of valid band identifiers

###### grass.semantic_label.reader.SemanticLabelReader.print_info

```python
print_info(shortcut=None, band=None, semantic_label=None, extended=False)
```

Prints semantic label information to stdout.

Can be filtered by semantic label identifier.

:param str shortcut: shortcut to filter (eg. S2) or None
:param str band: band (eg. 1) or None
:param str semantic_label: semantic_label filter (eg. S2_8A) or None
:param bool extended: print also extended metadata

##### grass.semantic_label.reader.SemanticLabelReaderError

Bases: <code>[Exception](#Exception)</code>

### grass.temporal

**Modules:**

- [**abstract_dataset**](#grass.temporal.abstract_dataset) – The abstract_dataset module provides the AbstractDataset class
- [**abstract_map_dataset**](#grass.temporal.abstract_map_dataset) – The abstract_map_dataset module provides the AbstractMapDataset class
- [**abstract_space_time_dataset**](#grass.temporal.abstract_space_time_dataset) – The abstract_space_time_dataset module provides the AbstractSpaceTimeDataset
- [**aggregation**](#grass.temporal.aggregation) – Aggregation methods for space time raster datasets
- [**base**](#grass.temporal.base) – This packages includes all base classes to store basic information
- [**c_libraries_interface**](#grass.temporal.c_libraries_interface) – Fast and exit-safe interface to GRASS C-library functions
- [**core**](#grass.temporal.core) – This module provides the functionality to create the temporal
- [**datetime_math**](#grass.temporal.datetime_math) – Functions for mathematical datetime operations
- [**extract**](#grass.temporal.extract) – Extract functions for space time raster, 3d raster and vector datasets
- [**factory**](#grass.temporal.factory) – Object factory
- [**gui_support**](#grass.temporal.gui_support) – GUI support functions
- [**list_stds**](#grass.temporal.list_stds) – Functions to create space time dataset lists
- [**mapcalc**](#grass.temporal.mapcalc) – Raster and 3d raster mapcalculation functions
- [**metadata**](#grass.temporal.metadata) – Metadata classes for map layer and space time datasets
- [**open_stds**](#grass.temporal.open_stds) – Functions to open or create space time datasets
- [**register**](#grass.temporal.register) – Functions to register map layer in space time datasets and the temporal database
- [**sampling**](#grass.temporal.sampling) – Sampling functions for space time datasets
- [**space_time_datasets**](#grass.temporal.space_time_datasets) – Map layer and space time dataset classes
- [**spatial_extent**](#grass.temporal.spatial_extent) – Spatial extents classes for map layer and space time datasets
- [**spatial_topology_dataset_connector**](#grass.temporal.spatial_topology_dataset_connector) – Spatial topology connector class
- [**spatio_temporal_relationships**](#grass.temporal.spatio_temporal_relationships) – Class to build the spatio-temporal topology between map lists
- [**stds_export**](#grass.temporal.stds_export) – Export functions for space time datasets
- [**stds_import**](#grass.temporal.stds_import) – Space time dataset import functions
- [**temporal_algebra**](#grass.temporal.temporal_algebra) – @package grass.temporal
- [**temporal_extent**](#grass.temporal.temporal_extent) – Temporal extent classes
- [**temporal_granularity**](#grass.temporal.temporal_granularity) – Functions to compute the temporal granularity of a map list
- [**temporal_operator**](#grass.temporal.temporal_operator) – @package grass.temporal
- [**temporal_raster3d_algebra**](#grass.temporal.temporal_raster3d_algebra) – !@package grass.temporal
- [**temporal_raster_algebra**](#grass.temporal.temporal_raster_algebra) – !@package grass.temporal
- [**temporal_raster_base_algebra**](#grass.temporal.temporal_raster_base_algebra) – @package grass.temporal
- [**temporal_topology_dataset_connector**](#grass.temporal.temporal_topology_dataset_connector) – Temporal topology dataset connector class
- [**temporal_vector_algebra**](#grass.temporal.temporal_vector_algebra) – @package grass.temporal
- [**unit_tests**](#grass.temporal.unit_tests) – Deprecated unittests
- [**univar_statistics**](#grass.temporal.univar_statistics) – Univariate statistic function for space time datasets

**Classes:**

- [**AbsoluteTemporalExtent**](#grass.temporal.AbsoluteTemporalExtent) – This is the absolute time class for all maps and spacetime datasets
- [**AbstractDataset**](#grass.temporal.AbstractDataset) – This is the base class for all datasets
- [**AbstractDatasetComparisonKeyEndTime**](#grass.temporal.AbstractDatasetComparisonKeyEndTime) – This comparison key can be used to sort lists of abstract datasets
- [**AbstractDatasetComparisonKeyStartTime**](#grass.temporal.AbstractDatasetComparisonKeyStartTime) – This comparison key can be used to sort lists of abstract datasets
- [**AbstractMapDataset**](#grass.temporal.AbstractMapDataset) – This is the base class for all maps (raster, vector, raster3d).
- [**AbstractSTDSRegister**](#grass.temporal.AbstractSTDSRegister) – This is the base class for all maps to store the space time datasets
- [**AbstractSpaceTimeDataset**](#grass.temporal.AbstractSpaceTimeDataset) – Abstract space time dataset class
- [**CLibrariesInterface**](#grass.temporal.CLibrariesInterface) – Fast and exit-safe interface to GRASS C-libraries functions
- [**DBConnection**](#grass.temporal.DBConnection) – This class represents the database interface connection
- [**DatasetBase**](#grass.temporal.DatasetBase) – This is the base class for all maps and spacetime datasets storing
- [**DictSQLSerializer**](#grass.temporal.DictSQLSerializer) –
- [**FatalError**](#grass.temporal.FatalError) –
- [**GlobalTemporalVar**](#grass.temporal.GlobalTemporalVar) – This class handles global temporal variable conditional expressions,
- [**RPCDefs**](#grass.temporal.RPCDefs) –
- [**Raster3DAbsoluteTime**](#grass.temporal.Raster3DAbsoluteTime) –
- [**Raster3DBase**](#grass.temporal.Raster3DBase) – Time stamped 3D raster map base information class
- [**Raster3DDataset**](#grass.temporal.Raster3DDataset) – Raster3d dataset class
- [**Raster3DMetadata**](#grass.temporal.Raster3DMetadata) – This is the raster3d metadata class
- [**Raster3DRelativeTime**](#grass.temporal.Raster3DRelativeTime) –
- [**Raster3DSTDSRegister**](#grass.temporal.Raster3DSTDSRegister) – Time stamped 3D raster map base information class
- [**Raster3DSpatialExtent**](#grass.temporal.Raster3DSpatialExtent) –
- [**RasterAbsoluteTime**](#grass.temporal.RasterAbsoluteTime) –
- [**RasterBase**](#grass.temporal.RasterBase) – Time stamped raster map base information class
- [**RasterDataset**](#grass.temporal.RasterDataset) – Raster dataset class
- [**RasterMetadata**](#grass.temporal.RasterMetadata) – This is the raster metadata class
- [**RasterMetadataBase**](#grass.temporal.RasterMetadataBase) – This is the metadata base class for time stamped raster and raster3d maps
- [**RasterRelativeTime**](#grass.temporal.RasterRelativeTime) –
- [**RasterSTDSRegister**](#grass.temporal.RasterSTDSRegister) – Time stamped raster map base information class
- [**RasterSpatialExtent**](#grass.temporal.RasterSpatialExtent) –
- [**RelativeTemporalExtent**](#grass.temporal.RelativeTemporalExtent) – This is the relative time class for all maps and space time datasets
- [**SQLDatabaseInterface**](#grass.temporal.SQLDatabaseInterface) – This class represents the SQL database interface
- [**SQLDatabaseInterfaceConnection**](#grass.temporal.SQLDatabaseInterfaceConnection) –
- [**STDSAbsoluteTime**](#grass.temporal.STDSAbsoluteTime) – This class implements the absolute time extent for space time dataset
- [**STDSBase**](#grass.temporal.STDSBase) – Base class for space time datasets
- [**STDSMetadataBase**](#grass.temporal.STDSMetadataBase) – This is the space time dataset metadata base class for
- [**STDSRasterMetadataBase**](#grass.temporal.STDSRasterMetadataBase) – This is the space time dataset metadata base
- [**STDSRelativeTime**](#grass.temporal.STDSRelativeTime) – This is the relative time class for all maps and space time datasets
- [**STR3DSAbsoluteTime**](#grass.temporal.STR3DSAbsoluteTime) –
- [**STR3DSBase**](#grass.temporal.STR3DSBase) – Space time 3D raster dataset base information class
- [**STR3DSMetadata**](#grass.temporal.STR3DSMetadata) – This is the space time 3D raster metadata class
- [**STR3DSRelativeTime**](#grass.temporal.STR3DSRelativeTime) –
- [**STR3DSSpatialExtent**](#grass.temporal.STR3DSSpatialExtent) –
- [**STRDSAbsoluteTime**](#grass.temporal.STRDSAbsoluteTime) –
- [**STRDSBase**](#grass.temporal.STRDSBase) – Space time raster dataset base information class
- [**STRDSMetadata**](#grass.temporal.STRDSMetadata) – This is the raster metadata class
- [**STRDSRelativeTime**](#grass.temporal.STRDSRelativeTime) –
- [**STRDSSpatialExtent**](#grass.temporal.STRDSSpatialExtent) –
- [**STVDSAbsoluteTime**](#grass.temporal.STVDSAbsoluteTime) –
- [**STVDSBase**](#grass.temporal.STVDSBase) – Space time vector dataset base information class
- [**STVDSMetadata**](#grass.temporal.STVDSMetadata) – This is the space time vector dataset metadata class
- [**STVDSRelativeTime**](#grass.temporal.STVDSRelativeTime) –
- [**STVDSSpatialExtent**](#grass.temporal.STVDSSpatialExtent) –
- [**SpaceTimeRaster3DDataset**](#grass.temporal.SpaceTimeRaster3DDataset) – Space time raster3d dataset class
- [**SpaceTimeRasterDataset**](#grass.temporal.SpaceTimeRasterDataset) – Space time raster dataset class
- [**SpaceTimeVectorDataset**](#grass.temporal.SpaceTimeVectorDataset) – Space time vector dataset class
- [**SpatialExtent**](#grass.temporal.SpatialExtent) – This is the spatial extent base class for all maps and space time datasets
- [**SpatialTopologyDatasetConnector**](#grass.temporal.SpatialTopologyDatasetConnector) – This class implements a spatial topology access structure to connect
- [**SpatioTemporalTopologyBuilder**](#grass.temporal.SpatioTemporalTopologyBuilder) – This class is designed to build the spatio-temporal topology
- [**TemporalAlgebraLexer**](#grass.temporal.TemporalAlgebraLexer) – Lexical analyzer for the GRASS GIS temporal algebra
- [**TemporalAlgebraParser**](#grass.temporal.TemporalAlgebraParser) – The temporal algebra class
- [**TemporalExtent**](#grass.temporal.TemporalExtent) – This is the abstract time base class for relative and absolute time
- [**TemporalOperatorLexer**](#grass.temporal.TemporalOperatorLexer) – Lexical analyzer for the GRASS GIS temporal operator
- [**TemporalOperatorParser**](#grass.temporal.TemporalOperatorParser) – The temporal operator class
- [**TemporalRaster3DAlgebraParser**](#grass.temporal.TemporalRaster3DAlgebraParser) – The temporal raster algebra class
- [**TemporalRasterAlgebraLexer**](#grass.temporal.TemporalRasterAlgebraLexer) – Lexical analyzer for the GRASS GIS temporal algebra
- [**TemporalRasterAlgebraParser**](#grass.temporal.TemporalRasterAlgebraParser) – The temporal raster algebra class
- [**TemporalRasterBaseAlgebraParser**](#grass.temporal.TemporalRasterBaseAlgebraParser) – The temporal algebra class
- [**TemporalTopologyDatasetConnector**](#grass.temporal.TemporalTopologyDatasetConnector) – This class implements a temporal topology access structure to connect
- [**TemporalVectorAlgebraLexer**](#grass.temporal.TemporalVectorAlgebraLexer) – Lexical analyzer for the GRASS GIS temporal vector algebra
- [**TemporalVectorAlgebraParser**](#grass.temporal.TemporalVectorAlgebraParser) – The temporal algebra class
- [**VectorAbsoluteTime**](#grass.temporal.VectorAbsoluteTime) –
- [**VectorBase**](#grass.temporal.VectorBase) – Time stamped vector map base information class
- [**VectorDataset**](#grass.temporal.VectorDataset) – Vector dataset class
- [**VectorMetadata**](#grass.temporal.VectorMetadata) – This is the vector metadata class
- [**VectorRelativeTime**](#grass.temporal.VectorRelativeTime) –
- [**VectorSTDSRegister**](#grass.temporal.VectorSTDSRegister) – Time stamped vector map base information class
- [**VectorSpatialExtent**](#grass.temporal.VectorSpatialExtent) –

**Functions:**

- [**adjust_datetime_to_granularity**](#grass.temporal.adjust_datetime_to_granularity) – Modify the datetime object to fit the given granularity
- [**aggregate_by_topology**](#grass.temporal.aggregate_by_topology) – Aggregate a list of raster input maps with r.series
- [**aggregate_raster_maps**](#grass.temporal.aggregate_raster_maps) – Aggregate a list of raster input maps with r.series
- [**assign_valid_time_to_map**](#grass.temporal.assign_valid_time_to_map) – Assign the valid time to a map dataset
- [**c_library_server**](#grass.temporal.c_library_server) – The GRASS C-libraries server function designed to be a target for
- [**check_datetime_string**](#grass.temporal.check_datetime_string) – Check if a string can be converted into a datetime object and return the object
- [**check_granularity_string**](#grass.temporal.check_granularity_string) – Check if the granularity string is valid
- [**check_new_map_dataset**](#grass.temporal.check_new_map_dataset) – Check if a new map dataset of a specific type can be created in
- [**check_new_stds**](#grass.temporal.check_new_stds) – Check if a new space time dataset of a specific type can be created
- [**collect_map_names**](#grass.temporal.collect_map_names) – Gather all maps from dataset using a specific sample method
- [**compute_absolute_time_granularity**](#grass.temporal.compute_absolute_time_granularity) – Compute the absolute time granularity
- [**compute_common_absolute_time_granularity**](#grass.temporal.compute_common_absolute_time_granularity) – Compute the greatest common granule from a list of absolute time granules,
- [**compute_common_absolute_time_granularity_simple**](#grass.temporal.compute_common_absolute_time_granularity_simple) – Compute the greatest common granule from a list of absolute time granules
- [**compute_common_relative_time_granularity**](#grass.temporal.compute_common_relative_time_granularity) – Compute the greatest common granule from a list of relative time granules
- [**compute_datetime_delta**](#grass.temporal.compute_datetime_delta) – Return a dictionary with the accumulated delta in year, month, day,
- [**compute_relative_time_granularity**](#grass.temporal.compute_relative_time_granularity) – Compute the relative time granularity
- [**compute_univar_stats**](#grass.temporal.compute_univar_stats) – Compute univariate statistics for a map of a space time raster or raster3d
- [**count_temporal_topology_relationships**](#grass.temporal.count_temporal_topology_relationships) – Count the temporal relations of a single list of maps or between two
- [**create_numeric_suffix**](#grass.temporal.create_numeric_suffix) – Create a string based on count and number of zeros decided by zeros
- [**create_suffix_from_datetime**](#grass.temporal.create_suffix_from_datetime) – Create a datetime string based on a datetime object and a provided
- [**create_temporal_database**](#grass.temporal.create_temporal_database) – This function will create the temporal database
- [**create_temporal_relation_sql_where_statement**](#grass.temporal.create_temporal_relation_sql_where_statement) – Create a SQL WHERE statement for temporal relation selection of maps in
- [**create_time_suffix**](#grass.temporal.create_time_suffix) – Create a datetime string based on a map datetime object
- [**dataset_factory**](#grass.temporal.dataset_factory) – A factory functions to create space time or map datasets
- [**dataset_mapcalculator**](#grass.temporal.dataset_mapcalculator) – Perform map-calculations of maps from different space time
- [**datetime_to_grass_datetime_string**](#grass.temporal.datetime_to_grass_datetime_string) – Convert a python datetime object into a GRASS datetime string
- [**decrement_datetime_by_string**](#grass.temporal.decrement_datetime_by_string) – Return a new datetime object decremented with the provided
- [**export_stds**](#grass.temporal.export_stds) – Export space time datasets as tar archive with optional compression
- [**extract_dataset**](#grass.temporal.extract_dataset) – Extract a subset of a space time raster, raster3d or vector dataset
- [**gcd**](#grass.temporal.gcd) – The Euclidean Algorithm
- [**gcd_list**](#grass.temporal.gcd_list) – Finds the GCD of numbers in a list.
- [**get_available_temporal_mapsets**](#grass.temporal.get_available_temporal_mapsets) – Return a list of of mapset names with temporal database driver and names
- [**get_current_gisdbase**](#grass.temporal.get_current_gisdbase) – Return the current gis database (gisdbase)
- [**get_current_location**](#grass.temporal.get_current_location) – Return the current location
- [**get_current_mapset**](#grass.temporal.get_current_mapset) – Return the current mapset
- [**get_database_info_string**](#grass.temporal.get_database_info_string) –
- [**get_dataset_list**](#grass.temporal.get_dataset_list) – Return a list of time stamped maps or space time datasets of a specific
- [**get_enable_mapset_check**](#grass.temporal.get_enable_mapset_check) – Return True if the mapsets should be checked while insert, update,
- [**get_enable_timestamp_write**](#grass.temporal.get_enable_timestamp_write) – Return True if the map timestamps should be written to the spatial
- [**get_raise_on_error**](#grass.temporal.get_raise_on_error) – Return True if a FatalError exception is raised instead of calling
- [**get_sql_template_path**](#grass.temporal.get_sql_template_path) –
- [**get_tgis_backend**](#grass.temporal.get_tgis_backend) – Return the temporal GIS backend as string
- [**get_tgis_c_library_interface**](#grass.temporal.get_tgis_c_library_interface) – Return the C-library interface that
- [**get_tgis_database**](#grass.temporal.get_tgis_database) – Return the temporal database string specified with t.connect
- [**get_tgis_database_string**](#grass.temporal.get_tgis_database_string) – Return the preprocessed temporal database string
- [**get_tgis_db_version**](#grass.temporal.get_tgis_db_version) – Get the supported version of the temporal database
- [**get_tgis_db_version_from_metadata**](#grass.temporal.get_tgis_db_version_from_metadata) – Get the version number of the temporal database from metadata
- [**get_tgis_dbmi_paramstyle**](#grass.temporal.get_tgis_dbmi_paramstyle) – Return the temporal database backend parameter style
- [**get_tgis_message_interface**](#grass.temporal.get_tgis_message_interface) – Return the temporal GIS message interface which is of type
- [**get_tgis_metadata**](#grass.temporal.get_tgis_metadata) – Return the tgis metadata table as a list of rows (dicts) or None if not
- [**get_tgis_version**](#grass.temporal.get_tgis_version) – Get the supported version of the temporal framework
- [**get_time_tuple_function**](#grass.temporal.get_time_tuple_function) – Helper function to return the appropriate function to get
- [**gran_plural_unit**](#grass.temporal.gran_plural_unit) – Return the absolute granularity unit in its singular term
- [**gran_singular_unit**](#grass.temporal.gran_singular_unit) – Return the absolute granularity unit in its singular term
- [**gran_to_gran**](#grass.temporal.gran_to_gran) – Converts the computed absolute granularity of a STDS to a smaller
- [**import_stds**](#grass.temporal.import_stds) – Import space time datasets of type raster and vector
- [**increment_datetime_by_string**](#grass.temporal.increment_datetime_by_string) – Return a new datetime object incremented with the provided
- [**init**](#grass.temporal.init) – This function set the correct database backend from GRASS environmental
- [**init_dbif**](#grass.temporal.init_dbif) – This method checks if the database interface connection exists,
- [**list_maps_of_stds**](#grass.temporal.list_maps_of_stds) – List the maps of a space time dataset using different methods
- [**modify_datetime**](#grass.temporal.modify_datetime) – Return a new datetime object incremented with the provided
- [**modify_datetime_by_string**](#grass.temporal.modify_datetime_by_string) – Return a new datetime object incremented with the provided
- [**open_new_map_dataset**](#grass.temporal.open_new_map_dataset) – Create a new map dataset object of a specific type that can be
- [**open_new_stds**](#grass.temporal.open_new_stds) – Create a new space time dataset of a specific type
- [**open_old_stds**](#grass.temporal.open_old_stds) – This function opens an existing space time dataset and return the
- [**print_gridded_dataset_univar_statistics**](#grass.temporal.print_gridded_dataset_univar_statistics) – Print univariate statistics for a space time raster or raster3d dataset.
- [**print_spatio_temporal_topology_relationships**](#grass.temporal.print_spatio_temporal_topology_relationships) – Print the temporal relationships of the
- [**print_temporal_topology_relationships**](#grass.temporal.print_temporal_topology_relationships) – Print the temporal relationships of the
- [**print_vector_dataset_univar_statistics**](#grass.temporal.print_vector_dataset_univar_statistics) – Print univariate statistics for a space time vector dataset
- [**profile_function**](#grass.temporal.profile_function) – Profiling function provided by the temporal framework
- [**register_map_object_list**](#grass.temporal.register_map_object_list) – Register a list of AbstractMapDataset objects in the temporal database
- [**register_maps_in_space_time_dataset**](#grass.temporal.register_maps_in_space_time_dataset) – Use this method to register maps in space time datasets.
- [**relative_time_to_time_delta**](#grass.temporal.relative_time_to_time_delta) – Convert the double value representing days into a timedelta object.
- [**relative_time_to_time_delta_seconds**](#grass.temporal.relative_time_to_time_delta_seconds) – Convert the double value representing seconds into a timedelta object.
- [**run_mapcalc2d**](#grass.temporal.run_mapcalc2d) – Helper function to run r.mapcalc in parallel
- [**run_mapcalc3d**](#grass.temporal.run_mapcalc3d) – Helper function to run r3.mapcalc in parallel
- [**run_vector_extraction**](#grass.temporal.run_vector_extraction) – Helper function to run r.mapcalc in parallel
- [**sample_stds_by_stds_topology**](#grass.temporal.sample_stds_by_stds_topology) – Sample the input space time datasets with a sample
- [**set_raise_on_error**](#grass.temporal.set_raise_on_error) – Define behavior on fatal error, invoked using the tgis messenger
- [**set_spatial_relationship**](#grass.temporal.set_spatial_relationship) –
- [**set_temporal_relationship**](#grass.temporal.set_temporal_relationship) –
- [**stop_subprocesses**](#grass.temporal.stop_subprocesses) – Stop the messenger and C-interface subprocesses
- [**string_to_datetime**](#grass.temporal.string_to_datetime) – Convert a string into a datetime object
- [**time_delta_to_relative_time**](#grass.temporal.time_delta_to_relative_time) – Convert the time delta into a double value, representing days.
- [**time_delta_to_relative_time_seconds**](#grass.temporal.time_delta_to_relative_time_seconds) – Convert the time delta into a double value, representing seconds.
- [**tlist**](#grass.temporal.tlist) – Return a list of space time datasets of absolute and relative time
- [**tlist_grouped**](#grass.temporal.tlist_grouped) – List of temporal elements grouped by mapsets.
- [**upgrade_temporal_database**](#grass.temporal.upgrade_temporal_database) – This function will upgrade the temporal database if needed.

#### grass.temporal.AbsoluteTemporalExtent

```python
AbsoluteTemporalExtent(table=None, ident=None, start_time=None, end_time=None)
```

Bases: <code>[TemporalExtent](#grass.temporal.temporal_extent.TemporalExtent)</code>

This is the absolute time class for all maps and spacetime datasets

start_time and end_time must be of type datetime

**Functions:**

- [**adjacent**](#grass.temporal.AbsoluteTemporalExtent.adjacent) – Return True if this temporal extent (A) is a meeting neighbor the
- [**after**](#grass.temporal.AbsoluteTemporalExtent.after) – Return True if this temporal extent (A) is located after the
- [**before**](#grass.temporal.AbsoluteTemporalExtent.before) – Return True if this temporal extent (A) is located before the
- [**clear**](#grass.temporal.AbsoluteTemporalExtent.clear) – Initialize the internal storage
- [**contains**](#grass.temporal.AbsoluteTemporalExtent.contains) – Return True if this temporal extent (A) contains the provided
- [**delete**](#grass.temporal.AbsoluteTemporalExtent.delete) – Delete the entry of this object from the temporal database
- [**deserialize**](#grass.temporal.AbsoluteTemporalExtent.deserialize) – Convert the content of the dbmi dictionary like row into the
- [**disjoint_union**](#grass.temporal.AbsoluteTemporalExtent.disjoint_union) – Creates a disjoint union with this temporal extent and the provided one.
- [**during**](#grass.temporal.AbsoluteTemporalExtent.during) – Return True if this temporal extent (A) is located during the provided
- [**equal**](#grass.temporal.AbsoluteTemporalExtent.equal) – Return True if this temporal extent (A) is equal to the provided
- [**finished**](#grass.temporal.AbsoluteTemporalExtent.finished) – Return True if this temporal extent (A) starts before the start of
- [**finishes**](#grass.temporal.AbsoluteTemporalExtent.finishes) – Return True if this temporal extent (A) starts after the start of
- [**follows**](#grass.temporal.AbsoluteTemporalExtent.follows) – Return True if this temporal extent (A) follows the
- [**get_delete_statement**](#grass.temporal.AbsoluteTemporalExtent.get_delete_statement) – Return the delete string
- [**get_end_time**](#grass.temporal.AbsoluteTemporalExtent.get_end_time) – Get the valid end time of the extent
- [**get_id**](#grass.temporal.AbsoluteTemporalExtent.get_id) – Convenient method to get the unique identifier (primary key)
- [**get_insert_statement**](#grass.temporal.AbsoluteTemporalExtent.get_insert_statement) – Return the sql statement and the argument
- [**get_insert_statement_mogrified**](#grass.temporal.AbsoluteTemporalExtent.get_insert_statement_mogrified) – Return the insert statement as mogrified string
- [**get_is_in_db_statement**](#grass.temporal.AbsoluteTemporalExtent.get_is_in_db_statement) – Return the selection string that checks if this object is registered in the
- [**get_select_statement**](#grass.temporal.AbsoluteTemporalExtent.get_select_statement) – Return the sql statement and the argument list in
- [**get_select_statement_mogrified**](#grass.temporal.AbsoluteTemporalExtent.get_select_statement_mogrified) – Return the select statement as mogrified string
- [**get_start_time**](#grass.temporal.AbsoluteTemporalExtent.get_start_time) – Get the valid start time of the extent
- [**get_table_name**](#grass.temporal.AbsoluteTemporalExtent.get_table_name) – Return the name of the table in which the internal
- [**get_update_all_statement**](#grass.temporal.AbsoluteTemporalExtent.get_update_all_statement) – Return the sql statement and the argument
- [**get_update_all_statement_mogrified**](#grass.temporal.AbsoluteTemporalExtent.get_update_all_statement_mogrified) – Return the update all statement as mogrified string
- [**get_update_statement**](#grass.temporal.AbsoluteTemporalExtent.get_update_statement) – Return the sql statement and the argument list
- [**get_update_statement_mogrified**](#grass.temporal.AbsoluteTemporalExtent.get_update_statement_mogrified) – Return the update statement as mogrified string
- [**insert**](#grass.temporal.AbsoluteTemporalExtent.insert) – Serialize the content of this object and store it in the temporal
- [**intersect**](#grass.temporal.AbsoluteTemporalExtent.intersect) – Intersect this temporal extent with the provided temporal extent and
- [**is_in_db**](#grass.temporal.AbsoluteTemporalExtent.is_in_db) – Check if this object is present in the temporal database
- [**overlapped**](#grass.temporal.AbsoluteTemporalExtent.overlapped) – Return True if this temporal extent (A) overlaps the provided
- [**overlaps**](#grass.temporal.AbsoluteTemporalExtent.overlaps) – Return True if this temporal extent (A) overlapped the provided
- [**precedes**](#grass.temporal.AbsoluteTemporalExtent.precedes) – Return True if this temporal extent (A) precedes the provided
- [**print_info**](#grass.temporal.AbsoluteTemporalExtent.print_info) – Print information about this class in human readable style
- [**print_self**](#grass.temporal.AbsoluteTemporalExtent.print_self) – Print the content of the internal dictionary to stdout
- [**print_shell_info**](#grass.temporal.AbsoluteTemporalExtent.print_shell_info) – Print information about this class in shell style
- [**select**](#grass.temporal.AbsoluteTemporalExtent.select) – Select the content from the temporal database and store it
- [**serialize**](#grass.temporal.AbsoluteTemporalExtent.serialize) – Convert the internal dictionary into a string of semicolon
- [**set_end_time**](#grass.temporal.AbsoluteTemporalExtent.set_end_time) – Set the valid end time of the extent
- [**set_id**](#grass.temporal.AbsoluteTemporalExtent.set_id) – Convenient method to set the unique identifier (primary key)
- [**set_start_time**](#grass.temporal.AbsoluteTemporalExtent.set_start_time) – Set the valid start time of the extent
- [**started**](#grass.temporal.AbsoluteTemporalExtent.started) – Return True if this temporal extent (A) started at the start of the
- [**starts**](#grass.temporal.AbsoluteTemporalExtent.starts) – Return True if this temporal extent (A) starts at the start of the
- [**temporal_relation**](#grass.temporal.AbsoluteTemporalExtent.temporal_relation) – Returns the temporal relation between temporal objects
- [**union**](#grass.temporal.AbsoluteTemporalExtent.union) – Creates a union with this temporal extent and the provided one.
- [**update**](#grass.temporal.AbsoluteTemporalExtent.update) – Serialize the content of this object and update it in the temporal
- [**update_all**](#grass.temporal.AbsoluteTemporalExtent.update_all) – Serialize the content of this object, including None objects,

**Attributes:**

- [**D**](#grass.temporal.AbsoluteTemporalExtent.D) –
- [**dbmi_paramstyle**](#grass.temporal.AbsoluteTemporalExtent.dbmi_paramstyle) –
- [**end_time**](#grass.temporal.AbsoluteTemporalExtent.end_time) –
- [**id**](#grass.temporal.AbsoluteTemporalExtent.id) –
- [**ident**](#grass.temporal.AbsoluteTemporalExtent.ident) –
- [**mapset**](#grass.temporal.AbsoluteTemporalExtent.mapset) –
- [**msgr**](#grass.temporal.AbsoluteTemporalExtent.msgr) –
- [**start_time**](#grass.temporal.AbsoluteTemporalExtent.start_time) –
- [**table**](#grass.temporal.AbsoluteTemporalExtent.table) –

##### grass.temporal.AbsoluteTemporalExtent.D

```python
D = {}
```

##### grass.temporal.AbsoluteTemporalExtent.adjacent

```python
adjacent(extent)
```

Return True if this temporal extent (A) is a meeting neighbor the
provided temporal extent (B)
::

```
A            |---------|
B  |---------|
A  |---------|
B            |---------|
```

:param extent: The temporal extent object that is a meeting neighbor
of this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=7, end_time=9)
>>> A.adjacent(B)
True
>>> B.adjacent(A)
True
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=3, end_time=5)
>>> A.adjacent(B)
True
>>> B.adjacent(A)
True
```

##### grass.temporal.AbsoluteTemporalExtent.after

```python
after(extent)
```

Return True if this temporal extent (A) is located after the
provided temporal extent (B)
::

```
A             |---------|
B  |---------|
```

:param extent: The temporal extent object that is located before
this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=8, end_time=9)
>>> B = TemporalExtent(start_time=6, end_time=7)
>>> A.after(B)
True
>>> B.after(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.before

```python
before(extent)
```

Return True if this temporal extent (A) is located before the
provided temporal extent (B)
::

```
A  |---------|
B             |---------|
```

:param extent: The temporal extent object that is located after
this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=6, end_time=7)
>>> B = TemporalExtent(start_time=8, end_time=9)
>>> A.before(B)
True
>>> B.before(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.clear

```python
clear()
```

Initialize the internal storage

##### grass.temporal.AbsoluteTemporalExtent.contains

```python
contains(extent)
```

Return True if this temporal extent (A) contains the provided
temporal extent (B)
::

```
A  |---------|
B   |-------|
```

:param extent: The temporal extent object that is located
during this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=4, end_time=9)
>>> B = TemporalExtent(start_time=5, end_time=8)
>>> A.contains(B)
True
>>> B.contains(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.dbmi_paramstyle

```python
dbmi_paramstyle = get_tgis_dbmi_paramstyle()
```

##### grass.temporal.AbsoluteTemporalExtent.delete

```python
delete(dbif=None)
```

Delete the entry of this object from the temporal database

:param dbif: The database interface to be used,
if None a temporary connection will be established

##### grass.temporal.AbsoluteTemporalExtent.deserialize

```python
deserialize(row)
```

Convert the content of the dbmi dictionary like row into the
internal dictionary

:param row: The dictionary like row to store in the internal dict

##### grass.temporal.AbsoluteTemporalExtent.disjoint_union

```python
disjoint_union(extent)
```

Creates a disjoint union with this temporal extent and the provided one.
Return a new temporal extent with the new start and end time.

:param extent: The temporal extent to create a union with
:return: The new temporal extent with start and end time

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=6)
>>> inter = A.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6

>>> A = TemporalExtent(start_time=5, end_time=6)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 7
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 7

>>> A = TemporalExtent(start_time=3, end_time=6)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 7
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 7

>>> A = TemporalExtent(start_time=3, end_time=8)
>>> B = TemporalExtent(start_time=5, end_time=6)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8

>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=6)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8

>>> A = TemporalExtent(start_time=5, end_time=None)
>>> B = TemporalExtent(start_time=3, end_time=6)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 6
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 6

>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=4)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=None)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> A = TemporalExtent(start_time=5, end_time=None)
>>> B = TemporalExtent(start_time=3, end_time=8)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 8
>>> A = TemporalExtent(start_time=5, end_time=None)
>>> B = TemporalExtent(start_time=3, end_time=None)
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 5
>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 | Start time:................. 3
 | End time:................... 5

>>> A = RelativeTemporalExtent(start_time=5, end_time=None, unit="years")
>>> B = RelativeTemporalExtent(start_time=3, end_time=None, unit="years")
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 3
 | End time:................... 5
 | Relative time unit:......... years

>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 3
 | End time:................... 5
 | Relative time unit:......... years


>>> from datetime import datetime as dt
>>> A = AbsoluteTemporalExtent(
...     start_time=dt(2001, 1, 10), end_time=dt(2003, 1, 1)
... )
>>> B = AbsoluteTemporalExtent(
...     start_time=dt(2005, 1, 10), end_time=dt(2008, 1, 1)
... )
>>> inter = A.disjoint_union(B)
>>> inter.print_info()
 +-------------------- Absolute time -----------------------------------------+
 | Start time:................. 2001-01-10 00:00:00
 | End time:................... 2008-01-01 00:00:00

>>> inter = B.disjoint_union(A)
>>> inter.print_info()
 +-------------------- Absolute time -----------------------------------------+
 | Start time:................. 2001-01-10 00:00:00
 | End time:................... 2008-01-01 00:00:00
```

##### grass.temporal.AbsoluteTemporalExtent.during

```python
during(extent)
```

Return True if this temporal extent (A) is located during the provided
temporal extent (B)
::

```
A   |-------|
B  |---------|
```

:param extent: The temporal extent object that contains this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=4, end_time=9)
>>> A.during(B)
True
>>> B.during(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.end_time

```python
end_time = property(fget=get_end_time, fset=set_end_time)
```

##### grass.temporal.AbsoluteTemporalExtent.equal

```python
equal(extent)
```

Return True if this temporal extent (A) is equal to the provided
temporal extent (B)
::

```
A  |---------|
B  |---------|
```

:param extent: The temporal extent object that is equal
during this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=6)
>>> B = TemporalExtent(start_time=5, end_time=6)
>>> A.equal(B)
True
>>> B.equal(A)
True
```

##### grass.temporal.AbsoluteTemporalExtent.finished

```python
finished(extent)
```

Return True if this temporal extent (A) starts before the start of
the provided temporal extent (B) and finishes with it
::

```
A  |---------|
B      |-----|
```

:param extent: The temporal extent object with which this extent
finishes

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=6, end_time=7)
>>> A.finished(B)
True
>>> B.finished(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.finishes

```python
finishes(extent)
```

Return True if this temporal extent (A) starts after the start of
the provided temporal extent (B) and finishes with it
::

```
A      |-----|
B  |---------|
```

:param extent: The temporal extent object with which this extent
finishes

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=6, end_time=7)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> A.finishes(B)
True
>>> B.finishes(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.follows

```python
follows(extent)
```

Return True if this temporal extent (A) follows the
provided temporal extent (B)
::

```
A            |---------|
B  |---------|
```

:param extent: The temporal extent object that is the predecessor
of this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=3, end_time=5)
>>> A.follows(B)
True
>>> B.follows(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.get_delete_statement

```python
get_delete_statement()
```

Return the delete string
:return: The DELETE string

##### grass.temporal.AbsoluteTemporalExtent.get_end_time

```python
get_end_time()
```

Get the valid end time of the extent
:return: None if not found

##### grass.temporal.AbsoluteTemporalExtent.get_id

```python
get_id()
```

Convenient method to get the unique identifier (primary key)
:return: None if not found

##### grass.temporal.AbsoluteTemporalExtent.get_insert_statement

```python
get_insert_statement()
```

Return the sql statement and the argument
list in database specific style
:return: The INSERT string

##### grass.temporal.AbsoluteTemporalExtent.get_insert_statement_mogrified

```python
get_insert_statement_mogrified(dbif=None)
```

Return the insert statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:return: The INSERT string

##### grass.temporal.AbsoluteTemporalExtent.get_is_in_db_statement

```python
get_is_in_db_statement()
```

Return the selection string that checks if this object is registered in the
temporal database
:return: The SELECT string

##### grass.temporal.AbsoluteTemporalExtent.get_select_statement

```python
get_select_statement()
```

Return the sql statement and the argument list in
database specific style
:return: The SELECT string

##### grass.temporal.AbsoluteTemporalExtent.get_select_statement_mogrified

```python
get_select_statement_mogrified(dbif=None)
```

Return the select statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:return: The SELECT string

##### grass.temporal.AbsoluteTemporalExtent.get_start_time

```python
get_start_time()
```

Get the valid start time of the extent
:return: None if not found

##### grass.temporal.AbsoluteTemporalExtent.get_table_name

```python
get_table_name()
```

Return the name of the table in which the internal
data are inserted, updated or selected
:return: The name of the table

##### grass.temporal.AbsoluteTemporalExtent.get_update_all_statement

```python
get_update_all_statement(ident=None)
```

Return the sql statement and the argument
list in database specific style

:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbsoluteTemporalExtent.get_update_all_statement_mogrified

```python
get_update_all_statement_mogrified(dbif=None, ident=None)
```

Return the update all statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbsoluteTemporalExtent.get_update_statement

```python
get_update_statement(ident=None)
```

Return the sql statement and the argument list
in database specific style

:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbsoluteTemporalExtent.get_update_statement_mogrified

```python
get_update_statement_mogrified(dbif=None, ident=None)
```

Return the update statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbsoluteTemporalExtent.id

```python
id = property(fget=get_id, fset=set_id)
```

##### grass.temporal.AbsoluteTemporalExtent.ident

```python
ident = ident
```

##### grass.temporal.AbsoluteTemporalExtent.insert

```python
insert(dbif=None)
```

Serialize the content of this object and store it in the temporal
database using the internal identifier

:param dbif: The database interface to be used,
if None a temporary connection will be established

##### grass.temporal.AbsoluteTemporalExtent.intersect

```python
intersect(extent)
```

Intersect this temporal extent with the provided temporal extent and
return a new temporal extent with the new start and end time

:param extent: The temporal extent to intersect with
:return: The new temporal extent with start and end time,
or None in case of no intersection

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=6)
>>> inter = A.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6

>>> A = TemporalExtent(start_time=5, end_time=6)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> inter = A.intersect(B)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6
>>> inter = B.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6

>>> A = TemporalExtent(start_time=3, end_time=6)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> inter = A.intersect(B)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6
>>> inter = B.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6

>>> A = TemporalExtent(start_time=3, end_time=8)
>>> B = TemporalExtent(start_time=5, end_time=6)
>>> inter = A.intersect(B)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6
>>> inter = B.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6

>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=6)
>>> inter = A.intersect(B)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6
>>> inter = B.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... 6

>>> A = TemporalExtent(start_time=5, end_time=None)
>>> B = TemporalExtent(start_time=3, end_time=6)
>>> inter = A.intersect(B)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... None
>>> inter = B.intersect(A)
>>> inter.print_info()
 | Start time:................. 5
 | End time:................... None

>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=4)
>>> inter = A.intersect(B)
>>> print(inter)
None

>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=None)
>>> inter = A.intersect(B)
>>> print(inter)
None
```

##### grass.temporal.AbsoluteTemporalExtent.is_in_db

```python
is_in_db(dbif=None, mapset=None)
```

Check if this object is present in the temporal database

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param mapset: The mapset with a temporal database to be used
The mapset of the database can be different from
the mapset of the map
:return: True if this object is present in the temporal database,
False otherwise

##### grass.temporal.AbsoluteTemporalExtent.mapset

```python
mapset = self.ident.split('@')[1]
```

##### grass.temporal.AbsoluteTemporalExtent.msgr

```python
msgr = get_tgis_message_interface()
```

##### grass.temporal.AbsoluteTemporalExtent.overlapped

```python
overlapped(extent)
```

Return True if this temporal extent (A) overlaps the provided
temporal extent (B)
::

```
A    |---------|
B  |---------|
```

:param extent: The temporal extent object that is overlapped
this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=6, end_time=8)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> A.overlapped(B)
True
>>> B.overlapped(A)
False

>>> A = TemporalExtent(start_time=6, end_time=8)
>>> B = TemporalExtent(start_time=5, end_time=6)
>>> A.overlapped(B)
False
>>> B.overlapped(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.overlaps

```python
overlaps(extent)
```

Return True if this temporal extent (A) overlapped the provided
temporal extent (B)
::

```
A  |---------|
B    |---------|
```

:param extent: The temporal extent object that is overlaps
this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=6, end_time=8)
>>> A.overlaps(B)
True
>>> B.overlaps(A)
False

>>> A = TemporalExtent(start_time=5, end_time=6)
>>> B = TemporalExtent(start_time=6, end_time=8)
>>> A.overlaps(B)
False
>>> B.overlaps(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.precedes

```python
precedes(extent)
```

Return True if this temporal extent (A) precedes the provided
temporal extent (B)
::

```
A  |---------|
B            |---------|
```

:param extent: The temporal extent object that is the successor
of this extent

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=7, end_time=9)
>>> A.precedes(B)
True
>>> B.precedes(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.print_info

```python
print_info()
```

Print information about this class in human readable style

##### grass.temporal.AbsoluteTemporalExtent.print_self

```python
print_self()
```

Print the content of the internal dictionary to stdout

##### grass.temporal.AbsoluteTemporalExtent.print_shell_info

```python
print_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbsoluteTemporalExtent.select

```python
select(dbif=None, mapset=None)
```

Select the content from the temporal database and store it
in the internal dictionary structure

:param dbif: The database interface to be used,
if None a temporary connection will be established

##### grass.temporal.AbsoluteTemporalExtent.serialize

```python
serialize(type, table, where=None)
```

Convert the internal dictionary into a string of semicolon
separated SQL statements The keys are the column names and
the values are the row entries

Usage:

.. code-block:: python

```
>>> init()
>>> t = DictSQLSerializer()
>>> t.D["id"] = "soil@PERMANENT"
>>> t.D["name"] = "soil"
>>> t.D["mapset"] = "PERMANENT"
>>> t.D["creator"] = "soeren"
>>> t.D["creation_time"] = datetime(2001, 1, 1)
>>> t.D["modification_time"] = datetime(2001, 1, 1)
>>> t.serialize(type="SELECT", table="raster_base")
('SELECT  name  , creator  , creation_time  , modification_time  , mapset  , id  FROM raster_base ;\n', ())
>>> t.serialize(type="INSERT", table="raster_base")
('INSERT INTO raster_base ( name  ,creator  ,creation_time  ,modification_time  ,mapset  ,id ) VALUES (? ,? ,? ,? ,? ,?) ;\n', ('soil', 'soeren', datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0), 'PERMANENT', 'soil@PERMANENT'))
>>> t.serialize(type="UPDATE", table="raster_base")
('UPDATE raster_base SET  name = ?  ,creator = ?  ,creation_time = ?  ,modification_time = ?  ,mapset = ?  ,id = ? ;\n', ('soil', 'soeren', datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0), 'PERMANENT', 'soil@PERMANENT'))
>>> t.serialize(type="UPDATE ALL", table="raster_base")
('UPDATE raster_base SET  name = ?  ,creator = ?  ,creation_time = ?  ,modification_time = ?  ,mapset = ?  ,id = ? ;\n', ('soil', 'soeren', datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0), 'PERMANENT', 'soil@PERMANENT'))

:param type: must be SELECT. INSERT, UPDATE
:param table: The name of the table to select, insert or update
:param where: The optional where statement
:return: a tuple containing the SQL string and the arguments
```

##### grass.temporal.AbsoluteTemporalExtent.set_end_time

```python
set_end_time(end_time)
```

Set the valid end time of the extent

##### grass.temporal.AbsoluteTemporalExtent.set_id

```python
set_id(ident)
```

Convenient method to set the unique identifier (primary key)

##### grass.temporal.AbsoluteTemporalExtent.set_start_time

```python
set_start_time(start_time)
```

Set the valid start time of the extent

##### grass.temporal.AbsoluteTemporalExtent.start_time

```python
start_time = property(fget=get_start_time, fset=set_start_time)
```

##### grass.temporal.AbsoluteTemporalExtent.started

```python
started(extent)
```

Return True if this temporal extent (A) started at the start of the
provided temporal extent (B) and finishes after it
::

```
A  |---------|
B  |-----|
```

:param extent: The temporal extent object with which this extent
started

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=7)
>>> B = TemporalExtent(start_time=5, end_time=6)
>>> A.started(B)
True
>>> B.started(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.starts

```python
starts(extent)
```

Return True if this temporal extent (A) starts at the start of the
provided temporal extent (B) and finishes within it
::

```
A  |-----|
B  |---------|
```

:param extent: The temporal extent object with which this extent
starts

Usage:

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=6)
>>> B = TemporalExtent(start_time=5, end_time=7)
>>> A.starts(B)
True
>>> B.starts(A)
False
```

##### grass.temporal.AbsoluteTemporalExtent.table

```python
table = table
```

##### grass.temporal.AbsoluteTemporalExtent.temporal_relation

```python
temporal_relation(extent)
```

Returns the temporal relation between temporal objects
Temporal relationships are implemented after
[Allen and Ferguson 1994 Actions and Events in Interval Temporal Logic]

The following temporal relationships are supported:

```
- equal
- during
- contains
- overlaps
- overlapped
- after
- before
- starts
- finishes
- started
- finished
- follows
- precedes
```

:param extent: The temporal extent
:return: The name of the temporal relation or None if no relation
found

##### grass.temporal.AbsoluteTemporalExtent.union

```python
union(extent)
```

Creates a union with this temporal extent and the provided one.
Return a new temporal extent with the new start and end time.

:param extent: The temporal extent to create a union with
:return: The new temporal extent with start and end time,
or None in case the temporal extents are unrelated
(before or after)

.. code-block:: python

```
>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=4)
>>> inter = A.intersect(B)
>>> print(inter)
None

>>> A = TemporalExtent(start_time=5, end_time=8)
>>> B = TemporalExtent(start_time=3, end_time=None)
>>> inter = A.intersect(B)
>>> print(inter)
None
```

##### grass.temporal.AbsoluteTemporalExtent.update

```python
update(dbif=None, ident=None)
```

Serialize the content of this object and update it in the temporal
database using the internal identifier

Only object entries which are exists (not None) are updated

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming

##### grass.temporal.AbsoluteTemporalExtent.update_all

```python
update_all(dbif=None, ident=None)
```

Serialize the content of this object, including None objects,
and update it in the temporal database using the internal identifier

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming

#### grass.temporal.AbstractDataset

```python
AbstractDataset()
```

Bases: <code>[SpatialTopologyDatasetConnector](#grass.temporal.spatial_topology_dataset_connector.SpatialTopologyDatasetConnector)</code>, <code>[TemporalTopologyDatasetConnector](#grass.temporal.temporal_topology_dataset_connector.TemporalTopologyDatasetConnector)</code>

This is the base class for all datasets
(raster, vector, raster3d, strds, stvds, str3ds)

**Functions:**

- [**append_contain**](#grass.temporal.AbstractDataset.append_contain) – Append a map that this map spatially contains
- [**append_contains**](#grass.temporal.AbstractDataset.append_contains) – Append a map that this map temporally contains
- [**append_cover**](#grass.temporal.AbstractDataset.append_cover) – Append a map that spatially cover this map
- [**append_covered**](#grass.temporal.AbstractDataset.append_covered) – Append a map that is spatially covered by this map
- [**append_during**](#grass.temporal.AbstractDataset.append_during) – Append a map that this map is temporally located during
- [**append_equal**](#grass.temporal.AbstractDataset.append_equal) – Append a map with equivalent temporal extent as this map
- [**append_equivalent**](#grass.temporal.AbstractDataset.append_equivalent) – Append a map with equivalent spatial extent as this map
- [**append_finished**](#grass.temporal.AbstractDataset.append_finished) – Append a map that this map temporally finished with
- [**append_finishes**](#grass.temporal.AbstractDataset.append_finishes) – Append a map that this map temporally finishes with
- [**append_follows**](#grass.temporal.AbstractDataset.append_follows) – Append a map that this map temporally follows
- [**append_in**](#grass.temporal.AbstractDataset.append_in) – Append a map that this is spatial in this map
- [**append_meet**](#grass.temporal.AbstractDataset.append_meet) – Append a map that spatially meet with this map
- [**append_overlap**](#grass.temporal.AbstractDataset.append_overlap) – Append a map that this spatial overlap with this map
- [**append_overlapped**](#grass.temporal.AbstractDataset.append_overlapped) – Append a map that this map temporally overlapped
- [**append_overlaps**](#grass.temporal.AbstractDataset.append_overlaps) – Append a map that this map temporally overlaps
- [**append_precedes**](#grass.temporal.AbstractDataset.append_precedes) – Append a map that this map temporally precedes
- [**append_started**](#grass.temporal.AbstractDataset.append_started) – Append a map that this map temporally started with
- [**append_starts**](#grass.temporal.AbstractDataset.append_starts) – Append a map that this map temporally starts with
- [**check_relative_time_unit**](#grass.temporal.AbstractDataset.check_relative_time_unit) – Check if unit is of type year(s), month(s), day(s), hour(s),
- [**delete**](#grass.temporal.AbstractDataset.delete) – Delete dataset from database if it exists
- [**get_absolute_time**](#grass.temporal.AbstractDataset.get_absolute_time) – Returns the start time, the end
- [**get_contain**](#grass.temporal.AbstractDataset.get_contain) – Return a list of map objects that this map contains
- [**get_contains**](#grass.temporal.AbstractDataset.get_contains) – Return a list of map objects that this map temporally contains
- [**get_cover**](#grass.temporal.AbstractDataset.get_cover) – Return a list of map objects that spatially cover this map
- [**get_covered**](#grass.temporal.AbstractDataset.get_covered) – Return a list of map objects that are spatially covered by this map
- [**get_during**](#grass.temporal.AbstractDataset.get_during) – Return a list of map objects that this map is temporally located during
- [**get_equal**](#grass.temporal.AbstractDataset.get_equal) – Return a list of map objects with equivalent temporal extent as
- [**get_equivalent**](#grass.temporal.AbstractDataset.get_equivalent) – Return a list of map objects with equivalent spatial extent as this map
- [**get_finished**](#grass.temporal.AbstractDataset.get_finished) – Return a list of map objects that this map temporally finished with
- [**get_finishes**](#grass.temporal.AbstractDataset.get_finishes) – Return a list of map objects that this map temporally finishes with
- [**get_follows**](#grass.temporal.AbstractDataset.get_follows) – Return a list of map objects that this map temporally follows
- [**get_id**](#grass.temporal.AbstractDataset.get_id) – Return the unique identifier of the dataset
- [**get_in**](#grass.temporal.AbstractDataset.get_in) – Return a list of map objects that are spatial in this map
- [**get_mapset**](#grass.temporal.AbstractDataset.get_mapset) – Return the mapset
- [**get_meet**](#grass.temporal.AbstractDataset.get_meet) – Return a list of map objects that spatially meet with this map
- [**get_name**](#grass.temporal.AbstractDataset.get_name) – Return the name
- [**get_new_instance**](#grass.temporal.AbstractDataset.get_new_instance) – Return a new instance with the type of this class
- [**get_number_of_relations**](#grass.temporal.AbstractDataset.get_number_of_relations) – Return a dictionary in which the keys are the relation names and the
- [**get_number_of_spatial_relations**](#grass.temporal.AbstractDataset.get_number_of_spatial_relations) – Return a dictionary in which the keys are the relation names and the value
- [**get_number_of_temporal_relations**](#grass.temporal.AbstractDataset.get_number_of_temporal_relations) – Return a dictionary in which the keys are the relation names and
- [**get_overlap**](#grass.temporal.AbstractDataset.get_overlap) – Return a list of map objects that this map spatial overlap with
- [**get_overlapped**](#grass.temporal.AbstractDataset.get_overlapped) – Return a list of map objects that this map temporally overlapped
- [**get_overlaps**](#grass.temporal.AbstractDataset.get_overlaps) – Return a list of map objects that this map temporally overlaps
- [**get_precedes**](#grass.temporal.AbstractDataset.get_precedes) – Return a list of map objects that this map temporally precedes
- [**get_relative_time**](#grass.temporal.AbstractDataset.get_relative_time) – Returns the start time, the end
- [**get_relative_time_unit**](#grass.temporal.AbstractDataset.get_relative_time_unit) – Returns the relative time unit
- [**get_spatial_extent**](#grass.temporal.AbstractDataset.get_spatial_extent) – Return the spatial extent
- [**get_spatial_extent_as_tuple**](#grass.temporal.AbstractDataset.get_spatial_extent_as_tuple) – Return the spatial extent as tuple
- [**get_spatial_relations**](#grass.temporal.AbstractDataset.get_spatial_relations) – Return the dictionary of spatial relationships
- [**get_started**](#grass.temporal.AbstractDataset.get_started) – Return a list of map objects that this map temporally started with
- [**get_starts**](#grass.temporal.AbstractDataset.get_starts) – Return a list of map objects that this map temporally starts with
- [**get_temporal_extent**](#grass.temporal.AbstractDataset.get_temporal_extent) – Return the temporal extent of the correct internal type
- [**get_temporal_extent_as_tuple**](#grass.temporal.AbstractDataset.get_temporal_extent_as_tuple) – Returns a tuple of the valid start and end time
- [**get_temporal_relations**](#grass.temporal.AbstractDataset.get_temporal_relations) – Return the dictionary of temporal relationships
- [**get_temporal_type**](#grass.temporal.AbstractDataset.get_temporal_type) – Return the temporal type of this dataset
- [**get_type**](#grass.temporal.AbstractDataset.get_type) – Return the type of this class as string
- [**insert**](#grass.temporal.AbstractDataset.insert) – Insert dataset into database
- [**is_in_db**](#grass.temporal.AbstractDataset.is_in_db) – Check if the dataset is registered in the database
- [**is_spatial_topology_build**](#grass.temporal.AbstractDataset.is_spatial_topology_build) – Check if the temporal topology was build
- [**is_stds**](#grass.temporal.AbstractDataset.is_stds) – Return True if this class is a space time dataset
- [**is_temporal_topology_build**](#grass.temporal.AbstractDataset.is_temporal_topology_build) – Check if the temporal topology was build
- [**is_time_absolute**](#grass.temporal.AbstractDataset.is_time_absolute) – Return True in case the temporal type is absolute
- [**is_time_relative**](#grass.temporal.AbstractDataset.is_time_relative) – Return True in case the temporal type is relative
- [**is_topology_build**](#grass.temporal.AbstractDataset.is_topology_build) – Check if the spatial and temporal topology was build
- [**next**](#grass.temporal.AbstractDataset.next) – Return the map with a start time temporally located after
- [**prev**](#grass.temporal.AbstractDataset.prev) – Return the map with a start time temporally located before
- [**print_info**](#grass.temporal.AbstractDataset.print_info) – Print information about this class in human readable style
- [**print_self**](#grass.temporal.AbstractDataset.print_self) – Print the content of the internal structure to stdout
- [**print_shell_info**](#grass.temporal.AbstractDataset.print_shell_info) – Print information about this class in shell style
- [**print_spatial_topology_info**](#grass.temporal.AbstractDataset.print_spatial_topology_info) – Print information about this class in human readable style
- [**print_spatial_topology_shell_info**](#grass.temporal.AbstractDataset.print_spatial_topology_shell_info) – Print information about this class in shell style
- [**print_temporal_topology_info**](#grass.temporal.AbstractDataset.print_temporal_topology_info) – Print information about this class in human readable style
- [**print_temporal_topology_shell_info**](#grass.temporal.AbstractDataset.print_temporal_topology_shell_info) – Print information about this class in shell style
- [**print_topology_info**](#grass.temporal.AbstractDataset.print_topology_info) –
- [**print_topology_shell_info**](#grass.temporal.AbstractDataset.print_topology_shell_info) –
- [**reset**](#grass.temporal.AbstractDataset.reset) – Reset the internal structure and set the identifier
- [**reset_spatial_topology**](#grass.temporal.AbstractDataset.reset_spatial_topology) – Reset any information about temporal topology
- [**reset_temporal_topology**](#grass.temporal.AbstractDataset.reset_temporal_topology) – Reset any information about temporal topology
- [**reset_topology**](#grass.temporal.AbstractDataset.reset_topology) – Reset any information about temporal topology
- [**select**](#grass.temporal.AbstractDataset.select) – Select temporal dataset entry from database and fill
- [**set_id**](#grass.temporal.AbstractDataset.set_id) – Set the identifier of the dataset
- [**set_next**](#grass.temporal.AbstractDataset.set_next) – Set the map that is temporally as closest located after this map.
- [**set_prev**](#grass.temporal.AbstractDataset.set_prev) – Set the map that is temporally as closest located before this map.
- [**set_spatial_topology_build_false**](#grass.temporal.AbstractDataset.set_spatial_topology_build_false) – Same as name
- [**set_spatial_topology_build_true**](#grass.temporal.AbstractDataset.set_spatial_topology_build_true) – Same as name
- [**set_temporal_topology_build_false**](#grass.temporal.AbstractDataset.set_temporal_topology_build_false) – Same as name
- [**set_temporal_topology_build_true**](#grass.temporal.AbstractDataset.set_temporal_topology_build_true) – Same as name
- [**set_topology_build_false**](#grass.temporal.AbstractDataset.set_topology_build_false) – Use this method when the spatio-temporal topology was not build
- [**set_topology_build_true**](#grass.temporal.AbstractDataset.set_topology_build_true) – Use this method when the spatio-temporal topology was build
- [**spatial_disjoint_union**](#grass.temporal.AbstractDataset.spatial_disjoint_union) – Return the spatial union as spatial_extent object.
- [**spatial_intersection**](#grass.temporal.AbstractDataset.spatial_intersection) – Return the spatial intersection as spatial_extent
- [**spatial_overlapping**](#grass.temporal.AbstractDataset.spatial_overlapping) – Return True if the spatial extents overlap
- [**spatial_relation**](#grass.temporal.AbstractDataset.spatial_relation) – Return the spatial relationship between self and dataset
- [**spatial_union**](#grass.temporal.AbstractDataset.spatial_union) – Return the spatial union as spatial_extent
- [**temporal_disjoint_union**](#grass.temporal.AbstractDataset.temporal_disjoint_union) – Creates a union with the provided dataset and
- [**temporal_intersection**](#grass.temporal.AbstractDataset.temporal_intersection) – Intersect self with the provided dataset and
- [**temporal_relation**](#grass.temporal.AbstractDataset.temporal_relation) – Return the temporal relation of self and the provided dataset
- [**temporal_union**](#grass.temporal.AbstractDataset.temporal_union) – Creates a union with the provided dataset and
- [**update**](#grass.temporal.AbstractDataset.update) – Update the dataset entry in the database from the internal structure
- [**update_all**](#grass.temporal.AbstractDataset.update_all) – Update the dataset entry in the database from the internal structure

**Attributes:**

- [**contain**](#grass.temporal.AbstractDataset.contain) –
- [**contains**](#grass.temporal.AbstractDataset.contains) –
- [**cover**](#grass.temporal.AbstractDataset.cover) –
- [**covered**](#grass.temporal.AbstractDataset.covered) –
- [**during**](#grass.temporal.AbstractDataset.during) –
- [**equal**](#grass.temporal.AbstractDataset.equal) –
- [**equivalent**](#grass.temporal.AbstractDataset.equivalent) –
- [**finished**](#grass.temporal.AbstractDataset.finished) –
- [**finishes**](#grass.temporal.AbstractDataset.finishes) –
- [**follows**](#grass.temporal.AbstractDataset.follows) –
- [**in\_**](#grass.temporal.AbstractDataset.in_) –
- [**meet**](#grass.temporal.AbstractDataset.meet) –
- [**msgr**](#grass.temporal.AbstractDataset.msgr) –
- [**overlap**](#grass.temporal.AbstractDataset.overlap) –
- [**overlapped**](#grass.temporal.AbstractDataset.overlapped) –
- [**overlaps**](#grass.temporal.AbstractDataset.overlaps) –
- [**precedes**](#grass.temporal.AbstractDataset.precedes) –
- [**started**](#grass.temporal.AbstractDataset.started) –
- [**starts**](#grass.temporal.AbstractDataset.starts) –
- [**temporal_extent**](#grass.temporal.AbstractDataset.temporal_extent) –

##### grass.temporal.AbstractDataset.append_contain

```python
append_contain(map)
```

Append a map that this map spatially contains

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_contains

```python
append_contains(map)
```

Append a map that this map temporally contains
This includes temporal relationships started and finished

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_cover

```python
append_cover(map)
```

Append a map that spatially cover this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_covered

```python
append_covered(map)
```

Append a map that is spatially covered by this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_during

```python
append_during(map)
```

Append a map that this map is temporally located during
This includes temporal relationships starts and finishes

:param map: This object should be of type
AbstractMapDataset or derived classes

##### grass.temporal.AbstractDataset.append_equal

```python
append_equal(map)
```

Append a map with equivalent temporal extent as this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_equivalent

```python
append_equivalent(map)
```

Append a map with equivalent spatial extent as this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_finished

```python
append_finished(map)
```

Append a map that this map temporally finished with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_finishes

```python
append_finishes(map)
```

Append a map that this map temporally finishes with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_follows

```python
append_follows(map)
```

Append a map that this map temporally follows

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_in

```python
append_in(map)
```

Append a map that this is spatial in this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_meet

```python
append_meet(map)
```

Append a map that spatially meet with this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_overlap

```python
append_overlap(map)
```

Append a map that this spatial overlap with this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_overlapped

```python
append_overlapped(map)
```

Append a map that this map temporally overlapped

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_overlaps

```python
append_overlaps(map)
```

Append a map that this map temporally overlaps

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_precedes

```python
append_precedes(map)
```

Append a map that this map temporally precedes

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_started

```python
append_started(map)
```

Append a map that this map temporally started with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.append_starts

```python
append_starts(map)
```

Append a map that this map temporally starts with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.check_relative_time_unit

```python
check_relative_time_unit(unit)
```

Check if unit is of type year(s), month(s), day(s), hour(s),
minute(s) or second(s)

:param unit: The unit string
:return: True if success, False otherwise

##### grass.temporal.AbstractDataset.contain

```python
contain = property(fget=get_contain, fset=append_contain)
```

##### grass.temporal.AbstractDataset.contains

```python
contains = property(fget=get_contains, fset=append_contains)
```

##### grass.temporal.AbstractDataset.cover

```python
cover = property(fget=get_cover, fset=append_cover)
```

##### grass.temporal.AbstractDataset.covered

```python
covered = property(fget=get_covered, fset=append_covered)
```

##### grass.temporal.AbstractDataset.delete

```python
delete()
```

Delete dataset from database if it exists

##### grass.temporal.AbstractDataset.during

```python
during = property(fget=get_during, fset=append_during)
```

##### grass.temporal.AbstractDataset.equal

```python
equal = property(fget=get_equal, fset=append_equal)
```

##### grass.temporal.AbstractDataset.equivalent

```python
equivalent = property(fget=get_equivalent, fset=append_equivalent)
```

##### grass.temporal.AbstractDataset.finished

```python
finished = property(fget=get_finished, fset=append_finished)
```

##### grass.temporal.AbstractDataset.finishes

```python
finishes = property(fget=get_finishes, fset=append_finishes)
```

##### grass.temporal.AbstractDataset.follows

```python
follows = property(fget=get_follows, fset=append_follows)
```

##### grass.temporal.AbstractDataset.get_absolute_time

```python
get_absolute_time()
```

Returns the start time, the end
time of the map as tuple

The start time is of type datetime.

The end time is of type datetime in case of interval time,
or None on case of a time instance.

:return: A tuple of (start_time, end_time)

##### grass.temporal.AbstractDataset.get_contain

```python
get_contain()
```

Return a list of map objects that this map contains

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_contains

```python
get_contains()
```

Return a list of map objects that this map temporally contains
This includes temporal relationships started and finished

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_cover

```python
get_cover()
```

Return a list of map objects that spatially cover this map

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_covered

```python
get_covered()
```

Return a list of map objects that are spatially covered by this map

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_during

```python
get_during()
```

Return a list of map objects that this map is temporally located during
This includes temporally relationships starts and finishes

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_equal

```python
get_equal()
```

Return a list of map objects with equivalent temporal extent as
this map

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_equivalent

```python
get_equivalent()
```

Return a list of map objects with equivalent spatial extent as this map

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_finished

```python
get_finished()
```

Return a list of map objects that this map temporally finished with

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_finishes

```python
get_finishes()
```

Return a list of map objects that this map temporally finishes with

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_follows

```python
get_follows()
```

Return a list of map objects that this map temporally follows

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_id

```python
get_id()
```

Return the unique identifier of the dataset
:return: The id of the dataset "name(:layer)@mapset" as string

##### grass.temporal.AbstractDataset.get_in

```python
get_in()
```

Return a list of map objects that are spatial in this map

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_mapset

```python
get_mapset()
```

Return the mapset
:return: The mapset in which the dataset was created as string

##### grass.temporal.AbstractDataset.get_meet

```python
get_meet()
```

Return a list of map objects that spatially meet with this map

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_name

```python
get_name()
```

Return the name
:return: The name of the dataset as string

##### grass.temporal.AbstractDataset.get_new_instance

```python
get_new_instance(ident)
```

Return a new instance with the type of this class

:param ident: The identifier of the new dataset instance
:return: A new instance with the type of this object

##### grass.temporal.AbstractDataset.get_number_of_relations

```python
get_number_of_relations()
```

Return a dictionary in which the keys are the relation names and the
value are the number of relations.

The following relations are available:

Spatial relations:

```
- equivalent
- overlap
- in
- contain
- meet
- cover
- covered
```

Temporal relations:

```
- equal
- follows
- precedes
- overlaps
- overlapped
- during (including starts, finishes)
- contains (including started, finished)
- starts
- started
- finishes
- finished
```

To access topological information the spatial, temporal or booth
topologies must be build first using the SpatioTemporalTopologyBuilder.

:return: The dictionary with relations as keys and number as values or
None in case the topology wasn't built

##### grass.temporal.AbstractDataset.get_number_of_spatial_relations

```python
get_number_of_spatial_relations()
```

Return a dictionary in which the keys are the relation names and the value
are the number of relations.

The following relations are available:

- equivalent
- overlap
- in
- contain
- meet
- cover
- covered

To access topological information the spatial topology must be
build first using the SpatialTopologyBuilder.

:return: the dictionary with relations as keys and number as
values or None in case the topology wasn't build

##### grass.temporal.AbstractDataset.get_number_of_temporal_relations

```python
get_number_of_temporal_relations()
```

Return a dictionary in which the keys are the relation names and
the value are the number of relations.

The following relations are available:

- equal
- follows
- precedes
- overlaps
- overlapped
- during (including starts, finishes)
- contains (including started, finished)
- starts
- started
- finishes
- finished

To access topological information the temporal topology must be build
first using the SpatioTemporalTopologyBuilder.

:return: the dictionary with relations as keys and number as values
or None in case the topology wasn't build

##### grass.temporal.AbstractDataset.get_overlap

```python
get_overlap()
```

Return a list of map objects that this map spatial overlap with

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_overlapped

```python
get_overlapped()
```

Return a list of map objects that this map temporally overlapped

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_overlaps

```python
get_overlaps()
```

Return a list of map objects that this map temporally overlaps

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_precedes

```python
get_precedes()
```

Return a list of map objects that this map temporally precedes

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_relative_time

```python
get_relative_time()
```

Returns the start time, the end
time and the temporal unit of the dataset as tuple

The start time is of type integer.

The end time is of type integer in case of interval time,
or None on case of a time instance.

:return: A tuple of (start_time, end_time, unit)

##### grass.temporal.AbstractDataset.get_relative_time_unit

```python
get_relative_time_unit()
```

Returns the relative time unit
:return: The relative time unit as string, None if not present

##### grass.temporal.AbstractDataset.get_spatial_extent

```python
get_spatial_extent()
```

Return the spatial extent

##### grass.temporal.AbstractDataset.get_spatial_extent_as_tuple

```python
get_spatial_extent_as_tuple()
```

Return the spatial extent as tuple

Top and bottom are set to 0 in case of a two dimensional spatial
extent.

:return: A the spatial extent as tuple (north, south, east, west, top, bottom)

##### grass.temporal.AbstractDataset.get_spatial_relations

```python
get_spatial_relations()
```

Return the dictionary of spatial relationships

Keys are the spatial relationships in upper case,
values are abstract map objects.

:return: The spatial relations dictionary

##### grass.temporal.AbstractDataset.get_started

```python
get_started()
```

Return a list of map objects that this map temporally started with

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_starts

```python
get_starts()
```

Return a list of map objects that this map temporally starts with

:return: A list of map objects or None

##### grass.temporal.AbstractDataset.get_temporal_extent

```python
get_temporal_extent()
```

Return the temporal extent of the correct internal type

##### grass.temporal.AbstractDataset.get_temporal_extent_as_tuple

```python
get_temporal_extent_as_tuple()
```

Returns a tuple of the valid start and end time

Start and end time can be either of type datetime or of type
integer, depending on the temporal type.

:return: A tuple of (start_time, end_time)

##### grass.temporal.AbstractDataset.get_temporal_relations

```python
get_temporal_relations()
```

Return the dictionary of temporal relationships

Keys are the temporal relationships in upper case,
values are abstract map objects.

:return: The temporal relations dictionary

##### grass.temporal.AbstractDataset.get_temporal_type

```python
get_temporal_type()
```

Return the temporal type of this dataset

The temporal type can be absolute or relative

:return: The temporal type of the dataset as string

##### grass.temporal.AbstractDataset.get_type

```python
get_type()
```

Return the type of this class as string

The type can be "vector", "raster", "raster3d", "stvds", "strds" or "str3ds"

:return: "vector", "raster", "raster3d", "stvds", "strds" or "str3ds"

##### grass.temporal.AbstractDataset.in\_

```python
in_ = property(fget=get_in, fset=append_in)
```

##### grass.temporal.AbstractDataset.insert

```python
insert(dbif=None, execute=True)
```

Insert dataset into database

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are returned
and must be executed by the caller.
:return: The SQL insert statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractDataset.is_in_db

```python
is_in_db(dbif=None, mapset=None)
```

Check if the dataset is registered in the database

:param dbif: The database interface to be used
:param mapset: The dbif connection to be used
:return: True if the dataset is registered in the database

##### grass.temporal.AbstractDataset.is_spatial_topology_build

```python
is_spatial_topology_build()
```

Check if the temporal topology was build

##### grass.temporal.AbstractDataset.is_stds

```python
is_stds()
```

Return True if this class is a space time dataset

:return: True if this class is a space time dataset, False otherwise

##### grass.temporal.AbstractDataset.is_temporal_topology_build

```python
is_temporal_topology_build()
```

Check if the temporal topology was build

##### grass.temporal.AbstractDataset.is_time_absolute

```python
is_time_absolute()
```

Return True in case the temporal type is absolute

:return: True if temporal type is absolute, False otherwise

##### grass.temporal.AbstractDataset.is_time_relative

```python
is_time_relative()
```

Return True in case the temporal type is relative

:return: True if temporal type is relative, False otherwise

##### grass.temporal.AbstractDataset.is_topology_build

```python
is_topology_build()
```

Check if the spatial and temporal topology was build

:return: A dictionary with "spatial" and "temporal" as keys that
have boolean values

##### grass.temporal.AbstractDataset.meet

```python
meet = property(fget=get_meet, fset=append_meet)
```

##### grass.temporal.AbstractDataset.msgr

```python
msgr = get_tgis_message_interface()
```

##### grass.temporal.AbstractDataset.next

```python
next()
```

Return the map with a start time temporally located after
the start time of this map, but temporal closer than other maps

:return: A map object or None

##### grass.temporal.AbstractDataset.overlap

```python
overlap = property(fget=get_overlap, fset=append_overlap)
```

##### grass.temporal.AbstractDataset.overlapped

```python
overlapped = property(fget=get_overlapped, fset=append_overlapped)
```

##### grass.temporal.AbstractDataset.overlaps

```python
overlaps = property(fget=get_overlaps, fset=append_overlaps)
```

##### grass.temporal.AbstractDataset.precedes

```python
precedes = property(fget=get_precedes, fset=append_precedes)
```

##### grass.temporal.AbstractDataset.prev

```python
prev()
```

Return the map with a start time temporally located before
the start time of this map, but temporal closer than other maps

:return: A map object or None

##### grass.temporal.AbstractDataset.print_info

```python
print_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractDataset.print_self

```python
print_self()
```

Print the content of the internal structure to stdout

##### grass.temporal.AbstractDataset.print_shell_info

```python
print_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractDataset.print_spatial_topology_info

```python
print_spatial_topology_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractDataset.print_spatial_topology_shell_info

```python
print_spatial_topology_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractDataset.print_temporal_topology_info

```python
print_temporal_topology_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractDataset.print_temporal_topology_shell_info

```python
print_temporal_topology_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractDataset.print_topology_info

```python
print_topology_info()
```

##### grass.temporal.AbstractDataset.print_topology_shell_info

```python
print_topology_shell_info()
```

##### grass.temporal.AbstractDataset.reset

```python
reset(ident)
```

Reset the internal structure and set the identifier

This method creates the dataset specific internal objects
that store the base information, the spatial and temporal extent
and the metadata. It must be implemented in the dataset
specific subclasses. This is the code for the
vector dataset:

.. code-block:: python

```
 self.base = VectorBase(ident=ident)
 self.absolute_time = VectorAbsoluteTime(ident=ident)
 self.relative_time = VectorRelativeTime(ident=ident)
 self.spatial_extent = VectorSpatialExtent(ident=ident)
 self.metadata = VectorMetadata(ident=ident)
```

:param ident: The identifier of the dataset that "name@mapset" or
in case of vector maps "name:layer@mapset"

##### grass.temporal.AbstractDataset.reset_spatial_topology

```python
reset_spatial_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractDataset.reset_temporal_topology

```python
reset_temporal_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractDataset.reset_topology

```python
reset_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractDataset.select

```python
select(dbif=None, mapset=None)
```

Select temporal dataset entry from database and fill
the internal structure

The content of every dataset is stored in the temporal database.
This method must be used to fill this object with the content
from the temporal database.

:param dbif: The database interface to be used
:param mapset: The dbif connection to be used

##### grass.temporal.AbstractDataset.set_id

```python
set_id(ident)
```

Set the identifier of the dataset

##### grass.temporal.AbstractDataset.set_next

```python
set_next(map)
```

Set the map that is temporally as closest located after this map.

Temporally located means that the start time of the "next" map is
temporally located AFTER the start time of this map, but temporally
near than other maps of the same dataset.

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.set_prev

```python
set_prev(map)
```

Set the map that is temporally as closest located before this map.

Temporally located means that the start time of the "previous" map
is temporally located BEFORE the start time of this map, but
temporally near than other maps of the same dataset.

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractDataset.set_spatial_topology_build_false

```python
set_spatial_topology_build_false()
```

Same as name

##### grass.temporal.AbstractDataset.set_spatial_topology_build_true

```python
set_spatial_topology_build_true()
```

Same as name

##### grass.temporal.AbstractDataset.set_temporal_topology_build_false

```python
set_temporal_topology_build_false()
```

Same as name

##### grass.temporal.AbstractDataset.set_temporal_topology_build_true

```python
set_temporal_topology_build_true()
```

Same as name

##### grass.temporal.AbstractDataset.set_topology_build_false

```python
set_topology_build_false()
```

Use this method when the spatio-temporal topology was not build

##### grass.temporal.AbstractDataset.set_topology_build_true

```python
set_topology_build_true()
```

Use this method when the spatio-temporal topology was build

##### grass.temporal.AbstractDataset.spatial_disjoint_union

```python
spatial_disjoint_union(dataset)
```

Return the spatial union as spatial_extent object.

:param dataset: The abstract dataset to create a union with
:return: The union spatial extent

##### grass.temporal.AbstractDataset.spatial_intersection

```python
spatial_intersection(dataset)
```

Return the spatial intersection as spatial_extent
object or None in case no intersection was found.

:param dataset: The abstract dataset to intersect with
:return: The intersection spatial extent

##### grass.temporal.AbstractDataset.spatial_overlapping

```python
spatial_overlapping(dataset)
```

Return True if the spatial extents overlap

:param dataset: The abstract dataset to check spatial overlapping
:return: True if self and the provided dataset spatial overlap

##### grass.temporal.AbstractDataset.spatial_relation

```python
spatial_relation(dataset)
```

Return the spatial relationship between self and dataset

:param dataset: The abstract dataset to compute the spatial
relation with self
:return: The spatial relationship as string

##### grass.temporal.AbstractDataset.spatial_union

```python
spatial_union(dataset)
```

Return the spatial union as spatial_extent
object or None in case the extents does not overlap or meet.

:param dataset: The abstract dataset to create a union with
:return: The union spatial extent

##### grass.temporal.AbstractDataset.started

```python
started = property(fget=get_started, fset=append_started)
```

##### grass.temporal.AbstractDataset.starts

```python
starts = property(fget=get_starts, fset=append_starts)
```

##### grass.temporal.AbstractDataset.temporal_disjoint_union

```python
temporal_disjoint_union(dataset)
```

Creates a union with the provided dataset and
return a new temporal extent with the new start and end time.

:param dataset: The abstract dataset to create temporal union with
:return: The new temporal extent with start and end time

##### grass.temporal.AbstractDataset.temporal_extent

```python
temporal_extent = property(fget=get_temporal_extent)
```

##### grass.temporal.AbstractDataset.temporal_intersection

```python
temporal_intersection(dataset)
```

Intersect self with the provided dataset and
return a new temporal extent with the new start and end time

:param dataset: The abstract dataset to temporal intersect with
:return: The new temporal extent with start and end time,
or None in case of no intersection

##### grass.temporal.AbstractDataset.temporal_relation

```python
temporal_relation(dataset)
```

Return the temporal relation of self and the provided dataset

:return: The temporal relation as string

##### grass.temporal.AbstractDataset.temporal_union

```python
temporal_union(dataset)
```

Creates a union with the provided dataset and
return a new temporal extent with the new start and end time.

:param dataset: The abstract dataset to create temporal union with
:return: The new temporal extent with start and end time,
or None in case of no intersection

##### grass.temporal.AbstractDataset.update

```python
update(dbif=None, execute=True, ident=None)
```

Update the dataset entry in the database from the internal structure
excluding None variables

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are returned
and must be executed by the caller.
:param ident: The identifier to be updated, useful for renaming
:return: The SQL update statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractDataset.update_all

```python
update_all(dbif=None, execute=True, ident=None)
```

Update the dataset entry in the database from the internal structure
and include None variables.

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are returned
and must be executed by the caller.
:param ident: The identifier to be updated, useful for renaming
:return: The SQL update statement in case execute=False, or an
empty string otherwise

#### grass.temporal.AbstractDatasetComparisonKeyEndTime

```python
AbstractDatasetComparisonKeyEndTime(obj, *args)
```

This comparison key can be used to sort lists of abstract datasets
by end time

Example:

.. code-block:: python

```
 # Return all maps in a space time raster dataset as map objects
 map_list = strds.get_registered_maps_as_objects()

 # Sort the maps in the list by end time
 sorted_map_list = sorted(map_list, key=AbstractDatasetComparisonKeyEndTime)
```

**Attributes:**

- [**obj**](#grass.temporal.AbstractDatasetComparisonKeyEndTime.obj) –

##### grass.temporal.AbstractDatasetComparisonKeyEndTime.obj

```python
obj = obj
```

#### grass.temporal.AbstractDatasetComparisonKeyStartTime

```python
AbstractDatasetComparisonKeyStartTime(obj, *args)
```

This comparison key can be used to sort lists of abstract datasets
by start time

Example:

.. code-block:: python

```
 # Return all maps in a space time raster dataset as map objects
 map_list = strds.get_registered_maps_as_objects()

 # Sort the maps in the list by start time
 sorted_map_list = sorted(map_list, key=AbstractDatasetComparisonKeyStartTime)
```

**Attributes:**

- [**obj**](#grass.temporal.AbstractDatasetComparisonKeyStartTime.obj) –

##### grass.temporal.AbstractDatasetComparisonKeyStartTime.obj

```python
obj = obj
```

#### grass.temporal.AbstractMapDataset

```python
AbstractMapDataset()
```

Bases: <code>[AbstractDataset](#grass.temporal.abstract_dataset.AbstractDataset)</code>

This is the base class for all maps (raster, vector, raster3d).

The temporal extent, the spatial extent and the metadata of maps
are stored in the temporal database. Maps can be registered in the
temporal database, updated and deleted.

This class provides all functionalities that are needed to manage maps
in the temporal database. That are:

- insert() to register the map and therefore its spatio-temporal extent
  and metadata in the temporal database
- update() to update the map spatio-temporal extent and metadata in the
  temporal database
- unregister() to unregister the map from each space time dataset in
  which this map is registered
- delete() to remove the map from the temporal database
- Methods to set relative and absolute time stamps
- Abstract methods that must be implemented in the map specific
  subclasses

**Functions:**

- [**add_stds_to_register**](#grass.temporal.AbstractMapDataset.add_stds_to_register) – Add a new space time dataset to the register
- [**append_contain**](#grass.temporal.AbstractMapDataset.append_contain) – Append a map that this map spatially contains
- [**append_contains**](#grass.temporal.AbstractMapDataset.append_contains) – Append a map that this map temporally contains
- [**append_cover**](#grass.temporal.AbstractMapDataset.append_cover) – Append a map that spatially cover this map
- [**append_covered**](#grass.temporal.AbstractMapDataset.append_covered) – Append a map that is spatially covered by this map
- [**append_during**](#grass.temporal.AbstractMapDataset.append_during) – Append a map that this map is temporally located during
- [**append_equal**](#grass.temporal.AbstractMapDataset.append_equal) – Append a map with equivalent temporal extent as this map
- [**append_equivalent**](#grass.temporal.AbstractMapDataset.append_equivalent) – Append a map with equivalent spatial extent as this map
- [**append_finished**](#grass.temporal.AbstractMapDataset.append_finished) – Append a map that this map temporally finished with
- [**append_finishes**](#grass.temporal.AbstractMapDataset.append_finishes) – Append a map that this map temporally finishes with
- [**append_follows**](#grass.temporal.AbstractMapDataset.append_follows) – Append a map that this map temporally follows
- [**append_in**](#grass.temporal.AbstractMapDataset.append_in) – Append a map that this is spatial in this map
- [**append_meet**](#grass.temporal.AbstractMapDataset.append_meet) – Append a map that spatially meet with this map
- [**append_overlap**](#grass.temporal.AbstractMapDataset.append_overlap) – Append a map that this spatial overlap with this map
- [**append_overlapped**](#grass.temporal.AbstractMapDataset.append_overlapped) – Append a map that this map temporally overlapped
- [**append_overlaps**](#grass.temporal.AbstractMapDataset.append_overlaps) – Append a map that this map temporally overlaps
- [**append_precedes**](#grass.temporal.AbstractMapDataset.append_precedes) – Append a map that this map temporally precedes
- [**append_started**](#grass.temporal.AbstractMapDataset.append_started) – Append a map that this map temporally started with
- [**append_starts**](#grass.temporal.AbstractMapDataset.append_starts) – Append a map that this map temporally starts with
- [**build_id**](#grass.temporal.AbstractMapDataset.build_id) – Convenient method to build the unique identifier
- [**build_id_from_search_path**](#grass.temporal.AbstractMapDataset.build_id_from_search_path) – Convenient method to build the unique identifier while
- [**check_for_correct_time**](#grass.temporal.AbstractMapDataset.check_for_correct_time) – Check for correct time
- [**check_relative_time_unit**](#grass.temporal.AbstractMapDataset.check_relative_time_unit) – Check if unit is of type year(s), month(s), day(s), hour(s),
- [**check_resolution_with_current_region**](#grass.temporal.AbstractMapDataset.check_resolution_with_current_region) – Check if the raster or voxel resolution is
- [**delete**](#grass.temporal.AbstractMapDataset.delete) – Delete a map entry from database if it exists
- [**get_absolute_time**](#grass.temporal.AbstractMapDataset.get_absolute_time) – Returns the start time, the end
- [**get_contain**](#grass.temporal.AbstractMapDataset.get_contain) – Return a list of map objects that this map contains
- [**get_contains**](#grass.temporal.AbstractMapDataset.get_contains) – Return a list of map objects that this map temporally contains
- [**get_cover**](#grass.temporal.AbstractMapDataset.get_cover) – Return a list of map objects that spatially cover this map
- [**get_covered**](#grass.temporal.AbstractMapDataset.get_covered) – Return a list of map objects that are spatially covered by this map
- [**get_during**](#grass.temporal.AbstractMapDataset.get_during) – Return a list of map objects that this map is temporally located during
- [**get_equal**](#grass.temporal.AbstractMapDataset.get_equal) – Return a list of map objects with equivalent temporal extent as
- [**get_equivalent**](#grass.temporal.AbstractMapDataset.get_equivalent) – Return a list of map objects with equivalent spatial extent as this map
- [**get_finished**](#grass.temporal.AbstractMapDataset.get_finished) – Return a list of map objects that this map temporally finished with
- [**get_finishes**](#grass.temporal.AbstractMapDataset.get_finishes) – Return a list of map objects that this map temporally finishes with
- [**get_follows**](#grass.temporal.AbstractMapDataset.get_follows) – Return a list of map objects that this map temporally follows
- [**get_id**](#grass.temporal.AbstractMapDataset.get_id) – Return the unique identifier of the dataset
- [**get_in**](#grass.temporal.AbstractMapDataset.get_in) – Return a list of map objects that are spatial in this map
- [**get_layer**](#grass.temporal.AbstractMapDataset.get_layer) – Return the layer of the map
- [**get_map_id**](#grass.temporal.AbstractMapDataset.get_map_id) – Return the map id. The map id is the unique identifier
- [**get_mapset**](#grass.temporal.AbstractMapDataset.get_mapset) – Return the mapset
- [**get_meet**](#grass.temporal.AbstractMapDataset.get_meet) – Return a list of map objects that spatially meet with this map
- [**get_name**](#grass.temporal.AbstractMapDataset.get_name) – Return the name
- [**get_new_instance**](#grass.temporal.AbstractMapDataset.get_new_instance) – Return a new instance with the type of this class
- [**get_new_stds_instance**](#grass.temporal.AbstractMapDataset.get_new_stds_instance) – Return a new space time dataset instance that store maps with the
- [**get_number_of_relations**](#grass.temporal.AbstractMapDataset.get_number_of_relations) – Return a dictionary in which the keys are the relation names and the
- [**get_number_of_spatial_relations**](#grass.temporal.AbstractMapDataset.get_number_of_spatial_relations) – Return a dictionary in which the keys are the relation names and the value
- [**get_number_of_temporal_relations**](#grass.temporal.AbstractMapDataset.get_number_of_temporal_relations) – Return a dictionary in which the keys are the relation names and
- [**get_overlap**](#grass.temporal.AbstractMapDataset.get_overlap) – Return a list of map objects that this map spatial overlap with
- [**get_overlapped**](#grass.temporal.AbstractMapDataset.get_overlapped) – Return a list of map objects that this map temporally overlapped
- [**get_overlaps**](#grass.temporal.AbstractMapDataset.get_overlaps) – Return a list of map objects that this map temporally overlaps
- [**get_precedes**](#grass.temporal.AbstractMapDataset.get_precedes) – Return a list of map objects that this map temporally precedes
- [**get_registered_stds**](#grass.temporal.AbstractMapDataset.get_registered_stds) – Return all space time dataset ids in which this map is registered
- [**get_relative_time**](#grass.temporal.AbstractMapDataset.get_relative_time) – Returns the start time, the end
- [**get_relative_time_unit**](#grass.temporal.AbstractMapDataset.get_relative_time_unit) – Returns the relative time unit
- [**get_spatial_extent**](#grass.temporal.AbstractMapDataset.get_spatial_extent) – Return the spatial extent
- [**get_spatial_extent_as_tuple**](#grass.temporal.AbstractMapDataset.get_spatial_extent_as_tuple) – Return the spatial extent as tuple
- [**get_spatial_relations**](#grass.temporal.AbstractMapDataset.get_spatial_relations) – Return the dictionary of spatial relationships
- [**get_started**](#grass.temporal.AbstractMapDataset.get_started) – Return a list of map objects that this map temporally started with
- [**get_starts**](#grass.temporal.AbstractMapDataset.get_starts) – Return a list of map objects that this map temporally starts with
- [**get_temporal_extent**](#grass.temporal.AbstractMapDataset.get_temporal_extent) – Return the temporal extent of the correct internal type
- [**get_temporal_extent_as_tuple**](#grass.temporal.AbstractMapDataset.get_temporal_extent_as_tuple) – Returns a tuple of the valid start and end time
- [**get_temporal_relations**](#grass.temporal.AbstractMapDataset.get_temporal_relations) – Return the dictionary of temporal relationships
- [**get_temporal_type**](#grass.temporal.AbstractMapDataset.get_temporal_type) – Return the temporal type of this dataset
- [**get_type**](#grass.temporal.AbstractMapDataset.get_type) – Return the type of this class as string
- [**has_grass_timestamp**](#grass.temporal.AbstractMapDataset.has_grass_timestamp) – Check if a grass file based time stamp exists for this map.
- [**insert**](#grass.temporal.AbstractMapDataset.insert) – Insert the map content into the database from the internal
- [**is_in_db**](#grass.temporal.AbstractMapDataset.is_in_db) – Check if the dataset is registered in the database
- [**is_spatial_topology_build**](#grass.temporal.AbstractMapDataset.is_spatial_topology_build) – Check if the temporal topology was build
- [**is_stds**](#grass.temporal.AbstractMapDataset.is_stds) – Return True if this class is a space time dataset
- [**is_temporal_topology_build**](#grass.temporal.AbstractMapDataset.is_temporal_topology_build) – Check if the temporal topology was build
- [**is_time_absolute**](#grass.temporal.AbstractMapDataset.is_time_absolute) – Return True in case the temporal type is absolute
- [**is_time_relative**](#grass.temporal.AbstractMapDataset.is_time_relative) – Return True in case the temporal type is relative
- [**is_topology_build**](#grass.temporal.AbstractMapDataset.is_topology_build) – Check if the spatial and temporal topology was build
- [**load**](#grass.temporal.AbstractMapDataset.load) – Load the content of this object from the grass
- [**map_exists**](#grass.temporal.AbstractMapDataset.map_exists) – Return True in case the map exists in the grass spatial database
- [**next**](#grass.temporal.AbstractMapDataset.next) – Return the map with a start time temporally located after
- [**prev**](#grass.temporal.AbstractMapDataset.prev) – Return the map with a start time temporally located before
- [**print_info**](#grass.temporal.AbstractMapDataset.print_info) – Print information about this object in human readable style
- [**print_self**](#grass.temporal.AbstractMapDataset.print_self) – Print the content of the internal structure to stdout
- [**print_shell_info**](#grass.temporal.AbstractMapDataset.print_shell_info) – Print information about this object in shell style
- [**print_spatial_topology_info**](#grass.temporal.AbstractMapDataset.print_spatial_topology_info) – Print information about this class in human readable style
- [**print_spatial_topology_shell_info**](#grass.temporal.AbstractMapDataset.print_spatial_topology_shell_info) – Print information about this class in shell style
- [**print_temporal_topology_info**](#grass.temporal.AbstractMapDataset.print_temporal_topology_info) – Print information about this class in human readable style
- [**print_temporal_topology_shell_info**](#grass.temporal.AbstractMapDataset.print_temporal_topology_shell_info) – Print information about this class in shell style
- [**print_topology_info**](#grass.temporal.AbstractMapDataset.print_topology_info) –
- [**print_topology_shell_info**](#grass.temporal.AbstractMapDataset.print_topology_shell_info) –
- [**read_semantic_label_from_grass**](#grass.temporal.AbstractMapDataset.read_semantic_label_from_grass) – Read the band identifier of this map from the map metadata
- [**read_timestamp_from_grass**](#grass.temporal.AbstractMapDataset.read_timestamp_from_grass) – Read the timestamp of this map from the map metadata
- [**remove_stds_from_register**](#grass.temporal.AbstractMapDataset.remove_stds_from_register) – Remove a space time dataset from the register
- [**remove_timestamp_from_grass**](#grass.temporal.AbstractMapDataset.remove_timestamp_from_grass) – Remove the timestamp from the grass file
- [**reset**](#grass.temporal.AbstractMapDataset.reset) – Reset the internal structure and set the identifier
- [**reset_spatial_topology**](#grass.temporal.AbstractMapDataset.reset_spatial_topology) – Reset any information about temporal topology
- [**reset_temporal_topology**](#grass.temporal.AbstractMapDataset.reset_temporal_topology) – Reset any information about temporal topology
- [**reset_topology**](#grass.temporal.AbstractMapDataset.reset_topology) – Reset any information about temporal topology
- [**select**](#grass.temporal.AbstractMapDataset.select) – Select temporal dataset entry from database and fill
- [**set_absolute_time**](#grass.temporal.AbstractMapDataset.set_absolute_time) – Set the absolute time with start time and end time
- [**set_id**](#grass.temporal.AbstractMapDataset.set_id) – Set the identifier of the dataset
- [**set_next**](#grass.temporal.AbstractMapDataset.set_next) – Set the map that is temporally as closest located after this map.
- [**set_prev**](#grass.temporal.AbstractMapDataset.set_prev) – Set the map that is temporally as closest located before this map.
- [**set_relative_time**](#grass.temporal.AbstractMapDataset.set_relative_time) – Set the relative time interval
- [**set_semantic_label**](#grass.temporal.AbstractMapDataset.set_semantic_label) – Set semantic label identifier
- [**set_spatial_extent**](#grass.temporal.AbstractMapDataset.set_spatial_extent) – Set the spatial extent of the map
- [**set_spatial_extent_from_values**](#grass.temporal.AbstractMapDataset.set_spatial_extent_from_values) – Set the spatial extent of the map from values
- [**set_spatial_topology_build_false**](#grass.temporal.AbstractMapDataset.set_spatial_topology_build_false) – Same as name
- [**set_spatial_topology_build_true**](#grass.temporal.AbstractMapDataset.set_spatial_topology_build_true) – Same as name
- [**set_temporal_extent**](#grass.temporal.AbstractMapDataset.set_temporal_extent) – Convenient method to set the temporal extent from a temporal extent
- [**set_temporal_topology_build_false**](#grass.temporal.AbstractMapDataset.set_temporal_topology_build_false) – Same as name
- [**set_temporal_topology_build_true**](#grass.temporal.AbstractMapDataset.set_temporal_topology_build_true) – Same as name
- [**set_time_to_absolute**](#grass.temporal.AbstractMapDataset.set_time_to_absolute) – Set the temporal type to absolute
- [**set_time_to_relative**](#grass.temporal.AbstractMapDataset.set_time_to_relative) – Set the temporal type to relative
- [**set_topology_build_false**](#grass.temporal.AbstractMapDataset.set_topology_build_false) – Use this method when the spatio-temporal topology was not build
- [**set_topology_build_true**](#grass.temporal.AbstractMapDataset.set_topology_build_true) – Use this method when the spatio-temporal topology was build
- [**spatial_buffer**](#grass.temporal.AbstractMapDataset.spatial_buffer) – Buffer the spatial extent by a given size in all
- [**spatial_buffer_2d**](#grass.temporal.AbstractMapDataset.spatial_buffer_2d) – Buffer the spatial extent by a given size in 2d
- [**spatial_disjoint_union**](#grass.temporal.AbstractMapDataset.spatial_disjoint_union) – Return the spatial union as spatial_extent object.
- [**spatial_intersection**](#grass.temporal.AbstractMapDataset.spatial_intersection) – Return the spatial intersection as spatial_extent
- [**spatial_overlapping**](#grass.temporal.AbstractMapDataset.spatial_overlapping) – Return True if the spatial extents overlap
- [**spatial_relation**](#grass.temporal.AbstractMapDataset.spatial_relation) – Return the spatial relationship between self and dataset
- [**spatial_union**](#grass.temporal.AbstractMapDataset.spatial_union) – Return the spatial union as spatial_extent
- [**split_name**](#grass.temporal.AbstractMapDataset.split_name) – Convenient method to split a map name into three potentially
- [**temporal_buffer**](#grass.temporal.AbstractMapDataset.temporal_buffer) – Create a temporal buffer based on an increment
- [**temporal_disjoint_union**](#grass.temporal.AbstractMapDataset.temporal_disjoint_union) – Creates a union with the provided dataset and
- [**temporal_intersection**](#grass.temporal.AbstractMapDataset.temporal_intersection) – Intersect self with the provided dataset and
- [**temporal_relation**](#grass.temporal.AbstractMapDataset.temporal_relation) – Return the temporal relation of self and the provided dataset
- [**temporal_union**](#grass.temporal.AbstractMapDataset.temporal_union) – Creates a union with the provided dataset and
- [**unregister**](#grass.temporal.AbstractMapDataset.unregister) – Remove the map entry in each space time dataset in which this map
- [**update**](#grass.temporal.AbstractMapDataset.update) – Update the map content in the database from the internal structure
- [**update_absolute_time**](#grass.temporal.AbstractMapDataset.update_absolute_time) – Update the absolute time
- [**update_all**](#grass.temporal.AbstractMapDataset.update_all) – Update the map content in the database from the internal structure
- [**update_relative_time**](#grass.temporal.AbstractMapDataset.update_relative_time) – Update the relative time interval
- [**write_timestamp_to_grass**](#grass.temporal.AbstractMapDataset.write_timestamp_to_grass) – Write the timestamp of this map into the map metadata

**Attributes:**

- [**ciface**](#grass.temporal.AbstractMapDataset.ciface) –
- [**contain**](#grass.temporal.AbstractMapDataset.contain) –
- [**contains**](#grass.temporal.AbstractMapDataset.contains) –
- [**cover**](#grass.temporal.AbstractMapDataset.cover) –
- [**covered**](#grass.temporal.AbstractMapDataset.covered) –
- [**during**](#grass.temporal.AbstractMapDataset.during) –
- [**equal**](#grass.temporal.AbstractMapDataset.equal) –
- [**equivalent**](#grass.temporal.AbstractMapDataset.equivalent) –
- [**finished**](#grass.temporal.AbstractMapDataset.finished) –
- [**finishes**](#grass.temporal.AbstractMapDataset.finishes) –
- [**follows**](#grass.temporal.AbstractMapDataset.follows) –
- [**in\_**](#grass.temporal.AbstractMapDataset.in_) –
- [**meet**](#grass.temporal.AbstractMapDataset.meet) –
- [**msgr**](#grass.temporal.AbstractMapDataset.msgr) –
- [**overlap**](#grass.temporal.AbstractMapDataset.overlap) –
- [**overlapped**](#grass.temporal.AbstractMapDataset.overlapped) –
- [**overlaps**](#grass.temporal.AbstractMapDataset.overlaps) –
- [**precedes**](#grass.temporal.AbstractMapDataset.precedes) –
- [**started**](#grass.temporal.AbstractMapDataset.started) –
- [**starts**](#grass.temporal.AbstractMapDataset.starts) –
- [**temporal_extent**](#grass.temporal.AbstractMapDataset.temporal_extent) –

##### grass.temporal.AbstractMapDataset.add_stds_to_register

```python
add_stds_to_register(stds_id, dbif=None, execute=True)
```

Add a new space time dataset to the register

:param stds_id: The id of the space time dataset to be registered
:param dbif: The database interface to be used
:param execute: If True the SQL INSERT table statements
will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.

:return: The SQL statements if execute=False, else an empty string

##### grass.temporal.AbstractMapDataset.append_contain

```python
append_contain(map)
```

Append a map that this map spatially contains

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_contains

```python
append_contains(map)
```

Append a map that this map temporally contains
This includes temporal relationships started and finished

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_cover

```python
append_cover(map)
```

Append a map that spatially cover this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_covered

```python
append_covered(map)
```

Append a map that is spatially covered by this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_during

```python
append_during(map)
```

Append a map that this map is temporally located during
This includes temporal relationships starts and finishes

:param map: This object should be of type
AbstractMapDataset or derived classes

##### grass.temporal.AbstractMapDataset.append_equal

```python
append_equal(map)
```

Append a map with equivalent temporal extent as this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_equivalent

```python
append_equivalent(map)
```

Append a map with equivalent spatial extent as this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_finished

```python
append_finished(map)
```

Append a map that this map temporally finished with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_finishes

```python
append_finishes(map)
```

Append a map that this map temporally finishes with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_follows

```python
append_follows(map)
```

Append a map that this map temporally follows

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_in

```python
append_in(map)
```

Append a map that this is spatial in this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_meet

```python
append_meet(map)
```

Append a map that spatially meet with this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_overlap

```python
append_overlap(map)
```

Append a map that this spatial overlap with this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_overlapped

```python
append_overlapped(map)
```

Append a map that this map temporally overlapped

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_overlaps

```python
append_overlaps(map)
```

Append a map that this map temporally overlaps

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_precedes

```python
append_precedes(map)
```

Append a map that this map temporally precedes

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_started

```python
append_started(map)
```

Append a map that this map temporally started with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.append_starts

```python
append_starts(map)
```

Append a map that this map temporally starts with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.build_id

```python
build_id(name, mapset, layer=None)
```

Convenient method to build the unique identifier

Existing layer and mapset definitions in the name
string will be reused

:param name: The name of the map
:param mapset: The mapset in which the map is located
:param layer: The layer of the vector map, use None in case no layer exists

:return: the id of the map as "name(:layer)@mapset" where layer is optional

##### grass.temporal.AbstractMapDataset.build_id_from_search_path

```python
build_id_from_search_path(name, element)
```

Convenient method to build the unique identifier while
checking the current search path for the correct mapset.

Existing mapset definitions in the name string will be reused.

If an element type is given and the mapset is not specified in
the name, the function will try to get the correct mapset by
searching for a map with the given name and of the given element
type on the current search path. If the combination is not found
on the current search path, it will fail and throw an error.

:param name: The name of the map
:param element: A mapset element type to be passed to g.findfile,
e.g. "cell", "vector", "raster3d"

:return: the id of the map as "name(:layer)@mapset" where layer is
optional

##### grass.temporal.AbstractMapDataset.check_for_correct_time

```python
check_for_correct_time()
```

Check for correct time

:return: True in case of success, False otherwise

##### grass.temporal.AbstractMapDataset.check_relative_time_unit

```python
check_relative_time_unit(unit)
```

Check if unit is of type year(s), month(s), day(s), hour(s),
minute(s) or second(s)

:param unit: The unit string
:return: True if success, False otherwise

##### grass.temporal.AbstractMapDataset.check_resolution_with_current_region

```python
check_resolution_with_current_region()
```

Check if the raster or voxel resolution is
finer than the current resolution

- Return "finer" in case the raster/voxel resolution is finer
  than the current region
- Return "coarser" in case the raster/voxel resolution is coarser
  than the current region

Vector maps have no resolution, since they store the coordinates
directly.

:return: "finer" or "coarser"

##### grass.temporal.AbstractMapDataset.ciface

```python
ciface = get_tgis_c_library_interface()
```

##### grass.temporal.AbstractMapDataset.contain

```python
contain = property(fget=get_contain, fset=append_contain)
```

##### grass.temporal.AbstractMapDataset.contains

```python
contains = property(fget=get_contains, fset=append_contains)
```

##### grass.temporal.AbstractMapDataset.cover

```python
cover = property(fget=get_cover, fset=append_cover)
```

##### grass.temporal.AbstractMapDataset.covered

```python
covered = property(fget=get_covered, fset=append_covered)
```

##### grass.temporal.AbstractMapDataset.delete

```python
delete(dbif=None, update=True, execute=True)
```

Delete a map entry from database if it exists

Remove dependent entries:

- Remove the map entry in each space time dataset in which this map
  is registered
- Remove the space time dataset register table

:param dbif: The database interface to be used
:param update: Call for each unregister statement the update from
registered maps of the space time dataset.
This can slow down the un-registration process
significantly.
:param execute: If True the SQL DELETE and DROP table statements
will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.

:return: The SQL statements if execute=False, else an empty string,
None in case of a failure

##### grass.temporal.AbstractMapDataset.during

```python
during = property(fget=get_during, fset=append_during)
```

##### grass.temporal.AbstractMapDataset.equal

```python
equal = property(fget=get_equal, fset=append_equal)
```

##### grass.temporal.AbstractMapDataset.equivalent

```python
equivalent = property(fget=get_equivalent, fset=append_equivalent)
```

##### grass.temporal.AbstractMapDataset.finished

```python
finished = property(fget=get_finished, fset=append_finished)
```

##### grass.temporal.AbstractMapDataset.finishes

```python
finishes = property(fget=get_finishes, fset=append_finishes)
```

##### grass.temporal.AbstractMapDataset.follows

```python
follows = property(fget=get_follows, fset=append_follows)
```

##### grass.temporal.AbstractMapDataset.get_absolute_time

```python
get_absolute_time()
```

Returns the start time, the end
time of the map as tuple

The start time is of type datetime.

The end time is of type datetime in case of interval time,
or None on case of a time instance.

:return: A tuple of (start_time, end_time)

##### grass.temporal.AbstractMapDataset.get_contain

```python
get_contain()
```

Return a list of map objects that this map contains

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_contains

```python
get_contains()
```

Return a list of map objects that this map temporally contains
This includes temporal relationships started and finished

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_cover

```python
get_cover()
```

Return a list of map objects that spatially cover this map

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_covered

```python
get_covered()
```

Return a list of map objects that are spatially covered by this map

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_during

```python
get_during()
```

Return a list of map objects that this map is temporally located during
This includes temporally relationships starts and finishes

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_equal

```python
get_equal()
```

Return a list of map objects with equivalent temporal extent as
this map

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_equivalent

```python
get_equivalent()
```

Return a list of map objects with equivalent spatial extent as this map

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_finished

```python
get_finished()
```

Return a list of map objects that this map temporally finished with

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_finishes

```python
get_finishes()
```

Return a list of map objects that this map temporally finishes with

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_follows

```python
get_follows()
```

Return a list of map objects that this map temporally follows

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_id

```python
get_id()
```

Return the unique identifier of the dataset
:return: The id of the dataset "name(:layer)@mapset" as string

##### grass.temporal.AbstractMapDataset.get_in

```python
get_in()
```

Return a list of map objects that are spatial in this map

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_layer

```python
get_layer()
```

Return the layer of the map

:return: the layer of the map or None in case no layer is defined

##### grass.temporal.AbstractMapDataset.get_map_id

```python
get_map_id()
```

Return the map id. The map id is the unique identifier
in grass and must not be equal to the
primary key identifier (id) of the map in the database.
Since vector maps may have layer information,
the unique id is a combination of name, layer and mapset.

Use get_map_id() every time your need to access the grass map
in the file system but not to identify
map information in the temporal database.

:return: The map id "name@mapset"

##### grass.temporal.AbstractMapDataset.get_mapset

```python
get_mapset()
```

Return the mapset
:return: The mapset in which the dataset was created as string

##### grass.temporal.AbstractMapDataset.get_meet

```python
get_meet()
```

Return a list of map objects that spatially meet with this map

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_name

```python
get_name()
```

Return the name
:return: The name of the dataset as string

##### grass.temporal.AbstractMapDataset.get_new_instance

```python
get_new_instance(ident)
```

Return a new instance with the type of this class

:param ident: The identifier of the new dataset instance
:return: A new instance with the type of this object

##### grass.temporal.AbstractMapDataset.get_new_stds_instance

```python
get_new_stds_instance(ident)
```

Return a new space time dataset instance that store maps with the
type of this map object (raster, raster_3d or vector)

:param ident The identifier of the space time dataset
:return: The new space time dataset instance

##### grass.temporal.AbstractMapDataset.get_number_of_relations

```python
get_number_of_relations()
```

Return a dictionary in which the keys are the relation names and the
value are the number of relations.

The following relations are available:

Spatial relations:

```
- equivalent
- overlap
- in
- contain
- meet
- cover
- covered
```

Temporal relations:

```
- equal
- follows
- precedes
- overlaps
- overlapped
- during (including starts, finishes)
- contains (including started, finished)
- starts
- started
- finishes
- finished
```

To access topological information the spatial, temporal or booth
topologies must be build first using the SpatioTemporalTopologyBuilder.

:return: The dictionary with relations as keys and number as values or
None in case the topology wasn't built

##### grass.temporal.AbstractMapDataset.get_number_of_spatial_relations

```python
get_number_of_spatial_relations()
```

Return a dictionary in which the keys are the relation names and the value
are the number of relations.

The following relations are available:

- equivalent
- overlap
- in
- contain
- meet
- cover
- covered

To access topological information the spatial topology must be
build first using the SpatialTopologyBuilder.

:return: the dictionary with relations as keys and number as
values or None in case the topology wasn't build

##### grass.temporal.AbstractMapDataset.get_number_of_temporal_relations

```python
get_number_of_temporal_relations()
```

Return a dictionary in which the keys are the relation names and
the value are the number of relations.

The following relations are available:

- equal
- follows
- precedes
- overlaps
- overlapped
- during (including starts, finishes)
- contains (including started, finished)
- starts
- started
- finishes
- finished

To access topological information the temporal topology must be build
first using the SpatioTemporalTopologyBuilder.

:return: the dictionary with relations as keys and number as values
or None in case the topology wasn't build

##### grass.temporal.AbstractMapDataset.get_overlap

```python
get_overlap()
```

Return a list of map objects that this map spatial overlap with

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_overlapped

```python
get_overlapped()
```

Return a list of map objects that this map temporally overlapped

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_overlaps

```python
get_overlaps()
```

Return a list of map objects that this map temporally overlaps

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_precedes

```python
get_precedes()
```

Return a list of map objects that this map temporally precedes

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_registered_stds

```python
get_registered_stds(dbif=None, mapset=None)
```

Return all space time dataset ids in which this map is registered
as as a list of strings, or None if this map is not
registered in any space time dataset.

:param dbif: The database interface to be used
:return: A list of ids of all space time datasets in
which this map is registered

##### grass.temporal.AbstractMapDataset.get_relative_time

```python
get_relative_time()
```

Returns the start time, the end
time and the temporal unit of the dataset as tuple

The start time is of type integer.

The end time is of type integer in case of interval time,
or None on case of a time instance.

:return: A tuple of (start_time, end_time, unit)

##### grass.temporal.AbstractMapDataset.get_relative_time_unit

```python
get_relative_time_unit()
```

Returns the relative time unit
:return: The relative time unit as string, None if not present

##### grass.temporal.AbstractMapDataset.get_spatial_extent

```python
get_spatial_extent()
```

Return the spatial extent

##### grass.temporal.AbstractMapDataset.get_spatial_extent_as_tuple

```python
get_spatial_extent_as_tuple()
```

Return the spatial extent as tuple

Top and bottom are set to 0 in case of a two dimensional spatial
extent.

:return: A the spatial extent as tuple (north, south, east, west, top, bottom)

##### grass.temporal.AbstractMapDataset.get_spatial_relations

```python
get_spatial_relations()
```

Return the dictionary of spatial relationships

Keys are the spatial relationships in upper case,
values are abstract map objects.

:return: The spatial relations dictionary

##### grass.temporal.AbstractMapDataset.get_started

```python
get_started()
```

Return a list of map objects that this map temporally started with

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_starts

```python
get_starts()
```

Return a list of map objects that this map temporally starts with

:return: A list of map objects or None

##### grass.temporal.AbstractMapDataset.get_temporal_extent

```python
get_temporal_extent()
```

Return the temporal extent of the correct internal type

##### grass.temporal.AbstractMapDataset.get_temporal_extent_as_tuple

```python
get_temporal_extent_as_tuple()
```

Returns a tuple of the valid start and end time

Start and end time can be either of type datetime or of type
integer, depending on the temporal type.

:return: A tuple of (start_time, end_time)

##### grass.temporal.AbstractMapDataset.get_temporal_relations

```python
get_temporal_relations()
```

Return the dictionary of temporal relationships

Keys are the temporal relationships in upper case,
values are abstract map objects.

:return: The temporal relations dictionary

##### grass.temporal.AbstractMapDataset.get_temporal_type

```python
get_temporal_type()
```

Return the temporal type of this dataset

The temporal type can be absolute or relative

:return: The temporal type of the dataset as string

##### grass.temporal.AbstractMapDataset.get_type

```python
get_type()
```

Return the type of this class as string

The type can be "vector", "raster", "raster3d", "stvds", "strds" or "str3ds"

:return: "vector", "raster", "raster3d", "stvds", "strds" or "str3ds"

##### grass.temporal.AbstractMapDataset.has_grass_timestamp

```python
has_grass_timestamp()
```

Check if a grass file based time stamp exists for this map.

:return: True is the grass file based time stamped exists for this map

##### grass.temporal.AbstractMapDataset.in\_

```python
in_ = property(fget=get_in, fset=append_in)
```

##### grass.temporal.AbstractMapDataset.insert

```python
insert(dbif=None, execute=True)
```

Insert the map content into the database from the internal
structure

This functions assures that the timestamp is written to the
grass file system based database in addition to the temporal
database entry. The stds register table will be created as well.
Hence maps can only be registered in a space time dataset, when
they were inserted in the temporal database beforehand.

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.
:return: The SQL insert statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractMapDataset.is_in_db

```python
is_in_db(dbif=None, mapset=None)
```

Check if the dataset is registered in the database

:param dbif: The database interface to be used
:param mapset: The dbif connection to be used
:return: True if the dataset is registered in the database

##### grass.temporal.AbstractMapDataset.is_spatial_topology_build

```python
is_spatial_topology_build()
```

Check if the temporal topology was build

##### grass.temporal.AbstractMapDataset.is_stds

```python
is_stds()
```

Return True if this class is a space time dataset

:return: True if this class is a space time dataset, False otherwise

##### grass.temporal.AbstractMapDataset.is_temporal_topology_build

```python
is_temporal_topology_build()
```

Check if the temporal topology was build

##### grass.temporal.AbstractMapDataset.is_time_absolute

```python
is_time_absolute()
```

Return True in case the temporal type is absolute

:return: True if temporal type is absolute, False otherwise

##### grass.temporal.AbstractMapDataset.is_time_relative

```python
is_time_relative()
```

Return True in case the temporal type is relative

:return: True if temporal type is relative, False otherwise

##### grass.temporal.AbstractMapDataset.is_topology_build

```python
is_topology_build()
```

Check if the spatial and temporal topology was build

:return: A dictionary with "spatial" and "temporal" as keys that
have boolean values

##### grass.temporal.AbstractMapDataset.load

```python
load()
```

Load the content of this object from the grass
file system based database

##### grass.temporal.AbstractMapDataset.map_exists

```python
map_exists()
```

Return True in case the map exists in the grass spatial database

:return: True if map exists, False otherwise

##### grass.temporal.AbstractMapDataset.meet

```python
meet = property(fget=get_meet, fset=append_meet)
```

##### grass.temporal.AbstractMapDataset.msgr

```python
msgr = get_tgis_message_interface()
```

##### grass.temporal.AbstractMapDataset.next

```python
next()
```

Return the map with a start time temporally located after
the start time of this map, but temporal closer than other maps

:return: A map object or None

##### grass.temporal.AbstractMapDataset.overlap

```python
overlap = property(fget=get_overlap, fset=append_overlap)
```

##### grass.temporal.AbstractMapDataset.overlapped

```python
overlapped = property(fget=get_overlapped, fset=append_overlapped)
```

##### grass.temporal.AbstractMapDataset.overlaps

```python
overlaps = property(fget=get_overlaps, fset=append_overlaps)
```

##### grass.temporal.AbstractMapDataset.precedes

```python
precedes = property(fget=get_precedes, fset=append_precedes)
```

##### grass.temporal.AbstractMapDataset.prev

```python
prev()
```

Return the map with a start time temporally located before
the start time of this map, but temporal closer than other maps

:return: A map object or None

##### grass.temporal.AbstractMapDataset.print_info

```python
print_info()
```

Print information about this object in human readable style

##### grass.temporal.AbstractMapDataset.print_self

```python
print_self()
```

Print the content of the internal structure to stdout

##### grass.temporal.AbstractMapDataset.print_shell_info

```python
print_shell_info()
```

Print information about this object in shell style

##### grass.temporal.AbstractMapDataset.print_spatial_topology_info

```python
print_spatial_topology_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractMapDataset.print_spatial_topology_shell_info

```python
print_spatial_topology_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractMapDataset.print_temporal_topology_info

```python
print_temporal_topology_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractMapDataset.print_temporal_topology_shell_info

```python
print_temporal_topology_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractMapDataset.print_topology_info

```python
print_topology_info()
```

##### grass.temporal.AbstractMapDataset.print_topology_shell_info

```python
print_topology_shell_info()
```

##### grass.temporal.AbstractMapDataset.read_semantic_label_from_grass

```python
read_semantic_label_from_grass()
```

Read the band identifier of this map from the map metadata
in the GRASS file system based spatial database and
set the internal band identifier that should be insert/updated
in the temporal database.

Currently only implemented in RasterDataset. Otherwise
silently pass.

##### grass.temporal.AbstractMapDataset.read_timestamp_from_grass

```python
read_timestamp_from_grass()
```

Read the timestamp of this map from the map metadata
in the grass file system based spatial database and
set the internal time stamp that should be insert/updated
in the temporal database.

##### grass.temporal.AbstractMapDataset.remove_stds_from_register

```python
remove_stds_from_register(stds_id, dbif=None, execute=True)
```

Remove a space time dataset from the register

:param stds_id: The id of the space time dataset to removed from
the registered
:param dbif: The database interface to be used
:param execute: If True the SQL INSERT table statements
will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.

:return: The SQL statements if execute=False, else an empty string

##### grass.temporal.AbstractMapDataset.remove_timestamp_from_grass

```python
remove_timestamp_from_grass()
```

Remove the timestamp from the grass file
system based spatial database

##### grass.temporal.AbstractMapDataset.reset

```python
reset(ident)
```

Reset the internal structure and set the identifier

This method creates the dataset specific internal objects
that store the base information, the spatial and temporal extent
and the metadata. It must be implemented in the dataset
specific subclasses. This is the code for the
vector dataset:

.. code-block:: python

```
 self.base = VectorBase(ident=ident)
 self.absolute_time = VectorAbsoluteTime(ident=ident)
 self.relative_time = VectorRelativeTime(ident=ident)
 self.spatial_extent = VectorSpatialExtent(ident=ident)
 self.metadata = VectorMetadata(ident=ident)
```

:param ident: The identifier of the dataset that "name@mapset" or
in case of vector maps "name:layer@mapset"

##### grass.temporal.AbstractMapDataset.reset_spatial_topology

```python
reset_spatial_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractMapDataset.reset_temporal_topology

```python
reset_temporal_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractMapDataset.reset_topology

```python
reset_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractMapDataset.select

```python
select(dbif=None, mapset=None)
```

Select temporal dataset entry from database and fill
the internal structure

The content of every dataset is stored in the temporal database.
This method must be used to fill this object with the content
from the temporal database.

:param dbif: The database interface to be used
:param mapset: The dbif connection to be used

##### grass.temporal.AbstractMapDataset.set_absolute_time

```python
set_absolute_time(start_time, end_time=None)
```

Set the absolute time with start time and end time

The end time is optional and must be set to None in case of time
instance.

This method only modifies this object and does not commit
the modifications to the temporal database.

:param start_time: A datetime object specifying the start time of the map
:param end_time: A datetime object specifying the end time of the
map, None in case or time instance

:return: True for success and False otherwise

##### grass.temporal.AbstractMapDataset.set_id

```python
set_id(ident)
```

Set the identifier of the dataset

##### grass.temporal.AbstractMapDataset.set_next

```python
set_next(map)
```

Set the map that is temporally as closest located after this map.

Temporally located means that the start time of the "next" map is
temporally located AFTER the start time of this map, but temporally
near than other maps of the same dataset.

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.set_prev

```python
set_prev(map)
```

Set the map that is temporally as closest located before this map.

Temporally located means that the start time of the "previous" map
is temporally located BEFORE the start time of this map, but
temporally near than other maps of the same dataset.

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractMapDataset.set_relative_time

```python
set_relative_time(start_time, end_time, unit)
```

Set the relative time interval

The end time is optional and must be set to None in case of time
instance.

This method only modifies this object and does not commit
the modifications to the temporal database.

:param start_time: An integer value
:param end_time: An integer value, None in case or time instance
:param unit: The unit of the relative time. Supported units:
year(s), month(s), day(s), hour(s), minute(s), second(s)

:return: True for success and False otherwise

##### grass.temporal.AbstractMapDataset.set_semantic_label

```python
set_semantic_label(semantic_label)
```

Set semantic label identifier

Currently only implemented in RasterDataset. Otherwise
report a warning.

##### grass.temporal.AbstractMapDataset.set_spatial_extent

```python
set_spatial_extent(spatial_extent)
```

Set the spatial extent of the map

This method only modifies this object and does not commit
the modifications to the temporal database.

:param spatial_extent: An object of type SpatialExtent or its subclasses

.. code-block: : python

```
>>> import datetime
>>> import grass.temporal as tgis
>>> map = tgis.RasterDataset(None)
>>> spat_ext = tgis.SpatialExtent(
...     north=10, south=-10, east=20, west=-20, top=5, bottom=-5
... )
>>> map.set_spatial_extent(spat_ext)
>>> print(map.get_spatial_extent_as_tuple())
(10.0, -10.0, 20.0, -20.0, 5.0, -5.0)
```

##### grass.temporal.AbstractMapDataset.set_spatial_extent_from_values

```python
set_spatial_extent_from_values(north, south, east, west, top=0, bottom=0)
```

Set the spatial extent of the map from values

This method only modifies this object and does not commit
the modifications to the temporal database.

:param north: The northern edge
:param south: The southern edge
:param east: The eastern edge
:param west: The western edge
:param top: The top edge
:param bottom: The bottom edge

##### grass.temporal.AbstractMapDataset.set_spatial_topology_build_false

```python
set_spatial_topology_build_false()
```

Same as name

##### grass.temporal.AbstractMapDataset.set_spatial_topology_build_true

```python
set_spatial_topology_build_true()
```

Same as name

##### grass.temporal.AbstractMapDataset.set_temporal_extent

```python
set_temporal_extent(extent)
```

Convenient method to set the temporal extent from a temporal extent
object

:param extent: The temporal extent that should be set for this object

.. code-block: : python

```
>>> import datetime
>>> import grass.temporal as tgis
>>> map = tgis.RasterDataset(None)
>>> temp_ext = tgis.RasterRelativeTime(
...     start_time=1, end_time=2, unit="years"
... )
>>> map.set_temporal_extent(temp_ext)
>>> print(map.get_temporal_extent_as_tuple())
(1, 2)
>>> map = tgis.VectorDataset(None)
>>> temp_ext = tgis.VectorAbsoluteTime(
...     start_time=datetime.datetime(2000, 1, 1),
...     end_time=datetime.datetime(2001, 1, 1),
... )
>>> map.set_temporal_extent(temp_ext)
>>> print(map.get_temporal_extent_as_tuple())
(datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0))

>>> map1 = tgis.VectorDataset("A@P")
>>> check = map1.set_absolute_time(
...     datetime.datetime(2000, 5, 5), datetime.datetime(2005, 6, 6)
... )
>>> print(map1.get_temporal_extent_as_tuple())
(datetime.datetime(2000, 5, 5, 0, 0), datetime.datetime(2005, 6, 6, 0, 0))
>>> map2 = tgis.RasterDataset("B@P")
>>> check = map2.set_absolute_time(
...     datetime.datetime(1990, 1, 1), datetime.datetime(1999, 8, 1)
... )
>>> print(map2.get_temporal_extent_as_tuple())
(datetime.datetime(1990, 1, 1, 0, 0), datetime.datetime(1999, 8, 1, 0, 0))
>>> map2.set_temporal_extent(map1.get_temporal_extent())
>>> print(map2.get_temporal_extent_as_tuple())
(datetime.datetime(2000, 5, 5, 0, 0), datetime.datetime(2005, 6, 6, 0, 0))
```

##### grass.temporal.AbstractMapDataset.set_temporal_topology_build_false

```python
set_temporal_topology_build_false()
```

Same as name

##### grass.temporal.AbstractMapDataset.set_temporal_topology_build_true

```python
set_temporal_topology_build_true()
```

Same as name

##### grass.temporal.AbstractMapDataset.set_time_to_absolute

```python
set_time_to_absolute()
```

Set the temporal type to absolute

##### grass.temporal.AbstractMapDataset.set_time_to_relative

```python
set_time_to_relative()
```

Set the temporal type to relative

##### grass.temporal.AbstractMapDataset.set_topology_build_false

```python
set_topology_build_false()
```

Use this method when the spatio-temporal topology was not build

##### grass.temporal.AbstractMapDataset.set_topology_build_true

```python
set_topology_build_true()
```

Use this method when the spatio-temporal topology was build

##### grass.temporal.AbstractMapDataset.spatial_buffer

```python
spatial_buffer(size, update=False, dbif=None)
```

Buffer the spatial extent by a given size in all
spatial directions.

:param size: The buffer size, using the unit of the grass region
:param update: If True perform an immediate database update, otherwise only the
internal variables are set
:param dbif: The database interface to be used

.. code-block: : python

```
>>> import grass.temporal as tgis
>>> map = tgis.RasterDataset(None)
>>> spat_ext = tgis.SpatialExtent(
...     north=10, south=-10, east=20, west=-20, top=5, bottom=-5
... )
>>> map.set_spatial_extent(spat_ext)
>>> map.spatial_buffer(10)
>>> print(map.get_spatial_extent_as_tuple())
(20.0, -20.0, 30.0, -30.0, 15.0, -15.0)
```

##### grass.temporal.AbstractMapDataset.spatial_buffer_2d

```python
spatial_buffer_2d(size, update=False, dbif=None)
```

Buffer the spatial extent by a given size in 2d
spatial directions.

:param size: The buffer size, using the unit of the grass region
:param update: If True perform an immediate database update, otherwise only the
internal variables are set
:param dbif: The database interface to be used

.. code-block: : python

```
>>> import grass.temporal as tgis
>>> map = tgis.RasterDataset(None)
>>> spat_ext = tgis.SpatialExtent(
...     north=10, south=-10, east=20, west=-20, top=5, bottom=-5
... )
>>> map.set_spatial_extent(spat_ext)
>>> map.spatial_buffer_2d(10)
>>> print(map.get_spatial_extent_as_tuple())
(20.0, -20.0, 30.0, -30.0, 5.0, -5.0)
```

##### grass.temporal.AbstractMapDataset.spatial_disjoint_union

```python
spatial_disjoint_union(dataset)
```

Return the spatial union as spatial_extent object.

:param dataset: The abstract dataset to create a union with
:return: The union spatial extent

##### grass.temporal.AbstractMapDataset.spatial_intersection

```python
spatial_intersection(dataset)
```

Return the spatial intersection as spatial_extent
object or None in case no intersection was found.

:param dataset: The abstract dataset to intersect with
:return: The intersection spatial extent

##### grass.temporal.AbstractMapDataset.spatial_overlapping

```python
spatial_overlapping(dataset)
```

Return True if the spatial extents overlap

:param dataset: The abstract dataset to check spatial overlapping
:return: True if self and the provided dataset spatial overlap

##### grass.temporal.AbstractMapDataset.spatial_relation

```python
spatial_relation(dataset)
```

Return the spatial relationship between self and dataset

:param dataset: The abstract dataset to compute the spatial
relation with self
:return: The spatial relationship as string

##### grass.temporal.AbstractMapDataset.spatial_union

```python
spatial_union(dataset)
```

Return the spatial union as spatial_extent
object or None in case the extents does not overlap or meet.

:param dataset: The abstract dataset to create a union with
:return: The union spatial extent

##### grass.temporal.AbstractMapDataset.split_name

```python
split_name(name, layer=None, mapset=None)
```

Convenient method to split a map name into three potentially
contained parts: map name, map layer and mapset. For the layer and
mapset, default keyword arguments can be given if not present in
the name. Layer and mapset present in the name will overwrite
the keyword arguments.

:param name: The name of the map
:param layer: The layer of the vector map, use None in case no layer exists
:param mapset: The mapset in which the map is located

:return: tuple of three elements name, layer, mapset e(:layer)@mapset" while
layer is optional

##### grass.temporal.AbstractMapDataset.started

```python
started = property(fget=get_started, fset=append_started)
```

##### grass.temporal.AbstractMapDataset.starts

```python
starts = property(fget=get_starts, fset=append_starts)
```

##### grass.temporal.AbstractMapDataset.temporal_buffer

```python
temporal_buffer(increment, update=False, dbif=None)
```

Create a temporal buffer based on an increment

For absolute time the increment must be a string of type "integer
unit"
Unit can be year, years, month, months, day, days, hour, hours,
minute, minutes, day or days.

:param increment: This is the increment, a string in case of
absolute time or an integer in case of relative
time
:param update: Perform an immediate database update to store the
modified temporal extent, otherwise only this object
will be modified

Usage:

.. code-block: : python

```
>>> import grass.temporal as tgis
>>> maps = []
>>> for i in range(5):
...     map = tgis.RasterDataset(None)
...     if i % 2 == 0:
...         check = map.set_relative_time(i, i + 1, "years")
...     else:
...         check = map.set_relative_time(i, None, "years")
...     map.temporal_buffer(3)
...     maps.append(map)
>>> for map in maps:
...     map.temporal_extent.print_info()
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. -3
 | End time:................... 4
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. -2
 | End time:................... 4
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. -1
 | End time:................... 6
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 0
 | End time:................... 6
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 1
 | End time:................... 8
 | Relative time unit:......... years
>>> maps = []
>>> for i in range(1, 5):
...     map = tgis.RasterDataset(None)
...     if i % 2 == 0:
...         check = map.set_absolute_time(
...             datetime(2001, i, 1), datetime(2001, i + 1, 1)
...         )
...     else:
...         check = map.set_absolute_time(datetime(2001, i, 1), None)
...     map.temporal_buffer("7 days")
...     maps.append(map)
>>> for map in maps:
...     map.temporal_extent.print_info()
 +-------------------- Absolute time -----------------------------------------+
 | Start time:................. 2000-12-25 00:00:00
 | End time:................... 2001-01-08 00:00:00
 +-------------------- Absolute time -----------------------------------------+
 | Start time:................. 2001-01-25 00:00:00
 | End time:................... 2001-03-08 00:00:00
 +-------------------- Absolute time -----------------------------------------+
 | Start time:................. 2001-02-22 00:00:00
 | End time:................... 2001-03-08 00:00:00
 +-------------------- Absolute time -----------------------------------------+
 | Start time:................. 2001-03-25 00:00:00
 | End time:................... 2001-05-08 00:00:00
```

##### grass.temporal.AbstractMapDataset.temporal_disjoint_union

```python
temporal_disjoint_union(dataset)
```

Creates a union with the provided dataset and
return a new temporal extent with the new start and end time.

:param dataset: The abstract dataset to create temporal union with
:return: The new temporal extent with start and end time

##### grass.temporal.AbstractMapDataset.temporal_extent

```python
temporal_extent = property(fget=get_temporal_extent)
```

##### grass.temporal.AbstractMapDataset.temporal_intersection

```python
temporal_intersection(dataset)
```

Intersect self with the provided dataset and
return a new temporal extent with the new start and end time

:param dataset: The abstract dataset to temporal intersect with
:return: The new temporal extent with start and end time,
or None in case of no intersection

##### grass.temporal.AbstractMapDataset.temporal_relation

```python
temporal_relation(dataset)
```

Return the temporal relation of self and the provided dataset

:return: The temporal relation as string

##### grass.temporal.AbstractMapDataset.temporal_union

```python
temporal_union(dataset)
```

Creates a union with the provided dataset and
return a new temporal extent with the new start and end time.

:param dataset: The abstract dataset to create temporal union with
:return: The new temporal extent with start and end time,
or None in case of no intersection

##### grass.temporal.AbstractMapDataset.unregister

```python
unregister(dbif=None, update=True, execute=True)
```

Remove the map entry in each space time dataset in which this map
is registered

:param dbif: The database interface to be used
:param update: Call for each unregister statement the update from
registered maps of the space time dataset. This can
slow down the un-registration process significantly.
:param execute: If True the SQL DELETE and DROP table statements
will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.

:return: The SQL statements if execute=False, else an empty string

##### grass.temporal.AbstractMapDataset.update

```python
update(dbif=None, execute=True)
```

Update the map content in the database from the internal structure
excluding None variables

This functions assures that the timestamp is written to the
grass file system based database in addition to the temporal
database entry.

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.
:return: The SQL insert statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractMapDataset.update_absolute_time

```python
update_absolute_time(start_time, end_time=None, dbif=None)
```

Update the absolute time

The end time is optional and must be set to None in case of time
instance.

This functions assures that the timestamp is written to the
grass file system based database in addition to the temporal
database entry.

:param start_time: A datetime object specifying the start time of the map
:param end_time: A datetime object specifying the end time of the
map, None in case or time instance
:param dbif: The database interface to be used

##### grass.temporal.AbstractMapDataset.update_all

```python
update_all(dbif=None, execute=True)
```

Update the map content in the database from the internal structure
including None variables

This functions assures that the timestamp is written to the
grass file system based database in addition to the temporal
database entry.

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.
:return: The SQL insert statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractMapDataset.update_relative_time

```python
update_relative_time(start_time, end_time, unit, dbif=None)
```

Update the relative time interval

The end time is optional and must be set to None in case of time
instance.

This functions assures that the timestamp is written to the
grass file system based database in addition to the temporal
database entry.

:param start_time: An integer value
:param end_time: An integer value, None in case or time instance
:param unit: The relative time unit
:param dbif: The database interface to be used

##### grass.temporal.AbstractMapDataset.write_timestamp_to_grass

```python
write_timestamp_to_grass()
```

Write the timestamp of this map into the map metadata
in the grass file system based spatial database.

#### grass.temporal.AbstractSTDSRegister

```python
AbstractSTDSRegister(table=None, ident=None, registered_stds=None)
```

Bases: <code>[SQLDatabaseInterface](#grass.temporal.base.SQLDatabaseInterface)</code>

This is the base class for all maps to store the space time datasets
as comma separated string in which they are registered

Usage:

.. code-block:: python

```
 >>> init()
 >>> t = AbstractSTDSRegister("raster", "soil@PERMANENT", "A@P,B@P,C@P")
 >>> t.id
 'soil@PERMANENT'
 >>> t.registered_stds
 'A@P,B@P,C@P'
```

**Functions:**

- [**clear**](#grass.temporal.AbstractSTDSRegister.clear) – Initialize the internal storage
- [**delete**](#grass.temporal.AbstractSTDSRegister.delete) – Delete the entry of this object from the temporal database
- [**deserialize**](#grass.temporal.AbstractSTDSRegister.deserialize) – Convert the content of the dbmi dictionary like row into the
- [**get_delete_statement**](#grass.temporal.AbstractSTDSRegister.get_delete_statement) – Return the delete string
- [**get_id**](#grass.temporal.AbstractSTDSRegister.get_id) – Convenient method to get the unique identifier (primary key)
- [**get_insert_statement**](#grass.temporal.AbstractSTDSRegister.get_insert_statement) – Return the sql statement and the argument
- [**get_insert_statement_mogrified**](#grass.temporal.AbstractSTDSRegister.get_insert_statement_mogrified) – Return the insert statement as mogrified string
- [**get_is_in_db_statement**](#grass.temporal.AbstractSTDSRegister.get_is_in_db_statement) – Return the selection string that checks if this object is registered in the
- [**get_registered_stds**](#grass.temporal.AbstractSTDSRegister.get_registered_stds) – Get the comma separated list of space time datasets ids
- [**get_select_statement**](#grass.temporal.AbstractSTDSRegister.get_select_statement) – Return the sql statement and the argument list in
- [**get_select_statement_mogrified**](#grass.temporal.AbstractSTDSRegister.get_select_statement_mogrified) – Return the select statement as mogrified string
- [**get_table_name**](#grass.temporal.AbstractSTDSRegister.get_table_name) – Return the name of the table in which the internal
- [**get_update_all_statement**](#grass.temporal.AbstractSTDSRegister.get_update_all_statement) – Return the sql statement and the argument
- [**get_update_all_statement_mogrified**](#grass.temporal.AbstractSTDSRegister.get_update_all_statement_mogrified) – Return the update all statement as mogrified string
- [**get_update_statement**](#grass.temporal.AbstractSTDSRegister.get_update_statement) – Return the sql statement and the argument list
- [**get_update_statement_mogrified**](#grass.temporal.AbstractSTDSRegister.get_update_statement_mogrified) – Return the update statement as mogrified string
- [**insert**](#grass.temporal.AbstractSTDSRegister.insert) – Serialize the content of this object and store it in the temporal
- [**is_in_db**](#grass.temporal.AbstractSTDSRegister.is_in_db) – Check if this object is present in the temporal database
- [**print_self**](#grass.temporal.AbstractSTDSRegister.print_self) – Print the content of the internal dictionary to stdout
- [**select**](#grass.temporal.AbstractSTDSRegister.select) – Select the content from the temporal database and store it
- [**serialize**](#grass.temporal.AbstractSTDSRegister.serialize) – Convert the internal dictionary into a string of semicolon
- [**set_id**](#grass.temporal.AbstractSTDSRegister.set_id) – Convenient method to set the unique identifier (primary key)
- [**set_registered_stds**](#grass.temporal.AbstractSTDSRegister.set_registered_stds) – Get the comma separated list of space time datasets ids
- [**update**](#grass.temporal.AbstractSTDSRegister.update) – Serialize the content of this object and update it in the temporal
- [**update_all**](#grass.temporal.AbstractSTDSRegister.update_all) – Serialize the content of this object, including None objects,

**Attributes:**

- [**D**](#grass.temporal.AbstractSTDSRegister.D) –
- [**dbmi_paramstyle**](#grass.temporal.AbstractSTDSRegister.dbmi_paramstyle) –
- [**id**](#grass.temporal.AbstractSTDSRegister.id) –
- [**ident**](#grass.temporal.AbstractSTDSRegister.ident) –
- [**mapset**](#grass.temporal.AbstractSTDSRegister.mapset) –
- [**msgr**](#grass.temporal.AbstractSTDSRegister.msgr) –
- [**registered_stds**](#grass.temporal.AbstractSTDSRegister.registered_stds) –
- [**table**](#grass.temporal.AbstractSTDSRegister.table) –

Constructor

:param table: The name of the temporal database table
that should be used to store the values
:param ident: The unique identifier must be a combination of
the dataset name, layer name and the mapset
"name@mapset" or "name:layer@mapset"
used as as primary key in the temporal database
:param stds: A comma separated list of space time dataset ids

##### grass.temporal.AbstractSTDSRegister.D

```python
D = {}
```

##### grass.temporal.AbstractSTDSRegister.clear

```python
clear()
```

Initialize the internal storage

##### grass.temporal.AbstractSTDSRegister.dbmi_paramstyle

```python
dbmi_paramstyle = get_tgis_dbmi_paramstyle()
```

##### grass.temporal.AbstractSTDSRegister.delete

```python
delete(dbif=None)
```

Delete the entry of this object from the temporal database

:param dbif: The database interface to be used,
if None a temporary connection will be established

##### grass.temporal.AbstractSTDSRegister.deserialize

```python
deserialize(row)
```

Convert the content of the dbmi dictionary like row into the
internal dictionary

:param row: The dictionary like row to store in the internal dict

##### grass.temporal.AbstractSTDSRegister.get_delete_statement

```python
get_delete_statement()
```

Return the delete string
:return: The DELETE string

##### grass.temporal.AbstractSTDSRegister.get_id

```python
get_id()
```

Convenient method to get the unique identifier (primary key)

:return: None if not found

##### grass.temporal.AbstractSTDSRegister.get_insert_statement

```python
get_insert_statement()
```

Return the sql statement and the argument
list in database specific style
:return: The INSERT string

##### grass.temporal.AbstractSTDSRegister.get_insert_statement_mogrified

```python
get_insert_statement_mogrified(dbif=None)
```

Return the insert statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:return: The INSERT string

##### grass.temporal.AbstractSTDSRegister.get_is_in_db_statement

```python
get_is_in_db_statement()
```

Return the selection string that checks if this object is registered in the
temporal database
:return: The SELECT string

##### grass.temporal.AbstractSTDSRegister.get_registered_stds

```python
get_registered_stds()
```

Get the comma separated list of space time datasets ids
in which this map is registered

:return: None if not found

##### grass.temporal.AbstractSTDSRegister.get_select_statement

```python
get_select_statement()
```

Return the sql statement and the argument list in
database specific style
:return: The SELECT string

##### grass.temporal.AbstractSTDSRegister.get_select_statement_mogrified

```python
get_select_statement_mogrified(dbif=None)
```

Return the select statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:return: The SELECT string

##### grass.temporal.AbstractSTDSRegister.get_table_name

```python
get_table_name()
```

Return the name of the table in which the internal
data are inserted, updated or selected
:return: The name of the table

##### grass.temporal.AbstractSTDSRegister.get_update_all_statement

```python
get_update_all_statement(ident=None)
```

Return the sql statement and the argument
list in database specific style

:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbstractSTDSRegister.get_update_all_statement_mogrified

```python
get_update_all_statement_mogrified(dbif=None, ident=None)
```

Return the update all statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbstractSTDSRegister.get_update_statement

```python
get_update_statement(ident=None)
```

Return the sql statement and the argument list
in database specific style

:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbstractSTDSRegister.get_update_statement_mogrified

```python
get_update_statement_mogrified(dbif=None, ident=None)
```

Return the update statement as mogrified string

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming
:return: The UPDATE string

##### grass.temporal.AbstractSTDSRegister.id

```python
id = property(fget=get_id, fset=set_id)
```

##### grass.temporal.AbstractSTDSRegister.ident

```python
ident = ident
```

##### grass.temporal.AbstractSTDSRegister.insert

```python
insert(dbif=None)
```

Serialize the content of this object and store it in the temporal
database using the internal identifier

:param dbif: The database interface to be used,
if None a temporary connection will be established

##### grass.temporal.AbstractSTDSRegister.is_in_db

```python
is_in_db(dbif=None, mapset=None)
```

Check if this object is present in the temporal database

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param mapset: The mapset with a temporal database to be used
The mapset of the database can be different from
the mapset of the map
:return: True if this object is present in the temporal database,
False otherwise

##### grass.temporal.AbstractSTDSRegister.mapset

```python
mapset = self.ident.split('@')[1]
```

##### grass.temporal.AbstractSTDSRegister.msgr

```python
msgr = get_tgis_message_interface()
```

##### grass.temporal.AbstractSTDSRegister.print_self

```python
print_self()
```

Print the content of the internal dictionary to stdout

##### grass.temporal.AbstractSTDSRegister.registered_stds

```python
registered_stds = property(fget=get_registered_stds, fset=set_registered_stds)
```

##### grass.temporal.AbstractSTDSRegister.select

```python
select(dbif=None, mapset=None)
```

Select the content from the temporal database and store it
in the internal dictionary structure

:param dbif: The database interface to be used,
if None a temporary connection will be established

##### grass.temporal.AbstractSTDSRegister.serialize

```python
serialize(type, table, where=None)
```

Convert the internal dictionary into a string of semicolon
separated SQL statements The keys are the column names and
the values are the row entries

Usage:

.. code-block:: python

```
>>> init()
>>> t = DictSQLSerializer()
>>> t.D["id"] = "soil@PERMANENT"
>>> t.D["name"] = "soil"
>>> t.D["mapset"] = "PERMANENT"
>>> t.D["creator"] = "soeren"
>>> t.D["creation_time"] = datetime(2001, 1, 1)
>>> t.D["modification_time"] = datetime(2001, 1, 1)
>>> t.serialize(type="SELECT", table="raster_base")
('SELECT  name  , creator  , creation_time  , modification_time  , mapset  , id  FROM raster_base ;\n', ())
>>> t.serialize(type="INSERT", table="raster_base")
('INSERT INTO raster_base ( name  ,creator  ,creation_time  ,modification_time  ,mapset  ,id ) VALUES (? ,? ,? ,? ,? ,?) ;\n', ('soil', 'soeren', datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0), 'PERMANENT', 'soil@PERMANENT'))
>>> t.serialize(type="UPDATE", table="raster_base")
('UPDATE raster_base SET  name = ?  ,creator = ?  ,creation_time = ?  ,modification_time = ?  ,mapset = ?  ,id = ? ;\n', ('soil', 'soeren', datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0), 'PERMANENT', 'soil@PERMANENT'))
>>> t.serialize(type="UPDATE ALL", table="raster_base")
('UPDATE raster_base SET  name = ?  ,creator = ?  ,creation_time = ?  ,modification_time = ?  ,mapset = ?  ,id = ? ;\n', ('soil', 'soeren', datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0), 'PERMANENT', 'soil@PERMANENT'))

:param type: must be SELECT. INSERT, UPDATE
:param table: The name of the table to select, insert or update
:param where: The optional where statement
:return: a tuple containing the SQL string and the arguments
```

##### grass.temporal.AbstractSTDSRegister.set_id

```python
set_id(ident)
```

Convenient method to set the unique identifier (primary key)

:param ident: The unique identifier must be a combination
of the dataset name, layer name and the mapset
"name@mapset" or "name:layer@mapset"

##### grass.temporal.AbstractSTDSRegister.set_registered_stds

```python
set_registered_stds(registered_stds)
```

Get the comma separated list of space time datasets ids
in which this map is registered

:param registered_stds: A comma separated list of space time
dataset ids in which this map is registered

##### grass.temporal.AbstractSTDSRegister.table

```python
table = table
```

##### grass.temporal.AbstractSTDSRegister.update

```python
update(dbif=None, ident=None)
```

Serialize the content of this object and update it in the temporal
database using the internal identifier

Only object entries which are exists (not None) are updated

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming

##### grass.temporal.AbstractSTDSRegister.update_all

```python
update_all(dbif=None, ident=None)
```

Serialize the content of this object, including None objects,
and update it in the temporal database using the internal identifier

:param dbif: The database interface to be used,
if None a temporary connection will be established
:param ident: The identifier to be updated, useful for renaming

#### grass.temporal.AbstractSpaceTimeDataset

```python
AbstractSpaceTimeDataset(ident)
```

Bases: <code>[AbstractDataset](#grass.temporal.abstract_dataset.AbstractDataset)</code>

Abstract space time dataset class

Base class for all space time datasets.

This class represents an abstract space time dataset. Convenient functions
to select, update, insert or delete objects of this type in the SQL
temporal database exists as well as functions to register or unregister
raster maps.

Parts of the temporal logic are implemented in the SQL temporal
database, like the computation of the temporal and spatial extent as
well as the collecting of metadata.

**Functions:**

- [**append_contain**](#grass.temporal.AbstractSpaceTimeDataset.append_contain) – Append a map that this map spatially contains
- [**append_contains**](#grass.temporal.AbstractSpaceTimeDataset.append_contains) – Append a map that this map temporally contains
- [**append_cover**](#grass.temporal.AbstractSpaceTimeDataset.append_cover) – Append a map that spatially cover this map
- [**append_covered**](#grass.temporal.AbstractSpaceTimeDataset.append_covered) – Append a map that is spatially covered by this map
- [**append_during**](#grass.temporal.AbstractSpaceTimeDataset.append_during) – Append a map that this map is temporally located during
- [**append_equal**](#grass.temporal.AbstractSpaceTimeDataset.append_equal) – Append a map with equivalent temporal extent as this map
- [**append_equivalent**](#grass.temporal.AbstractSpaceTimeDataset.append_equivalent) – Append a map with equivalent spatial extent as this map
- [**append_finished**](#grass.temporal.AbstractSpaceTimeDataset.append_finished) – Append a map that this map temporally finished with
- [**append_finishes**](#grass.temporal.AbstractSpaceTimeDataset.append_finishes) – Append a map that this map temporally finishes with
- [**append_follows**](#grass.temporal.AbstractSpaceTimeDataset.append_follows) – Append a map that this map temporally follows
- [**append_in**](#grass.temporal.AbstractSpaceTimeDataset.append_in) – Append a map that this is spatial in this map
- [**append_meet**](#grass.temporal.AbstractSpaceTimeDataset.append_meet) – Append a map that spatially meet with this map
- [**append_overlap**](#grass.temporal.AbstractSpaceTimeDataset.append_overlap) – Append a map that this spatial overlap with this map
- [**append_overlapped**](#grass.temporal.AbstractSpaceTimeDataset.append_overlapped) – Append a map that this map temporally overlapped
- [**append_overlaps**](#grass.temporal.AbstractSpaceTimeDataset.append_overlaps) – Append a map that this map temporally overlaps
- [**append_precedes**](#grass.temporal.AbstractSpaceTimeDataset.append_precedes) – Append a map that this map temporally precedes
- [**append_started**](#grass.temporal.AbstractSpaceTimeDataset.append_started) – Append a map that this map temporally started with
- [**append_starts**](#grass.temporal.AbstractSpaceTimeDataset.append_starts) – Append a map that this map temporally starts with
- [**check_relative_time_unit**](#grass.temporal.AbstractSpaceTimeDataset.check_relative_time_unit) – Check if unit is of type year(s), month(s), day(s), hour(s),
- [**check_temporal_topology**](#grass.temporal.AbstractSpaceTimeDataset.check_temporal_topology) – Check the temporal topology of all maps of the current space time
- [**count_gaps**](#grass.temporal.AbstractSpaceTimeDataset.count_gaps) – Count the number of gaps between temporal neighbors
- [**count_temporal_relations**](#grass.temporal.AbstractSpaceTimeDataset.count_temporal_relations) – Count the temporal relations between the registered maps.
- [**count_temporal_types**](#grass.temporal.AbstractSpaceTimeDataset.count_temporal_types) – Return the temporal type of the registered maps as dictionary
- [**create_command_string**](#grass.temporal.AbstractSpaceTimeDataset.create_command_string) – Create the command string that was used to create this
- [**create_map_register_name**](#grass.temporal.AbstractSpaceTimeDataset.create_map_register_name) – Create the name of the map register table of this space time
- [**delete**](#grass.temporal.AbstractSpaceTimeDataset.delete) – Delete a space time dataset from the temporal database
- [**get_absolute_time**](#grass.temporal.AbstractSpaceTimeDataset.get_absolute_time) – Returns the start time, the end
- [**get_contain**](#grass.temporal.AbstractSpaceTimeDataset.get_contain) – Return a list of map objects that this map contains
- [**get_contains**](#grass.temporal.AbstractSpaceTimeDataset.get_contains) – Return a list of map objects that this map temporally contains
- [**get_cover**](#grass.temporal.AbstractSpaceTimeDataset.get_cover) – Return a list of map objects that spatially cover this map
- [**get_covered**](#grass.temporal.AbstractSpaceTimeDataset.get_covered) – Return a list of map objects that are spatially covered by this map
- [**get_during**](#grass.temporal.AbstractSpaceTimeDataset.get_during) – Return a list of map objects that this map is temporally located during
- [**get_equal**](#grass.temporal.AbstractSpaceTimeDataset.get_equal) – Return a list of map objects with equivalent temporal extent as
- [**get_equivalent**](#grass.temporal.AbstractSpaceTimeDataset.get_equivalent) – Return a list of map objects with equivalent spatial extent as this map
- [**get_finished**](#grass.temporal.AbstractSpaceTimeDataset.get_finished) – Return a list of map objects that this map temporally finished with
- [**get_finishes**](#grass.temporal.AbstractSpaceTimeDataset.get_finishes) – Return a list of map objects that this map temporally finishes with
- [**get_follows**](#grass.temporal.AbstractSpaceTimeDataset.get_follows) – Return a list of map objects that this map temporally follows
- [**get_granularity**](#grass.temporal.AbstractSpaceTimeDataset.get_granularity) – Return the granularity of the space time dataset
- [**get_id**](#grass.temporal.AbstractSpaceTimeDataset.get_id) – Return the unique identifier of the dataset
- [**get_in**](#grass.temporal.AbstractSpaceTimeDataset.get_in) – Return a list of map objects that are spatial in this map
- [**get_initial_values**](#grass.temporal.AbstractSpaceTimeDataset.get_initial_values) – Return the initial values: temporal_type,
- [**get_map_register**](#grass.temporal.AbstractSpaceTimeDataset.get_map_register) – Return the name of the map register table
- [**get_map_time**](#grass.temporal.AbstractSpaceTimeDataset.get_map_time) – Return the type of the map time, interval, point, mixed or invalid
- [**get_mapset**](#grass.temporal.AbstractSpaceTimeDataset.get_mapset) – Return the mapset
- [**get_meet**](#grass.temporal.AbstractSpaceTimeDataset.get_meet) – Return a list of map objects that spatially meet with this map
- [**get_name**](#grass.temporal.AbstractSpaceTimeDataset.get_name) – Get dataset name including semantic label filter if enabled.
- [**get_new_instance**](#grass.temporal.AbstractSpaceTimeDataset.get_new_instance) – Return a new instance with the type of this class
- [**get_new_map_instance**](#grass.temporal.AbstractSpaceTimeDataset.get_new_map_instance) – Return a new instance of a map which is associated
- [**get_number_of_relations**](#grass.temporal.AbstractSpaceTimeDataset.get_number_of_relations) – Return a dictionary in which the keys are the relation names and the
- [**get_number_of_spatial_relations**](#grass.temporal.AbstractSpaceTimeDataset.get_number_of_spatial_relations) – Return a dictionary in which the keys are the relation names and the value
- [**get_number_of_temporal_relations**](#grass.temporal.AbstractSpaceTimeDataset.get_number_of_temporal_relations) – Return a dictionary in which the keys are the relation names and
- [**get_overlap**](#grass.temporal.AbstractSpaceTimeDataset.get_overlap) – Return a list of map objects that this map spatial overlap with
- [**get_overlapped**](#grass.temporal.AbstractSpaceTimeDataset.get_overlapped) – Return a list of map objects that this map temporally overlapped
- [**get_overlaps**](#grass.temporal.AbstractSpaceTimeDataset.get_overlaps) – Return a list of map objects that this map temporally overlaps
- [**get_precedes**](#grass.temporal.AbstractSpaceTimeDataset.get_precedes) – Return a list of map objects that this map temporally precedes
- [**get_registered_maps**](#grass.temporal.AbstractSpaceTimeDataset.get_registered_maps) – Return SQL rows of the selected registered maps.
- [**get_registered_maps_as_objects**](#grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects) – Return all or a subset of the registered maps as ordered object
- [**get_registered_maps_as_objects_by_granularity**](#grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects_by_granularity) – Return all registered maps as ordered (by start_time) object list
- [**get_registered_maps_as_objects_with_gaps**](#grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects_with_gaps) – Return all or a subset of the registered maps as
- [**get_registered_maps_as_objects_with_temporal_topology**](#grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects_with_temporal_topology) – Return all or a subset of the registered maps as ordered object
- [**get_relative_time**](#grass.temporal.AbstractSpaceTimeDataset.get_relative_time) – Returns the start time, the end
- [**get_relative_time_unit**](#grass.temporal.AbstractSpaceTimeDataset.get_relative_time_unit) – Returns the relative time unit
- [**get_semantic_type**](#grass.temporal.AbstractSpaceTimeDataset.get_semantic_type) – Return the semantic type of this dataset
- [**get_spatial_extent**](#grass.temporal.AbstractSpaceTimeDataset.get_spatial_extent) – Return the spatial extent
- [**get_spatial_extent_as_tuple**](#grass.temporal.AbstractSpaceTimeDataset.get_spatial_extent_as_tuple) – Return the spatial extent as tuple
- [**get_spatial_relations**](#grass.temporal.AbstractSpaceTimeDataset.get_spatial_relations) – Return the dictionary of spatial relationships
- [**get_started**](#grass.temporal.AbstractSpaceTimeDataset.get_started) – Return a list of map objects that this map temporally started with
- [**get_starts**](#grass.temporal.AbstractSpaceTimeDataset.get_starts) – Return a list of map objects that this map temporally starts with
- [**get_temporal_extent**](#grass.temporal.AbstractSpaceTimeDataset.get_temporal_extent) – Return the temporal extent of the correct internal type
- [**get_temporal_extent_as_tuple**](#grass.temporal.AbstractSpaceTimeDataset.get_temporal_extent_as_tuple) – Returns a tuple of the valid start and end time
- [**get_temporal_relations**](#grass.temporal.AbstractSpaceTimeDataset.get_temporal_relations) – Return the dictionary of temporal relationships
- [**get_temporal_type**](#grass.temporal.AbstractSpaceTimeDataset.get_temporal_type) – Return the temporal type of this dataset
- [**get_type**](#grass.temporal.AbstractSpaceTimeDataset.get_type) – Return the type of this class as string
- [**insert**](#grass.temporal.AbstractSpaceTimeDataset.insert) – Insert the space time dataset content into the database from the internal
- [**is_in_db**](#grass.temporal.AbstractSpaceTimeDataset.is_in_db) – Check if the dataset is registered in the database
- [**is_map_registered**](#grass.temporal.AbstractSpaceTimeDataset.is_map_registered) – Check if a map is registered in the space time dataset
- [**is_spatial_topology_build**](#grass.temporal.AbstractSpaceTimeDataset.is_spatial_topology_build) – Check if the temporal topology was build
- [**is_stds**](#grass.temporal.AbstractSpaceTimeDataset.is_stds) – Return True if this class is a space time dataset
- [**is_temporal_topology_build**](#grass.temporal.AbstractSpaceTimeDataset.is_temporal_topology_build) – Check if the temporal topology was build
- [**is_time_absolute**](#grass.temporal.AbstractSpaceTimeDataset.is_time_absolute) – Return True in case the temporal type is absolute
- [**is_time_relative**](#grass.temporal.AbstractSpaceTimeDataset.is_time_relative) – Return True in case the temporal type is relative
- [**is_topology_build**](#grass.temporal.AbstractSpaceTimeDataset.is_topology_build) – Check if the spatial and temporal topology was build
- [**next**](#grass.temporal.AbstractSpaceTimeDataset.next) – Return the map with a start time temporally located after
- [**prev**](#grass.temporal.AbstractSpaceTimeDataset.prev) – Return the map with a start time temporally located before
- [**print_history**](#grass.temporal.AbstractSpaceTimeDataset.print_history) – Print history information about this class in human readable
- [**print_info**](#grass.temporal.AbstractSpaceTimeDataset.print_info) – Print information about this class in human readable style
- [**print_self**](#grass.temporal.AbstractSpaceTimeDataset.print_self) – Print the content of the internal structure to stdout
- [**print_shell_info**](#grass.temporal.AbstractSpaceTimeDataset.print_shell_info) – Print information about this class in shell style
- [**print_spatial_topology_info**](#grass.temporal.AbstractSpaceTimeDataset.print_spatial_topology_info) – Print information about this class in human readable style
- [**print_spatial_topology_shell_info**](#grass.temporal.AbstractSpaceTimeDataset.print_spatial_topology_shell_info) – Print information about this class in shell style
- [**print_spatio_temporal_relationships**](#grass.temporal.AbstractSpaceTimeDataset.print_spatio_temporal_relationships) – Print the spatio-temporal relationships for each map of the space
- [**print_temporal_topology_info**](#grass.temporal.AbstractSpaceTimeDataset.print_temporal_topology_info) – Print information about this class in human readable style
- [**print_temporal_topology_shell_info**](#grass.temporal.AbstractSpaceTimeDataset.print_temporal_topology_shell_info) – Print information about this class in shell style
- [**print_topology_info**](#grass.temporal.AbstractSpaceTimeDataset.print_topology_info) –
- [**print_topology_shell_info**](#grass.temporal.AbstractSpaceTimeDataset.print_topology_shell_info) –
- [**register_map**](#grass.temporal.AbstractSpaceTimeDataset.register_map) – Register a map in the space time dataset.
- [**rename**](#grass.temporal.AbstractSpaceTimeDataset.rename) – Rename the space time dataset
- [**resample_maplist_by_granularity**](#grass.temporal.AbstractSpaceTimeDataset.resample_maplist_by_granularity) – Resample a list of AbstractMapDatasets by a given granularity
- [**reset**](#grass.temporal.AbstractSpaceTimeDataset.reset) – Reset the internal structure and set the identifier
- [**reset_spatial_topology**](#grass.temporal.AbstractSpaceTimeDataset.reset_spatial_topology) – Reset any information about temporal topology
- [**reset_temporal_topology**](#grass.temporal.AbstractSpaceTimeDataset.reset_temporal_topology) – Reset any information about temporal topology
- [**reset_topology**](#grass.temporal.AbstractSpaceTimeDataset.reset_topology) – Reset any information about temporal topology
- [**sample_by_dataset**](#grass.temporal.AbstractSpaceTimeDataset.sample_by_dataset) – Sample this space time dataset with the temporal topology
- [**sample_by_dataset_sql**](#grass.temporal.AbstractSpaceTimeDataset.sample_by_dataset_sql) – Sample this space time dataset with the temporal topology
- [**select**](#grass.temporal.AbstractSpaceTimeDataset.select) – Select temporal dataset entry from database and fill
- [**set_aggregation_type**](#grass.temporal.AbstractSpaceTimeDataset.set_aggregation_type) – Set the aggregation type of the space time dataset
- [**set_granularity**](#grass.temporal.AbstractSpaceTimeDataset.set_granularity) – Set the granularity
- [**set_id**](#grass.temporal.AbstractSpaceTimeDataset.set_id) – Set the identifier of the dataset
- [**set_initial_values**](#grass.temporal.AbstractSpaceTimeDataset.set_initial_values) – Set the initial values of the space time dataset
- [**set_map_register**](#grass.temporal.AbstractSpaceTimeDataset.set_map_register) – Set the name of the map register table
- [**set_next**](#grass.temporal.AbstractSpaceTimeDataset.set_next) – Set the map that is temporally as closest located after this map.
- [**set_prev**](#grass.temporal.AbstractSpaceTimeDataset.set_prev) – Set the map that is temporally as closest located before this map.
- [**set_relative_time_unit**](#grass.temporal.AbstractSpaceTimeDataset.set_relative_time_unit) – Set the relative time unit which may be of type:
- [**set_spatial_topology_build_false**](#grass.temporal.AbstractSpaceTimeDataset.set_spatial_topology_build_false) – Same as name
- [**set_spatial_topology_build_true**](#grass.temporal.AbstractSpaceTimeDataset.set_spatial_topology_build_true) – Same as name
- [**set_temporal_topology_build_false**](#grass.temporal.AbstractSpaceTimeDataset.set_temporal_topology_build_false) – Same as name
- [**set_temporal_topology_build_true**](#grass.temporal.AbstractSpaceTimeDataset.set_temporal_topology_build_true) – Same as name
- [**set_topology_build_false**](#grass.temporal.AbstractSpaceTimeDataset.set_topology_build_false) – Use this method when the spatio-temporal topology was not build
- [**set_topology_build_true**](#grass.temporal.AbstractSpaceTimeDataset.set_topology_build_true) – Use this method when the spatio-temporal topology was build
- [**shift**](#grass.temporal.AbstractSpaceTimeDataset.shift) – Temporally shift each registered map with the provided granularity
- [**shift_map_list**](#grass.temporal.AbstractSpaceTimeDataset.shift_map_list) – Temporally shift each map in the list with the provided granularity
- [**snap**](#grass.temporal.AbstractSpaceTimeDataset.snap) – For each registered map snap the end time to the start time of
- [**snap_map_list**](#grass.temporal.AbstractSpaceTimeDataset.snap_map_list) – For each map in the list snap the end time to the start time of its
- [**spatial_disjoint_union**](#grass.temporal.AbstractSpaceTimeDataset.spatial_disjoint_union) – Return the spatial union as spatial_extent object.
- [**spatial_intersection**](#grass.temporal.AbstractSpaceTimeDataset.spatial_intersection) – Return the spatial intersection as spatial_extent
- [**spatial_overlapping**](#grass.temporal.AbstractSpaceTimeDataset.spatial_overlapping) – Return True if the spatial extents overlap
- [**spatial_relation**](#grass.temporal.AbstractSpaceTimeDataset.spatial_relation) – Return the spatial relationship between self and dataset
- [**spatial_union**](#grass.temporal.AbstractSpaceTimeDataset.spatial_union) – Return the spatial union as spatial_extent
- [**temporal_disjoint_union**](#grass.temporal.AbstractSpaceTimeDataset.temporal_disjoint_union) – Creates a union with the provided dataset and
- [**temporal_intersection**](#grass.temporal.AbstractSpaceTimeDataset.temporal_intersection) – Intersect self with the provided dataset and
- [**temporal_relation**](#grass.temporal.AbstractSpaceTimeDataset.temporal_relation) – Return the temporal relation of self and the provided dataset
- [**temporal_union**](#grass.temporal.AbstractSpaceTimeDataset.temporal_union) – Creates a union with the provided dataset and
- [**unregister_map**](#grass.temporal.AbstractSpaceTimeDataset.unregister_map) – Unregister a map from the space time dataset.
- [**update**](#grass.temporal.AbstractSpaceTimeDataset.update) – Update the dataset entry in the database from the internal structure
- [**update_all**](#grass.temporal.AbstractSpaceTimeDataset.update_all) – Update the dataset entry in the database from the internal structure
- [**update_command_string**](#grass.temporal.AbstractSpaceTimeDataset.update_command_string) – Append the current command string to any existing command string
- [**update_from_registered_maps**](#grass.temporal.AbstractSpaceTimeDataset.update_from_registered_maps) – This methods updates the modification time, the spatial and

**Attributes:**

- [**contain**](#grass.temporal.AbstractSpaceTimeDataset.contain) –
- [**contains**](#grass.temporal.AbstractSpaceTimeDataset.contains) –
- [**cover**](#grass.temporal.AbstractSpaceTimeDataset.cover) –
- [**covered**](#grass.temporal.AbstractSpaceTimeDataset.covered) –
- [**during**](#grass.temporal.AbstractSpaceTimeDataset.during) –
- [**equal**](#grass.temporal.AbstractSpaceTimeDataset.equal) –
- [**equivalent**](#grass.temporal.AbstractSpaceTimeDataset.equivalent) –
- [**finished**](#grass.temporal.AbstractSpaceTimeDataset.finished) –
- [**finishes**](#grass.temporal.AbstractSpaceTimeDataset.finishes) –
- [**follows**](#grass.temporal.AbstractSpaceTimeDataset.follows) –
- [**in\_**](#grass.temporal.AbstractSpaceTimeDataset.in_) –
- [**map_counter**](#grass.temporal.AbstractSpaceTimeDataset.map_counter) –
- [**meet**](#grass.temporal.AbstractSpaceTimeDataset.meet) –
- [**msgr**](#grass.temporal.AbstractSpaceTimeDataset.msgr) –
- [**overlap**](#grass.temporal.AbstractSpaceTimeDataset.overlap) –
- [**overlapped**](#grass.temporal.AbstractSpaceTimeDataset.overlapped) –
- [**overlaps**](#grass.temporal.AbstractSpaceTimeDataset.overlaps) –
- [**precedes**](#grass.temporal.AbstractSpaceTimeDataset.precedes) –
- [**semantic_label**](#grass.temporal.AbstractSpaceTimeDataset.semantic_label) –
- [**started**](#grass.temporal.AbstractSpaceTimeDataset.started) –
- [**starts**](#grass.temporal.AbstractSpaceTimeDataset.starts) –
- [**temporal_extent**](#grass.temporal.AbstractSpaceTimeDataset.temporal_extent) –

##### grass.temporal.AbstractSpaceTimeDataset.append_contain

```python
append_contain(map)
```

Append a map that this map spatially contains

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_contains

```python
append_contains(map)
```

Append a map that this map temporally contains
This includes temporal relationships started and finished

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_cover

```python
append_cover(map)
```

Append a map that spatially cover this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_covered

```python
append_covered(map)
```

Append a map that is spatially covered by this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_during

```python
append_during(map)
```

Append a map that this map is temporally located during
This includes temporal relationships starts and finishes

:param map: This object should be of type
AbstractMapDataset or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_equal

```python
append_equal(map)
```

Append a map with equivalent temporal extent as this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_equivalent

```python
append_equivalent(map)
```

Append a map with equivalent spatial extent as this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_finished

```python
append_finished(map)
```

Append a map that this map temporally finished with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_finishes

```python
append_finishes(map)
```

Append a map that this map temporally finishes with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_follows

```python
append_follows(map)
```

Append a map that this map temporally follows

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_in

```python
append_in(map)
```

Append a map that this is spatial in this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_meet

```python
append_meet(map)
```

Append a map that spatially meet with this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_overlap

```python
append_overlap(map)
```

Append a map that this spatial overlap with this map

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_overlapped

```python
append_overlapped(map)
```

Append a map that this map temporally overlapped

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_overlaps

```python
append_overlaps(map)
```

Append a map that this map temporally overlaps

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_precedes

```python
append_precedes(map)
```

Append a map that this map temporally precedes

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_started

```python
append_started(map)
```

Append a map that this map temporally started with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.append_starts

```python
append_starts(map)
```

Append a map that this map temporally starts with

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.check_relative_time_unit

```python
check_relative_time_unit(unit)
```

Check if unit is of type year(s), month(s), day(s), hour(s),
minute(s) or second(s)

:param unit: The unit string
:return: True if success, False otherwise

##### grass.temporal.AbstractSpaceTimeDataset.check_temporal_topology

```python
check_temporal_topology(maps=None, dbif=None)
```

Check the temporal topology of all maps of the current space time
dataset or of an optional list of maps

Correct topology means, that time intervals are not overlap or
that intervals does not contain other intervals.
Equal time intervals are not allowed.

The optional map list must be ordered by start time

Allowed and not allowed temporal relationships for correct topology:

- after -> allowed

- precedes -> allowed

- follows -> allowed

- precedes -> allowed

- equal -> not allowed

- during -> not allowed

- contains -> not allowed

- overlaps -> not allowed

- overlapped -> not allowed

- starts -> not allowed

- finishes -> not allowed

- started -> not allowed

- finished -> not allowed

:param maps: An optional list of AbstractDataset objects, in case of
None all maps of the space time dataset are checked
:param dbif: The database interface to be used
:return: True if topology is correct

##### grass.temporal.AbstractSpaceTimeDataset.contain

```python
contain = property(fget=get_contain, fset=append_contain)
```

##### grass.temporal.AbstractSpaceTimeDataset.contains

```python
contains = property(fget=get_contains, fset=append_contains)
```

##### grass.temporal.AbstractSpaceTimeDataset.count_gaps

```python
count_gaps(maps=None, dbif=None)
```

Count the number of gaps between temporal neighbors

:param maps: A sorted (start_time) list of AbstractDataset objects
:param dbif: The database interface to be used
:return: The numbers of gaps between temporal neighbors

##### grass.temporal.AbstractSpaceTimeDataset.count_temporal_relations

```python
count_temporal_relations(maps=None, dbif=None)
```

Count the temporal relations between the registered maps.

The map list must be ordered by start time.
Temporal relations are counted by analysing the sparse upper right
side temporal relationships matrix.

:param maps: A sorted (start_time) list of AbstractDataset objects
:param dbif: The database interface to be used
:return: A dictionary with counted temporal relationships

##### grass.temporal.AbstractSpaceTimeDataset.count_temporal_types

```python
count_temporal_types(maps=None, dbif=None)
```

Return the temporal type of the registered maps as dictionary

The map list can be a list of AbstractDataset or database rows.
It must be ordered by start time

The temporal type can be:

- point -> only the start time is present
- interval -> start and end time
- invalid -> No valid time point or interval found

:param maps: A sorted (start_time) list of AbstractDataset objects or database
rows
:param dbif: The database interface to be used

##### grass.temporal.AbstractSpaceTimeDataset.cover

```python
cover = property(fget=get_cover, fset=append_cover)
```

##### grass.temporal.AbstractSpaceTimeDataset.covered

```python
covered = property(fget=get_covered, fset=append_covered)
```

##### grass.temporal.AbstractSpaceTimeDataset.create_command_string

```python
create_command_string()
```

Create the command string that was used to create this
space time dataset.

The command string should be set with self.metadata.set_command()

:return: The command string

##### grass.temporal.AbstractSpaceTimeDataset.create_map_register_name

```python
create_map_register_name()
```

Create the name of the map register table of this space time
dataset

A uuid and the map type are used to create the table name

ATTENTION: It must be assured that the base object has selected its
content from the database.

:return: The name of the map register table

##### grass.temporal.AbstractSpaceTimeDataset.delete

```python
delete(dbif=None, execute=True)
```

Delete a space time dataset from the temporal database

This method removes the space time dataset from the temporal
database and drops its map register table

:param dbif: The database interface to be used
:param execute: If True the SQL DELETE and DROP table
statements will be executed.
If False the prepared SQL statements are returned
and must be executed by the caller.

:return: The SQL statements if execute == False, else an empty
string

##### grass.temporal.AbstractSpaceTimeDataset.during

```python
during = property(fget=get_during, fset=append_during)
```

##### grass.temporal.AbstractSpaceTimeDataset.equal

```python
equal = property(fget=get_equal, fset=append_equal)
```

##### grass.temporal.AbstractSpaceTimeDataset.equivalent

```python
equivalent = property(fget=get_equivalent, fset=append_equivalent)
```

##### grass.temporal.AbstractSpaceTimeDataset.finished

```python
finished = property(fget=get_finished, fset=append_finished)
```

##### grass.temporal.AbstractSpaceTimeDataset.finishes

```python
finishes = property(fget=get_finishes, fset=append_finishes)
```

##### grass.temporal.AbstractSpaceTimeDataset.follows

```python
follows = property(fget=get_follows, fset=append_follows)
```

##### grass.temporal.AbstractSpaceTimeDataset.get_absolute_time

```python
get_absolute_time()
```

Returns the start time, the end
time of the map as tuple

The start time is of type datetime.

The end time is of type datetime in case of interval time,
or None on case of a time instance.

:return: A tuple of (start_time, end_time)

##### grass.temporal.AbstractSpaceTimeDataset.get_contain

```python
get_contain()
```

Return a list of map objects that this map contains

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_contains

```python
get_contains()
```

Return a list of map objects that this map temporally contains
This includes temporal relationships started and finished

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_cover

```python
get_cover()
```

Return a list of map objects that spatially cover this map

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_covered

```python
get_covered()
```

Return a list of map objects that are spatially covered by this map

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_during

```python
get_during()
```

Return a list of map objects that this map is temporally located during
This includes temporally relationships starts and finishes

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_equal

```python
get_equal()
```

Return a list of map objects with equivalent temporal extent as
this map

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_equivalent

```python
get_equivalent()
```

Return a list of map objects with equivalent spatial extent as this map

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_finished

```python
get_finished()
```

Return a list of map objects that this map temporally finished with

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_finishes

```python
get_finishes()
```

Return a list of map objects that this map temporally finishes with

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_follows

```python
get_follows()
```

Return a list of map objects that this map temporally follows

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_granularity

```python
get_granularity()
```

Return the granularity of the space time dataset

Granularity can be of absolute time or relative time.
In case of absolute time a string containing an integer
value and the time unit (years, months, days, hours, minutes,
seconds). In case of relative time an integer value is expected.

:return: The granularity

##### grass.temporal.AbstractSpaceTimeDataset.get_id

```python
get_id()
```

Return the unique identifier of the dataset
:return: The id of the dataset "name(:layer)@mapset" as string

##### grass.temporal.AbstractSpaceTimeDataset.get_in

```python
get_in()
```

Return a list of map objects that are spatial in this map

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_initial_values

```python
get_initial_values()
```

Return the initial values: temporal_type,
semantic_type, title, description

##### grass.temporal.AbstractSpaceTimeDataset.get_map_register

```python
get_map_register()
```

Return the name of the map register table
:return: The map register table name

##### grass.temporal.AbstractSpaceTimeDataset.get_map_time

```python
get_map_time()
```

Return the type of the map time, interval, point, mixed or invalid

##### grass.temporal.AbstractSpaceTimeDataset.get_mapset

```python
get_mapset()
```

Return the mapset
:return: The mapset in which the dataset was created as string

##### grass.temporal.AbstractSpaceTimeDataset.get_meet

```python
get_meet()
```

Return a list of map objects that spatially meet with this map

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_name

```python
get_name(semantic_label=True)
```

Get dataset name including semantic label filter if enabled.

:param bool semantic_label: True to return dataset name
including semantic label filter if defined
(eg. "landsat.L8_1") otherwise dataset name is returned only
(eg. "landsat").

:return str: dataset name

##### grass.temporal.AbstractSpaceTimeDataset.get_new_instance

```python
get_new_instance(ident)
```

Return a new instance with the type of this class

:param ident: The identifier of the new dataset instance
:return: A new instance with the type of this object

##### grass.temporal.AbstractSpaceTimeDataset.get_new_map_instance

```python
get_new_map_instance(ident=None)
```

Return a new instance of a map which is associated
with the type of this object

:param ident: The unique identifier of the new object

##### grass.temporal.AbstractSpaceTimeDataset.get_number_of_relations

```python
get_number_of_relations()
```

Return a dictionary in which the keys are the relation names and the
value are the number of relations.

The following relations are available:

Spatial relations:

```
- equivalent
- overlap
- in
- contain
- meet
- cover
- covered
```

Temporal relations:

```
- equal
- follows
- precedes
- overlaps
- overlapped
- during (including starts, finishes)
- contains (including started, finished)
- starts
- started
- finishes
- finished
```

To access topological information the spatial, temporal or booth
topologies must be build first using the SpatioTemporalTopologyBuilder.

:return: The dictionary with relations as keys and number as values or
None in case the topology wasn't built

##### grass.temporal.AbstractSpaceTimeDataset.get_number_of_spatial_relations

```python
get_number_of_spatial_relations()
```

Return a dictionary in which the keys are the relation names and the value
are the number of relations.

The following relations are available:

- equivalent
- overlap
- in
- contain
- meet
- cover
- covered

To access topological information the spatial topology must be
build first using the SpatialTopologyBuilder.

:return: the dictionary with relations as keys and number as
values or None in case the topology wasn't build

##### grass.temporal.AbstractSpaceTimeDataset.get_number_of_temporal_relations

```python
get_number_of_temporal_relations()
```

Return a dictionary in which the keys are the relation names and
the value are the number of relations.

The following relations are available:

- equal
- follows
- precedes
- overlaps
- overlapped
- during (including starts, finishes)
- contains (including started, finished)
- starts
- started
- finishes
- finished

To access topological information the temporal topology must be build
first using the SpatioTemporalTopologyBuilder.

:return: the dictionary with relations as keys and number as values
or None in case the topology wasn't build

##### grass.temporal.AbstractSpaceTimeDataset.get_overlap

```python
get_overlap()
```

Return a list of map objects that this map spatial overlap with

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_overlapped

```python
get_overlapped()
```

Return a list of map objects that this map temporally overlapped

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_overlaps

```python
get_overlaps()
```

Return a list of map objects that this map temporally overlaps

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_precedes

```python
get_precedes()
```

Return a list of map objects that this map temporally precedes

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_registered_maps

```python
get_registered_maps(columns=None, where=None, order=None, dbif=None, group=None, spatial_extent=None, spatial_relation=None)
```

Return SQL rows of the selected registered maps.

In case neither columns nor columns for grouping (group)
are specified, each returned row represents a dataset and
includes all columns specified in the datatype specific view.

If group is not None, the rows in the register tables are
grouped_by the list of columns in the group option. This
function is useful to retrieve e.g. granules from an STRDS
with satellite imagery where scene consists of different bands
that have different semantic_labels but equal an temporal extend
(group=["strat_time", "end_time"]).
The returned SQL rows of grouped output contain the selected
columns plus the columns in the group option. If no columns
are selected only the "id" column is returned. Content of the
selected columns is concatenated to a comma separated string.

The combination of the spatial_extent and spatial_relation parameters
can be used to return only SQL rows of maps with the given spatial
relation to the provided spatial extent

:param columns: Columns to be selected as SQL compliant string,
default is "\*" or "id" if group is given.
:param where: The SQL where statement to select a subset
of the registered maps without "WHERE"
:param group: The columns to be used in the SQL GROUP BY statement
as SQL compliant string without "GROUP BY"
:param spatial_extent: Spatial extent dict and projection information
e.g. from g.region -ug3 with GRASS GIS region keys
"n", "s", "e", "w", "b", "t", and "projection".
:param spatial_relation: Spatial relation to the provided
spatial extent as a string with one of the following values:
"overlaps": maps that spatially overlap ("intersect")
within the provided spatial extent
"is_contained": maps that are fully within the provided spatial extent
"contains": maps that contain (fully cover) the provided spatial extent
:param dbif: The database interface to be used

:return: SQL rows of all registered maps grouped by the columns given in
the group option, in case no maps are found, None is returned

##### grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects

```python
get_registered_maps_as_objects(where=None, order='start_time', dbif=None, spatial_extent=None, spatial_relation=None)
```

Return all or a subset of the registered maps as ordered object
list for spatio-temporal topological operations that require the
spatio-temporal extent only

The objects are initialized with their id's' and the spatio-temporal
extent (temporal type, start time, end time, west, east, south,
north, bottom and top).
In case more map information are needed, use the select()
method for each listed object.

The combination of the spatial_extent and spatial_relation parameters
can be used to return only maps with the given spatial relation to
the provided spatial extent

:param where: The SQL where statement to select a subset of
the registered maps without "WHERE"
:param order: The SQL order statement to be used to order the
objects in the list without "ORDER BY"
:param dbif: The database interface to be used
:param spatial_extent: Spatial extent dict and projection information
e.g. from g.region -ug3 with GRASS GIS region keys
"n", "s", "e", "w", "b", "t", and "projection".
:param spatial_relation: Spatial relation to the provided
spatial extent as a string with one of the following values:
"overlaps": maps that spatially overlap ("intersect")
within the provided spatial extent
"is_contained": maps that are fully within the provided spatial extent
"contains": maps that contain (fully cover) the provided spatial extent

:return: The ordered map object list,
In case nothing is found, an empty list is returned

##### grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects_by_granularity

```python
get_registered_maps_as_objects_by_granularity(gran=None, dbif=None)
```

Return all registered maps as ordered (by start_time) object list
with "gap" map objects (id==None) for spatio-temporal topological
operations that require the temporal extent only.

Each list entry is a list of AbstractMapDatasets objects
which are potentially equal the actual granule, contain the
actual granule or are located in the actual granule.
Hence for each granule a list of AbstractMapDatasets can be
expected.

Maps that overlap the granule are ignored.

The granularity of the space time dataset is used as increment in
case the granule is not user defined.

A valid temporal topology (no overlapping or inclusion allowed)
is needed to get correct results.

Space time datasets with interval time, time instances and mixed
time are supported.

Gaps between maps are identified as unregistered maps with id==None.

The objects are initialized with their id's' and the spatio-temporal
extent (temporal type, start time, end time, west, east, south,
north, bottom and top).
In case more map information are needed, use the select()
method for each listed object.

:param gran: The granularity string to be used, if None the
granularity of the space time dataset is used.
Absolute time has the format "number unit", relative
time has the format "number".
The unit in case of absolute time can be one of "second,
seconds, minute, minutes, hour, hours, day, days, week,
weeks, month, months, year, years". The unit of the
relative time granule is always the space time dataset
unit and can not be changed.
:param dbif: The database interface to be used

:return: ordered list of map lists. Each list represents a single
granule, or None in case nothing found

##### grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects_with_gaps

```python
get_registered_maps_as_objects_with_gaps(where=None, dbif=None, spatial_extent=None, spatial_relation=None)
```

Return all or a subset of the registered maps as
ordered (by start_time) object list with
"gap" map objects (id==None) for spatio-temporal topological
operations that require the spatio-temporal extent only.

Gaps between maps are identified as maps with id==None

The objects are initialized with their id's' and the spatio-temporal
extent (temporal type, start time, end time, west, east, south,
north, bottom and top).
In case more map information are needed, use the select()
method for each listed object.

The combination of the spatial_extent and spatial_relation parameters
can be used to return only map objects with the given spatial relation
to the provided spatial extent.

:param where: The SQL where statement to select a
subset of the registered maps without "WHERE"
:param dbif: The database interface to be used
:param spatial_extent: Spatial extent dict and projection information
e.g. from g.region -ug3 with GRASS GIS region keys
"n", "s", "e", "w", "b", "t", and "projection".
:param spatial_relation: Spatial relation to the provided
spatial extent as a string with one of the following values:
"overlaps": maps that spatially overlap ("intersect")
within the provided spatial extent
"is_contained": maps that are fully within the provided spatial extent
"contains": maps that contain (fully cover) the provided spatial extent

:return: ordered object list, in case nothing found None is returned

##### grass.temporal.AbstractSpaceTimeDataset.get_registered_maps_as_objects_with_temporal_topology

```python
get_registered_maps_as_objects_with_temporal_topology(where=None, order='start_time', dbif=None, spatial_extent=None, spatial_relation=None)
```

Return all or a subset of the registered maps as ordered object
list with spatio-temporal topological relationship information.

The objects are initialized with their id's' and the spatio-temporal
extent (temporal type, start time, end time, west, east, south,
north, bottom and top).
In case more map information are needed, use the select()
method for each listed object.

The combination of the spatial_extent and spatial_relation parameters
can be used to return only maps with the given spatial relation to
the provided spatial extent

:param where: The SQL where statement to select a subset of
the registered maps without "WHERE"
:param order: The SQL order statement to be used to order the
objects in the list without "ORDER BY"
:param dbif: The database interface to be used
:param spatial_extent: Spatial extent dict and projection information
e.g. from g.region -ug3 with GRASS GIS region keys
"n", "s", "e", "w", "b", "t", and "projection".
:param spatial_relation: Spatial relation to the provided
spatial extent as a string with one of the following values:
"overlaps": maps that spatially overlap ("intersect")
within the provided spatial extent
"is_contained": maps that are fully within the provided spatial extent
"contains": maps that contain (fully cover) the provided spatial extent

:return: The ordered map object list,
In case nothing found None is returned

##### grass.temporal.AbstractSpaceTimeDataset.get_relative_time

```python
get_relative_time()
```

Returns the start time, the end
time and the temporal unit of the dataset as tuple

The start time is of type integer.

The end time is of type integer in case of interval time,
or None on case of a time instance.

:return: A tuple of (start_time, end_time, unit)

##### grass.temporal.AbstractSpaceTimeDataset.get_relative_time_unit

```python
get_relative_time_unit()
```

Returns the relative time unit
:return: The relative time unit as string, None if not present

##### grass.temporal.AbstractSpaceTimeDataset.get_semantic_type

```python
get_semantic_type()
```

Return the semantic type of this dataset
:return: The semantic type

##### grass.temporal.AbstractSpaceTimeDataset.get_spatial_extent

```python
get_spatial_extent()
```

Return the spatial extent

##### grass.temporal.AbstractSpaceTimeDataset.get_spatial_extent_as_tuple

```python
get_spatial_extent_as_tuple()
```

Return the spatial extent as tuple

Top and bottom are set to 0 in case of a two dimensional spatial
extent.

:return: A the spatial extent as tuple (north, south, east, west, top, bottom)

##### grass.temporal.AbstractSpaceTimeDataset.get_spatial_relations

```python
get_spatial_relations()
```

Return the dictionary of spatial relationships

Keys are the spatial relationships in upper case,
values are abstract map objects.

:return: The spatial relations dictionary

##### grass.temporal.AbstractSpaceTimeDataset.get_started

```python
get_started()
```

Return a list of map objects that this map temporally started with

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_starts

```python
get_starts()
```

Return a list of map objects that this map temporally starts with

:return: A list of map objects or None

##### grass.temporal.AbstractSpaceTimeDataset.get_temporal_extent

```python
get_temporal_extent()
```

Return the temporal extent of the correct internal type

##### grass.temporal.AbstractSpaceTimeDataset.get_temporal_extent_as_tuple

```python
get_temporal_extent_as_tuple()
```

Returns a tuple of the valid start and end time

Start and end time can be either of type datetime or of type
integer, depending on the temporal type.

:return: A tuple of (start_time, end_time)

##### grass.temporal.AbstractSpaceTimeDataset.get_temporal_relations

```python
get_temporal_relations()
```

Return the dictionary of temporal relationships

Keys are the temporal relationships in upper case,
values are abstract map objects.

:return: The temporal relations dictionary

##### grass.temporal.AbstractSpaceTimeDataset.get_temporal_type

```python
get_temporal_type()
```

Return the temporal type of this dataset

The temporal type can be absolute or relative

:return: The temporal type of the dataset as string

##### grass.temporal.AbstractSpaceTimeDataset.get_type

```python
get_type()
```

Return the type of this class as string

The type can be "vector", "raster", "raster3d", "stvds", "strds" or "str3ds"

:return: "vector", "raster", "raster3d", "stvds", "strds" or "str3ds"

##### grass.temporal.AbstractSpaceTimeDataset.in\_

```python
in_ = property(fget=get_in, fset=append_in)
```

##### grass.temporal.AbstractSpaceTimeDataset.insert

```python
insert(dbif=None, execute=True)
```

Insert the space time dataset content into the database from the internal
structure

The map register table will be created, so that maps
can be registered.

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.
:return: The SQL insert statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractSpaceTimeDataset.is_in_db

```python
is_in_db(dbif=None, mapset=None)
```

Check if the dataset is registered in the database

:param dbif: The database interface to be used
:param mapset: The dbif connection to be used
:return: True if the dataset is registered in the database

##### grass.temporal.AbstractSpaceTimeDataset.is_map_registered

```python
is_map_registered(map_id, dbif=None)
```

Check if a map is registered in the space time dataset

:param map_id: The map id
:param dbif: The database interface to be used
:return: True if success, False otherwise

##### grass.temporal.AbstractSpaceTimeDataset.is_spatial_topology_build

```python
is_spatial_topology_build()
```

Check if the temporal topology was build

##### grass.temporal.AbstractSpaceTimeDataset.is_stds

```python
is_stds()
```

Return True if this class is a space time dataset

:return: True if this class is a space time dataset, False otherwise

##### grass.temporal.AbstractSpaceTimeDataset.is_temporal_topology_build

```python
is_temporal_topology_build()
```

Check if the temporal topology was build

##### grass.temporal.AbstractSpaceTimeDataset.is_time_absolute

```python
is_time_absolute()
```

Return True in case the temporal type is absolute

:return: True if temporal type is absolute, False otherwise

##### grass.temporal.AbstractSpaceTimeDataset.is_time_relative

```python
is_time_relative()
```

Return True in case the temporal type is relative

:return: True if temporal type is relative, False otherwise

##### grass.temporal.AbstractSpaceTimeDataset.is_topology_build

```python
is_topology_build()
```

Check if the spatial and temporal topology was build

:return: A dictionary with "spatial" and "temporal" as keys that
have boolean values

##### grass.temporal.AbstractSpaceTimeDataset.map_counter

```python
map_counter = 0
```

##### grass.temporal.AbstractSpaceTimeDataset.meet

```python
meet = property(fget=get_meet, fset=append_meet)
```

##### grass.temporal.AbstractSpaceTimeDataset.msgr

```python
msgr = get_tgis_message_interface()
```

##### grass.temporal.AbstractSpaceTimeDataset.next

```python
next()
```

Return the map with a start time temporally located after
the start time of this map, but temporal closer than other maps

:return: A map object or None

##### grass.temporal.AbstractSpaceTimeDataset.overlap

```python
overlap = property(fget=get_overlap, fset=append_overlap)
```

##### grass.temporal.AbstractSpaceTimeDataset.overlapped

```python
overlapped = property(fget=get_overlapped, fset=append_overlapped)
```

##### grass.temporal.AbstractSpaceTimeDataset.overlaps

```python
overlaps = property(fget=get_overlaps, fset=append_overlaps)
```

##### grass.temporal.AbstractSpaceTimeDataset.precedes

```python
precedes = property(fget=get_precedes, fset=append_precedes)
```

##### grass.temporal.AbstractSpaceTimeDataset.prev

```python
prev()
```

Return the map with a start time temporally located before
the start time of this map, but temporal closer than other maps

:return: A map object or None

##### grass.temporal.AbstractSpaceTimeDataset.print_history

```python
print_history()
```

Print history information about this class in human readable
shell style

##### grass.temporal.AbstractSpaceTimeDataset.print_info

```python
print_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractSpaceTimeDataset.print_self

```python
print_self()
```

Print the content of the internal structure to stdout

##### grass.temporal.AbstractSpaceTimeDataset.print_shell_info

```python
print_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractSpaceTimeDataset.print_spatial_topology_info

```python
print_spatial_topology_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractSpaceTimeDataset.print_spatial_topology_shell_info

```python
print_spatial_topology_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractSpaceTimeDataset.print_spatio_temporal_relationships

```python
print_spatio_temporal_relationships(maps=None, spatial=None, dbif=None)
```

Print the spatio-temporal relationships for each map of the space
time dataset or for each map of the optional list of maps

:param maps: a ordered by start_time list of map objects, if None
the registered maps of the space time dataset are used
:param spatial: This indicates if the spatial topology is created as
well: spatial can be None (no spatial topology),
"2D" using west, east, south, north or "3D" using
west, east, south, north, bottom, top
:param dbif: The database interface to be used

##### grass.temporal.AbstractSpaceTimeDataset.print_temporal_topology_info

```python
print_temporal_topology_info()
```

Print information about this class in human readable style

##### grass.temporal.AbstractSpaceTimeDataset.print_temporal_topology_shell_info

```python
print_temporal_topology_shell_info()
```

Print information about this class in shell style

##### grass.temporal.AbstractSpaceTimeDataset.print_topology_info

```python
print_topology_info()
```

##### grass.temporal.AbstractSpaceTimeDataset.print_topology_shell_info

```python
print_topology_shell_info()
```

##### grass.temporal.AbstractSpaceTimeDataset.register_map

```python
register_map(map, dbif=None)
```

Register a map in the space time dataset.

This method takes care of the registration of a map
in a space time dataset.

In case the map is already registered this function
will break with a warning and return False.

This method raises a FatalError exception in case of a fatal error

:param map: The AbstractMapDataset object that should be registered
:param dbif: The database interface to be used
:return: True if success, False otherwise

##### grass.temporal.AbstractSpaceTimeDataset.rename

```python
rename(ident, dbif=None)
```

Rename the space time dataset

This method renames the space time dataset, the map register table
and updates the entries in registered maps stds register.

Renaming does not work with Postgresql yet.

:param ident: The new identifier "name@mapset"
:param dbif: The database interface to be used

##### grass.temporal.AbstractSpaceTimeDataset.resample_maplist_by_granularity

```python
resample_maplist_by_granularity(maps, start, end, gran)
```

Resample a list of AbstractMapDatasets by a given granularity

The provided map list must be sorted by start time.
A valid temporal topology (no overlapping or inclusion allowed)
is needed to receive correct results.

Maps with interval time, time instances and mixed
time are supported.

The temporal topology search order is as follows:

1. Maps that are equal to the actual granule are used
1. If no equal found then maps that contain the actual granule
   are used
1. If no maps are found that contain the actual granule then maps
   are used that overlaps the actual granule
1. If no overlaps maps found then overlapped maps are used
1. If no overlapped maps are found then maps are used that are
   during the actual granule

Each entry in the resulting list is a list of
AbstractMapDatasets objects.
Hence for each granule a list of AbstractMapDatasets can be
expected.

Gaps between maps are identified as unregistered maps with id==None.

:param maps: An ordered list (by start time) of AbstractMapDatasets
objects. All maps must have the same temporal type
and the same unit in case of relative time.
:param start: The start time of the provided map list
:param end: The end time of the provided map list
:param gran: The granularity string to be used, if None the
granularity of the space time dataset is used.
Absolute time has the format "number unit", relative
time has the format "number".
The unit in case of absolute time can be one of "second,
seconds, minute, minutes, hour, hours, day, days, week,
weeks, month, months, year, years". The unit of the
relative time granule is always the space time dataset
unit and can not be changed.

:return: ordered list of map lists. Each list represents a single
granule, or None in case nothing found

Usage:

.. code-block:: python

```
 >>> import grass.temporal as tgis
 >>> maps = []
 >>> for i in range(3):
 ...     map = tgis.RasterDataset("map%i@PERMANENT" % i)
 ...     check = map.set_relative_time(i + 2, i + 3, "days")
 ...     maps.append(map)
 ...
 >>> grans = tgis.AbstractSpaceTimeDataset.resample_maplist_by_granularity(
 ...     maps, 0, 8, 1
 ... )
 >>> for map_list in grans:
 ...     print(
 ...         map_list[0].get_id(),
 ...         map_list[0].get_temporal_extent_as_tuple(),
 ...     )
 ...
 None (0, 1)
 None (1, 2)
 map0@PERMANENT (2, 3)
 map1@PERMANENT (3, 4)
 map2@PERMANENT (4, 5)
 None (5, 6)
 None (6, 7)
 None (7, 8)

 >>> maps = []
 >>> map1 = tgis.RasterDataset("map1@PERMANENT")
 >>> check = map1.set_relative_time(2, 6, "days")
 >>> maps.append(map1)
 >>> map2 = tgis.RasterDataset("map2@PERMANENT")
 >>> check = map2.set_relative_time(7, 13, "days")
 >>> maps.append(map2)
 >>> grans = tgis.AbstractSpaceTimeDataset.resample_maplist_by_granularity(
 ...     maps, 0, 16, 2
 ... )
 >>> for map_list in grans:
 ...     print(
 ...         map_list[0].get_id(),
 ...         map_list[0].get_temporal_extent_as_tuple(),
 ...     )
 ...
 None (0, 2)
 map1@PERMANENT (2, 4)
 map1@PERMANENT (4, 6)
 map2@PERMANENT (6, 8)
 map2@PERMANENT (8, 10)
 map2@PERMANENT (10, 12)
 map2@PERMANENT (12, 14)
 None (14, 16)

 >>> maps = []
 >>> map1 = tgis.RasterDataset("map1@PERMANENT")
 >>> check = map1.set_relative_time(2, None, "days")
 >>> maps.append(map1)
 >>> map2 = tgis.RasterDataset("map2@PERMANENT")
 >>> check = map2.set_relative_time(7, None, "days")
 >>> maps.append(map2)
 >>> grans = tgis.AbstractSpaceTimeDataset.resample_maplist_by_granularity(
 ...     maps, 0, 16, 2
 ... )
 >>> for map_list in grans:
 ...     print(
 ...         map_list[0].get_id(),
 ...         map_list[0].get_temporal_extent_as_tuple(),
 ...     )
 ...
 None (0, 2)
 map1@PERMANENT (2, 4)
 None (4, 6)
 map2@PERMANENT (6, 8)
 None (8, 10)
 None (10, 12)
 None (12, 14)
 None (14, 16)

 >>> maps = []
 >>> map1 = tgis.RasterDataset("map1@PERMANENT")
 >>> check = map1.set_absolute_time(
 ...     datetime(2000, 4, 1), datetime(2000, 6, 1)
 ... )
 >>> maps.append(map1)
 >>> map2 = tgis.RasterDataset("map2@PERMANENT")
 >>> check = map2.set_absolute_time(
 ...     datetime(2000, 8, 1), datetime(2000, 12, 1)
 ... )
 >>> maps.append(map2)
 >>> grans = tgis.AbstractSpaceTimeDataset.resample_maplist_by_granularity(
 ...     maps, datetime(2000, 1, 1), datetime(2001, 4, 1), "1 month"
 ... )
 >>> for map_list in grans:
 ...     print(
 ...         map_list[0].get_id(),
 ...         map_list[0].get_temporal_extent_as_tuple(),
 ...     )
 ...
 None (datetime.datetime(2000, 1, 1, 0, 0), datetime.datetime(2000, 2, 1, 0, 0))
 None (datetime.datetime(2000, 2, 1, 0, 0), datetime.datetime(2000, 3, 1, 0, 0))
 None (datetime.datetime(2000, 3, 1, 0, 0), datetime.datetime(2000, 4, 1, 0, 0))
 map1@PERMANENT (datetime.datetime(2000, 4, 1, 0, 0), datetime.datetime(2000, 5, 1, 0, 0))
 map1@PERMANENT (datetime.datetime(2000, 5, 1, 0, 0), datetime.datetime(2000, 6, 1, 0, 0))
 None (datetime.datetime(2000, 6, 1, 0, 0), datetime.datetime(2000, 7, 1, 0, 0))
 None (datetime.datetime(2000, 7, 1, 0, 0), datetime.datetime(2000, 8, 1, 0, 0))
 map2@PERMANENT (datetime.datetime(2000, 8, 1, 0, 0), datetime.datetime(2000, 9, 1, 0, 0))
 map2@PERMANENT (datetime.datetime(2000, 9, 1, 0, 0), datetime.datetime(2000, 10, 1, 0, 0))
 map2@PERMANENT (datetime.datetime(2000, 10, 1, 0, 0), datetime.datetime(2000, 11, 1, 0, 0))
 map2@PERMANENT (datetime.datetime(2000, 11, 1, 0, 0), datetime.datetime(2000, 12, 1, 0, 0))
 None (datetime.datetime(2000, 12, 1, 0, 0), datetime.datetime(2001, 1, 1, 0, 0))
 None (datetime.datetime(2001, 1, 1, 0, 0), datetime.datetime(2001, 2, 1, 0, 0))
 None (datetime.datetime(2001, 2, 1, 0, 0), datetime.datetime(2001, 3, 1, 0, 0))
 None (datetime.datetime(2001, 3, 1, 0, 0), datetime.datetime(2001, 4, 1, 0, 0))
```

##### grass.temporal.AbstractSpaceTimeDataset.reset

```python
reset(ident)
```

Reset the internal structure and set the identifier

This method creates the dataset specific internal objects
that store the base information, the spatial and temporal extent
and the metadata. It must be implemented in the dataset
specific subclasses. This is the code for the
vector dataset:

.. code-block:: python

```
 self.base = VectorBase(ident=ident)
 self.absolute_time = VectorAbsoluteTime(ident=ident)
 self.relative_time = VectorRelativeTime(ident=ident)
 self.spatial_extent = VectorSpatialExtent(ident=ident)
 self.metadata = VectorMetadata(ident=ident)
```

:param ident: The identifier of the dataset that "name@mapset" or
in case of vector maps "name:layer@mapset"

##### grass.temporal.AbstractSpaceTimeDataset.reset_spatial_topology

```python
reset_spatial_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractSpaceTimeDataset.reset_temporal_topology

```python
reset_temporal_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractSpaceTimeDataset.reset_topology

```python
reset_topology()
```

Reset any information about temporal topology

##### grass.temporal.AbstractSpaceTimeDataset.sample_by_dataset

```python
sample_by_dataset(stds, method=None, spatial=False, dbif=None)
```

Sample this space time dataset with the temporal topology
of a second space time dataset

In case spatial is True, the spatial overlap between
temporal related maps is performed. Only
temporal related and spatial overlapping maps are returned.

Return all registered maps as ordered (by start_time) object list.
Each list entry is a list of map
objects which are potentially located in temporal relation to the
actual granule of the second space time dataset.

Each entry in the object list is a dict. The actual sampler
map and its temporal extent (the actual granule) and
the list of samples are stored:

.. code-block:: python

```
list = self.sample_by_dataset(
    stds=sampler, method=["during", "overlap", "contains", "equal"]
)
for entry in list:
    granule = entry["granule"]
    maplist = entry["samples"]
    for map in maplist:
        map.select()
        map.print_info()
```

A valid temporal topology (no overlapping or inclusion allowed)
is needed to get correct results in case of gaps in the sample
dataset.

Gaps between maps are identified as unregistered maps with id==None.

The objects are initialized with their id's' and the spatio-temporal
extent (temporal type, start time, end time, west, east, south,
north, bottom and top).
In case more map information are needed, use the select()
method for each listed object.

:param stds: The space time dataset to be used for temporal sampling
:param method: This option specifies what sample method should be
used. In case the registered maps are of temporal
point type, only the start time is used for sampling.
In case of mixed of interval data the user can chose
between:

```
   - Example ["start", "during", "equals"]

   - start: Select maps of which the start time is
     located in the selection granule:

     .. code-block:: output
         map    :        s
         granule:  s-----------------e

         map    :        s--------------------e
         granule:  s-----------------e

         map    :        s--------e
         granule:  s-----------------e

   - contains: Select maps which are temporal
     during the selection granule:

     .. code-block:: output
         map    :     s-----------e
         granule:  s-----------------e

   - overlap: Select maps which temporal overlap
     the selection granule, this includes overlaps and
     overlapped:

     .. code-block:: output
         map    :     s-----------e
         granule:        s-----------------e

         map    :     s-----------e
         granule:  s----------e

   - during: Select maps which temporally contains
     the selection granule:

     .. code-block:: output
         map    :  s-----------------e
         granule:     s-----------e

   - equals: Select maps which temporally equal
     to the selection granule:

     .. code-block:: output
         map    :  s-----------e
         granule:  s-----------e

   - follows: Select maps which temporally follow
     the selection granule:

     .. code-block:: output
         map    :              s-----------e
         granule:  s-----------e

   - precedes: Select maps which temporally precedes
     the selection granule:

     .. code-block:: output
         map    :  s-----------e
         granule:              s-----------e

   All these methods can be combined. Method must be of
   type tuple including the identification strings.
```

:param spatial: If set True additional the 2d spatial overlapping
is used for selection -> spatio-temporal relation.
The returned map objects will have temporal and
spatial extents
:param dbif: The database interface to be used

:return: A list of lists of map objects or None in case nothing was
found None

##### grass.temporal.AbstractSpaceTimeDataset.sample_by_dataset_sql

```python
sample_by_dataset_sql(stds, method=None, spatial=False, dbif=None)
```

Sample this space time dataset with the temporal topology
of a second space time dataset using SQL queries.

This function is very slow for huge large space time datasets
but can run several times in the same process without problems.

The sample dataset must have "interval" as temporal map type,
so all sample maps have valid interval time.

In case spatial is True, the spatial overlap between
temporal related maps is performed. Only
temporal related and spatial overlapping maps are returned.

Return all registered maps as ordered (by start_time) object list
with "gap" map objects (id==None). Each list entry is a list of map
objects which are potentially located in temporal relation to the
actual granule of the second space time dataset.

Each entry in the object list is a dict. The actual sampler
map and its temporal extent (the actual granule) and
the list of samples are stored:

.. code-block:: python

```
list = self.sample_by_dataset(
    stds=sampler, method=["during", "overlap", "contain", "equal"]
)
for entry in list:
    granule = entry["granule"]
    maplist = entry["samples"]
    for map in maplist:
        map.select()
        map.print_info()
```

A valid temporal topology (no overlapping or inclusion allowed)
is needed to get correct results in case of gaps in the sample
dataset.

Gaps between maps are identified as unregistered maps with id==None.

The objects are initialized with their id's' and the spatio-temporal
extent (temporal type, start time, end time, west, east, south,
north, bottom and top).
In case more map information are needed, use the select()
method for each listed object.

:param stds: The space time dataset to be used for temporal sampling
:param method: This option specifies what sample method should be
used. In case the registered maps are of temporal
point type, only the start time is used for sampling.
In case of mixed of interval data the user can chose
between:

```
   - Example ["start", "during", "equals"]

   - start: Select maps of which the start time is
     located in the selection granule:

     .. code-block:: output
         map    :        s
         granule:  s-----------------e

         map    :        s--------------------e
         granule:  s-----------------e

         map    :        s--------e
         granule:  s-----------------e

   - contains: Select maps which are temporal
     during the selection granule:

     .. code-block:: output
         map    :     s-----------e
         granule:  s-----------------e

   - overlap: Select maps which temporal overlap
     the selection granule, this includes overlaps and
     overlapped:

     .. code-block:: output
         map    :     s-----------e
         granule:        s-----------------e

         map    :     s-----------e
         granule:  s----------e

   - during: Select maps which temporally contains
     the selection granule:

     .. code-block:: output
         map    :  s-----------------e
         granule:     s-----------e

   - equals: Select maps which temporally equal
     to the selection granule:

     .. code-block:: output
         map    :  s-----------e
         granule:  s-----------e

   - follows: Select maps which temporally follow
     the selection granule:

     .. code-block:: output
         map    :              s-----------e
         granule:  s-----------e

   - precedes: Select maps which temporally precedes
     the selection granule:

     .. code-block:: output
         map    :  s-----------e
         granule:              s-----------e

   All these methods can be combined. Method must be of
   type tuple including the identification strings.
```

:param spatial: If set True additional the 2d spatial overlapping
is used for selection -> spatio-temporal relation.
The returned map objects will have temporal and
spatial extents
:param dbif: The database interface to be used

:return: A list of lists of map objects or None in case nothing was
found None

##### grass.temporal.AbstractSpaceTimeDataset.select

```python
select(dbif=None, mapset=None)
```

Select temporal dataset entry from database and fill
the internal structure

The content of every dataset is stored in the temporal database.
This method must be used to fill this object with the content
from the temporal database.

:param dbif: The database interface to be used
:param mapset: The dbif connection to be used

##### grass.temporal.AbstractSpaceTimeDataset.semantic_label

```python
semantic_label = None
```

##### grass.temporal.AbstractSpaceTimeDataset.set_aggregation_type

```python
set_aggregation_type(aggregation_type)
```

Set the aggregation type of the space time dataset

:param aggregation_type: The aggregation type of the space time
dataset

##### grass.temporal.AbstractSpaceTimeDataset.set_granularity

```python
set_granularity(granularity)
```

Set the granularity

The granularity is usually computed by the space time dataset at
runtime.

Granularity can be of absolute time or relative time.
In case of absolute time a string containing an integer
value and the time unit (years, months, days, hours, minutes,
seconds). In case of relative time an integer value is expected.

This method only modifies this object and does not commit
the modifications to the temporal database.

:param granularity: The granularity of the dataset

##### grass.temporal.AbstractSpaceTimeDataset.set_id

```python
set_id(ident)
```

Set the identifier of the dataset

##### grass.temporal.AbstractSpaceTimeDataset.set_initial_values

```python
set_initial_values(temporal_type, semantic_type=None, title=None, description=None)
```

Set the initial values of the space time dataset

In addition the command creation string is generated
an inserted into the metadata object.

This method only modifies this object and does not commit
the modifications to the temporal database.

The insert() function must be called to commit
this content into the temporal database.

:param temporal_type: The temporal type of this space
time dataset (absolute or relative)
:param semantic_type: The semantic type of this dataset
:param title: The title
:param description: The description of this dataset

##### grass.temporal.AbstractSpaceTimeDataset.set_map_register

```python
set_map_register(name)
```

Set the name of the map register table

This table stores all map names which are registered
in this space time dataset.

This method only modifies this object and does not commit
the modifications to the temporal database.

:param name: The name of the register table

##### grass.temporal.AbstractSpaceTimeDataset.set_next

```python
set_next(map)
```

Set the map that is temporally as closest located after this map.

Temporally located means that the start time of the "next" map is
temporally located AFTER the start time of this map, but temporally
near than other maps of the same dataset.

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.set_prev

```python
set_prev(map)
```

Set the map that is temporally as closest located before this map.

Temporally located means that the start time of the "previous" map
is temporally located BEFORE the start time of this map, but
temporally near than other maps of the same dataset.

:param map: This object should be of type AbstractMapDataset
or derived classes

##### grass.temporal.AbstractSpaceTimeDataset.set_relative_time_unit

```python
set_relative_time_unit(unit)
```

Set the relative time unit which may be of type:
years, months, days, hours, minutes or seconds

All maps registered in a (relative time)
space time dataset must have the same unit

This method only modifies this object and does not commit
the modifications to the temporal database.

:param unit: The relative time unit

##### grass.temporal.AbstractSpaceTimeDataset.set_spatial_topology_build_false

```python
set_spatial_topology_build_false()
```

Same as name

##### grass.temporal.AbstractSpaceTimeDataset.set_spatial_topology_build_true

```python
set_spatial_topology_build_true()
```

Same as name

##### grass.temporal.AbstractSpaceTimeDataset.set_temporal_topology_build_false

```python
set_temporal_topology_build_false()
```

Same as name

##### grass.temporal.AbstractSpaceTimeDataset.set_temporal_topology_build_true

```python
set_temporal_topology_build_true()
```

Same as name

##### grass.temporal.AbstractSpaceTimeDataset.set_topology_build_false

```python
set_topology_build_false()
```

Use this method when the spatio-temporal topology was not build

##### grass.temporal.AbstractSpaceTimeDataset.set_topology_build_true

```python
set_topology_build_true()
```

Use this method when the spatio-temporal topology was build

##### grass.temporal.AbstractSpaceTimeDataset.shift

```python
shift(gran, dbif=None)
```

Temporally shift each registered map with the provided granularity

:param gran: The granularity to be used for shifting
:param dbif: The database interface to be used
:return: True something to shift, False if nothing to shift or wrong
granularity

##### grass.temporal.AbstractSpaceTimeDataset.shift_map_list

```python
shift_map_list(maps, gran)
```

Temporally shift each map in the list with the provided granularity

This method does not perform any temporal database operations.

:param maps: A list of maps with initialized temporal extent
:param gran: The granularity to be used for shifting
:return: The modified map list, None if nothing to shift or wrong
granularity

.. code-block:: python

```
>>> import grass.temporal as tgis
>>> maps = []
>>> for i in range(5):
...     map = tgis.RasterDataset(None)
...     if i % 2 == 0:
...         check = map.set_relative_time(i, i + 1, "years")
...     else:
...         check = map.set_relative_time(i, None, "years")
...     maps.append(map)
...
>>> for map in maps:
...     map.temporal_extent.print_info()
...
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 0
 | End time:................... 1
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 1
 | End time:................... None
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 2
 | End time:................... 3
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 3
 | End time:................... None
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 4
 | End time:................... 5
 | Relative time unit:......... years
>>> maps = tgis.AbstractSpaceTimeDataset.shift_map_list(maps, 5)
>>> for map in maps:
...     map.temporal_extent.print_info()
...
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 5
 | End time:................... 6
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 6
 | End time:................... None
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 7
 | End time:................... 8
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 8
 | End time:................... None
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 9
 | End time:................... 10
 | Relative time unit:......... years
```

##### grass.temporal.AbstractSpaceTimeDataset.snap

```python
snap(dbif=None)
```

For each registered map snap the end time to the start time of
its temporal nearest neighbor in the future

Maps with equal time stamps are not snapped

:param dbif: The database interface to be used

##### grass.temporal.AbstractSpaceTimeDataset.snap_map_list

```python
snap_map_list(maps)
```

For each map in the list snap the end time to the start time of its
temporal nearest neighbor in the future.

Maps with equal time stamps are not snapped.

The granularity of the map list will be used to create the end time
of the last map in case it has a time instance as timestamp.

This method does not perform any temporal database operations.

:param maps: A list of maps with initialized temporal extent
:return: The modified map list, None nothing to shift or wrong
granularity

Usage:

.. code-block:: python

```
>>> import grass.temporal as tgis
>>> maps = []
>>> for i in range(5):
...     map = tgis.RasterDataset(None)
...     if i % 2 == 0:
...         check = map.set_relative_time(i, i + 1, "years")
...     else:
...         check = map.set_relative_time(i, None, "years")
...     maps.append(map)
...
>>> for map in maps:
...     map.temporal_extent.print_info()
...
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 0
 | End time:................... 1
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 1
 | End time:................... None
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 2
 | End time:................... 3
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 3
 | End time:................... None
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 4
 | End time:................... 5
 | Relative time unit:......... years
>>> maps = tgis.AbstractSpaceTimeDataset.snap_map_list(maps)
>>> for map in maps:
...     map.temporal_extent.print_info()
...
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 0
 | End time:................... 1
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 1
 | End time:................... 2
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 2
 | End time:................... 3
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 3
 | End time:................... 4
 | Relative time unit:......... years
 +-------------------- Relative time -----------------------------------------+
 | Start time:................. 4
 | End time:................... 5
 | Relative time unit:......... years
```

##### grass.temporal.AbstractSpaceTimeDataset.spatial_disjoint_union

```python
spatial_disjoint_union(dataset)
```

Return the spatial union as spatial_extent object.

:param dataset: The abstract dataset to create a union with
:return: The union spatial extent

##### grass.temporal.AbstractSpaceTimeDataset.spatial_intersection

```python
spatial_intersection(dataset)
```

Return the spatial intersection as spatial_extent
object or None in case no intersection was found.

:param dataset: The abstract dataset to intersect with
:return: The intersection spatial extent

##### grass.temporal.AbstractSpaceTimeDataset.spatial_overlapping

```python
spatial_overlapping(dataset)
```

Return True if the spatial extents overlap

:param dataset: The abstract dataset to check spatial overlapping
:return: True if self and the provided dataset spatial overlap

##### grass.temporal.AbstractSpaceTimeDataset.spatial_relation

```python
spatial_relation(dataset)
```

Return the spatial relationship between self and dataset

:param dataset: The abstract dataset to compute the spatial
relation with self
:return: The spatial relationship as string

##### grass.temporal.AbstractSpaceTimeDataset.spatial_union

```python
spatial_union(dataset)
```

Return the spatial union as spatial_extent
object or None in case the extents does not overlap or meet.

:param dataset: The abstract dataset to create a union with
:return: The union spatial extent

##### grass.temporal.AbstractSpaceTimeDataset.started

```python
started = property(fget=get_started, fset=append_started)
```

##### grass.temporal.AbstractSpaceTimeDataset.starts

```python
starts = property(fget=get_starts, fset=append_starts)
```

##### grass.temporal.AbstractSpaceTimeDataset.temporal_disjoint_union

```python
temporal_disjoint_union(dataset)
```

Creates a union with the provided dataset and
return a new temporal extent with the new start and end time.

:param dataset: The abstract dataset to create temporal union with
:return: The new temporal extent with start and end time

##### grass.temporal.AbstractSpaceTimeDataset.temporal_extent

```python
temporal_extent = property(fget=get_temporal_extent)
```

##### grass.temporal.AbstractSpaceTimeDataset.temporal_intersection

```python
temporal_intersection(dataset)
```

Intersect self with the provided dataset and
return a new temporal extent with the new start and end time

:param dataset: The abstract dataset to temporal intersect with
:return: The new temporal extent with start and end time,
or None in case of no intersection

##### grass.temporal.AbstractSpaceTimeDataset.temporal_relation

```python
temporal_relation(dataset)
```

Return the temporal relation of self and the provided dataset

:return: The temporal relation as string

##### grass.temporal.AbstractSpaceTimeDataset.temporal_union

```python
temporal_union(dataset)
```

Creates a union with the provided dataset and
return a new temporal extent with the new start and end time.

:param dataset: The abstract dataset to create temporal union with
:return: The new temporal extent with start and end time,
or None in case of no intersection

##### grass.temporal.AbstractSpaceTimeDataset.unregister_map

```python
unregister_map(map, dbif=None, execute=True)
```

Unregister a map from the space time dataset.

This method takes care of the un-registration of a map
from a space time dataset.

:param map: The map object to unregister
:param dbif: The database interface to be used
:param execute: If True the SQL DELETE and DROP table
statements will be executed.
If False the prepared SQL statements are
returned and must be executed by the caller.

:return: The SQL statements if execute == False, else an empty
string, None in case of a failure

##### grass.temporal.AbstractSpaceTimeDataset.update

```python
update(dbif=None, execute=True, ident=None)
```

Update the dataset entry in the database from the internal structure
excluding None variables

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are returned
and must be executed by the caller.
:param ident: The identifier to be updated, useful for renaming
:return: The SQL update statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractSpaceTimeDataset.update_all

```python
update_all(dbif=None, execute=True, ident=None)
```

Update the dataset entry in the database from the internal structure
and include None variables.

:param dbif: The database interface to be used
:param execute: If True the SQL statements will be executed.
If False the prepared SQL statements are returned
and must be executed by the caller.
:param ident: The identifier to be updated, useful for renaming
:return: The SQL update statement in case execute=False, or an
empty string otherwise

##### grass.temporal.AbstractSpaceTimeDataset.update_command_string

```python
update_command_string(dbif=None)
```

Append the current command string to any existing command string
in the metadata class and calls metadata update

:param dbif: The database interface to be used

##### grass.temporal.AbstractSpaceTimeDataset.update_from_registered_maps

```python
update_from_registered_maps(dbif=None)
```

This methods updates the modification time, the spatial and
temporal extent as well as type specific metadata. It should always
been called after maps are registered or unregistered/deleted from
the space time dataset.

The update of the temporal extent checks if the end time is set
correctly.
In case the registered maps have no valid end time (None) the
maximum start time
will be used. If the end time is earlier than the maximum start
time, it will be replaced by the maximum start time.

:param dbif: The database interface to be used

#### grass.temporal.CLibrariesInterface

```python
CLibrariesInterface()
```

Bases: <code>[RPCServerBase](#grass.pygrass.rpc.base.RPCServerBase)</code>

Fast and exit-safe interface to GRASS C-libraries functions

This class implements a fast and exit-safe interface to the GRASS
gis, raster, 3D raster and vector C-libraries functions.

The C-libraries functions are called via ctypes in a subprocess
using a pipe (multiprocessing.Pipe) to transfer the text messages.
Hence, the process that uses the CLibrariesInterface will not be
exited, if a G_fatal_error() was invoked in the subprocess.
In this case the CLibrariesInterface object will simply start a
new subprocess and restarts the pipeline.

Usage:

.. code-block:: python

```
>>> import grass.script as gscript
>>> import grass.temporal as tgis
>>> gscript.use_temp_region()
>>> gscript.run_command(
...     "g.region",
...     n=80.0,
...     s=0.0,
...     e=120.0,
...     w=0.0,
...     t=1.0,
...     b=0.0,
...     res=10.0,
...     res3=10.0,
... )
0
>>> tgis.init()
>>> gscript.run_command(
...     "r.mapcalc", expression="test = 1", overwrite=True, quiet=True
... )
0
>>> gscript.run_command(
...     "r3.mapcalc", expression="test = 1", overwrite=True, quiet=True
... )
0
>>> gscript.run_command(
...     "v.random", output="test", n=10, overwrite=True, quiet=True
... )
0
>>> gscript.run_command(
...     "r.timestamp",
...     map="test",
...     date="12 Mar 1995 10:34:40",
...     overwrite=True,
...     quiet=True,
... )
0
>>> gscript.run_command(
...     "r3.timestamp",
...     map="test",
...     date="12 Mar 1995 10:34:40",
...     overwrite=True,
...     quiet=True,
... )
0
>>> gscript.run_command(
...     "v.timestamp",
...     map="test",
...     date="12 Mar 1995 10:34:40",
...     overwrite=True,
...     quiet=True,
... )
0
