"""
This type stub file was generated by pyright.
"""

from . import editwindow, frame

"""Slices is an interactive text control in which a user types in
commands to be sent to the interpreter.  This particular shell is
based on wxPython's wxStyledTextCtrl.

Sponsored by Orbtech - Your source for Python programming expertise.
Slices is a version of shell modified by David Mashburn."""
__author__ = ...
USE_MAGIC = ...
PRINT_UPDATE_MAX_TIME = ...
NAVKEYS = ...
GROUPING_SELECTING = ...
IO_SELECTING = ...
GROUPING_START = ...
GROUPING_START_FOLDED = ...
GROUPING_MIDDLE = ...
GROUPING_END = ...
INPUT_START = ...
INPUT_START_FOLDED = ...
INPUT_MIDDLE = ...
INPUT_END = ...
OUTPUT_START = ...
OUTPUT_START_FOLDED = ...
OUTPUT_MIDDLE = ...
OUTPUT_END = ...
OUTPUT_BG = ...
READLINE_BG = ...
INPUT_READLINE = ...
GROUPING_MASK = ...
INPUT_MASK = ...
OUTPUT_MASK = ...
IO_MASK = ...
IO_START_MASK = ...
IO_START_FOLDED_MASK = ...
IO_ANY_START_MASK = ...
IO_MIDDLE_MASK = ...
IO_END_MASK = ...
usrBinEnvPythonText = ...
pyslicesFormatHeaderText = ...
groupingStartText = ...
inputStartText = ...
outputStartText = ...
tutorialText = ...
class SlicesShellFrame(frame.Frame, frame.ShellFrameMixin):
    """Frame containing the sliceshell component."""
    name = ...
    def __init__(self, parent=..., id=..., title=..., pos=..., size=..., style=..., locals=..., InterpClass=..., config=..., dataDir=..., filename=..., *args, **kwds) -> None:
        """Create SlicesShellFrame instance."""
        ...
    
    def OnClose(self, event): # -> None:
        """Event handler for closing."""
        ...
    
    def OnAbout(self, event): # -> None:
        """Display an About window."""
        ...
    
    def OnHelp(self, event): # -> None:
        """Show a help dialog."""
        ...
    
    def LoadSettings(self): # -> None:
        ...
    
    def SaveSettings(self, force=...): # -> None:
        ...
    
    def DoSaveSettings(self): # -> None:
        ...
    
    def OnEnableShellMode(self, event): # -> None:
        """Change between Slices Mode and Shell Mode"""
        ...
    
    def OnHideFoldingMargin(self, event): # -> None:
        """Change between Slices Mode and Shell Mode"""
        ...
    
    def OnIdle(self, event): # -> None:
        """Event handler for idle time."""
        ...
    
    def hasBuffer(self): # -> bool:
        """Return True if there is a current buffer."""
        ...
    
    def bufferClose(self): # -> bool:
        """Close buffer."""
        ...
    
    def bufferCreate(self, filename=...): # -> None:
        """Create new buffer."""
        ...
    
    def bufferDestroy(self): # -> None:
        """Destroy the current buffer."""
        ...
    
    def bufferHasChanged(self): # -> Literal[False]:
        """Return True if buffer has changed since last save."""
        ...
    
    def bufferNew(self): # -> bool:
        """Create new buffer."""
        ...
    
    def bufferOpen(self, file=...): # -> Literal[True] | None:
        """Open file in buffer."""
        ...
    
    def simpleSave(self, confirmed=...): # -> None:
        ...
    
    def bufferSave(self): # -> bool:
        """Save buffer to its file."""
        ...
    
    def bufferSaveAs(self): # -> bool:
        """Save buffer to a new filename."""
        ...
    
    def bufferSaveACopy(self): # -> bool:
        """Save buffer to a new filename."""
        ...
    
    def bufferSuggestSave(self): # -> bool:
        """Suggest saving changes.  Return True if user selected Cancel."""
        ...
    
    def updateNamespace(self): # -> None:
        """Update the buffer namespace for autocompletion and calltips."""
        ...
    


HELP_TEXT = ...
class SlicesShellFacade:
    """Simplified interface to all shell-related functionality.

    This is a semi-transparent facade, in that all attributes of other
    are accessible, even though only some are visible to the user."""
    name = ...
    def __init__(self, other) -> None:
        """Create a SlicesShellFacade instance."""
        ...
    
    def help(self): # -> None:
        """Display some useful information about how to use the slices shell."""
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    


DISPLAY_TEXT = ...
class SlicesShell(editwindow.EditWindow):
    """Notebook Shell based on StyledTextCtrl."""
    name = ...
    def __init__(self, parent, id=..., pos=..., size=..., style=..., introText=..., locals=..., InterpClass=..., startupScript=..., execStartupScript=..., showPySlicesTutorial=..., enableShellMode=..., useStockId=..., hideFoldingMargin=..., *args, **kwds) -> None:
        """Create Shell instance."""
        ...
    
    def ToggleShellMode(self, enableShellMode=...): # -> None:
        ...
    
    def ToggleFoldingMargin(self, hideFoldingMargin=...): # -> None:
        ...
    
    def clearHistory(self): # -> None:
        ...
    
    def destroy(self): # -> None:
        ...
    
    def setFocus(self): # -> None:
        """Set focus to the slices shell."""
        ...
    
    def OnIdle(self, event): # -> None:
        """Free the CPU to do other things."""
        ...
    
    def showIntro(self, text=...): # -> None:
        """Display introductory text in the slices shell."""
        ...
    
    def setBuiltinKeywords(self): # -> None:
        """Create pseudo keywords as part of builtins.

        This sets "close", "exit" and "quit" to a helpful string.
        """
        ...
    
    def quit(self): # -> None:
        """Quit the application."""
        ...
    
    def setLocalShell(self): # -> None:
        """Add 'slicesshell' to locals as reference to ShellFacade instance."""
        ...
    
    def execStartupScript(self, startupScript): # -> None:
        """Execute the user's PYTHONSTARTUP script if they have one."""
        ...
    
    def about(self): # -> None:
        """Display information about Py."""
        ...
    
    def BreakTextIntoCommands(self, text): # -> tuple[None, Any] | list[Any]:
        """Turn a text block into multiple multi-line commands."""
        ...
    
    def MarkerSet(self, line, markerBitsSet): # -> None:
        """MarkerSet is the Set command for MarkerGet"""
        ...
    
    def GetGroupingSlice(self, line_num=...): # -> tuple[int, int]:
        """Get the start/stop lines for the slice based on any line in the slice"""
        ...
    
    def GetIOSlice(self, line_num=...): # -> tuple[int, int]:
        """Get the start/stop lines for the slice based on any line in the slice"""
        ...
    
    def FoldGroupingSlice(self, line_num=...): # -> None:
        ...
    
    def FoldIOSlice(self, line_num=...): # -> None:
        ...
    
    def UnFoldGroupingSlice(self, line_num=...): # -> None:
        ...
    
    def UnFoldIOSlice(self, line_num=...): # -> None:
        ...
    
    def DeleteOutputSlicesAfter(self, line_num=...): # -> None:
        """Delete all outputs after an input"""
        ...
    
    def SplitSlice(self, line_num=...): # -> None:
        ...
    
    def BackspaceWMarkers(self, force=...): # -> bool:
        ...
    
    def ForwardDeleteWMarkers(self): # -> bool:
        ...
    
    def GetIOSelection(self): # -> tuple[int, int | Any]:
        ...
    
    def MergeAdjacentSlices(self): # -> None:
        ...
    
    def SliceSelectionDelete(self): # -> None:
        """Deletion of any selected and possibly discontinuous slices."""
        ...
    
    def OnChar(self, event): # -> None:
        """Keypress event handler.

        Only receives an event if OnKeyDown calls event.Skip() for the
        corresponding event."""
        ...
    
    def AutoCompActiveCallback(self): # -> None:
        ...
    
    def OnKeyDown(self, event):
        """Key down event handler."""
        ...
    
    def MarginSelectAll(self): # -> None:
        ...
    
    def MarginUnselectAll(self): # -> None:
        ...
    
    def DoMarginClick(self, lineClicked, margin, shiftDown, controlDown): # -> None:
        ...
    
    def OnMarginClick(self, evt): # -> None:
        ...
    
    def OnShowCompHistory(self): # -> None:
        """Show possible autocompletion Words from already typed words."""
        ...
    
    def ReplaceSelection(self, text, sliceDeletion=..., *args, **kwds): # -> None:
        ...
    
    def clearCommand(self): # -> None:
        """Delete the current, unexecuted command."""
        ...
    
    def OnHistoryReplace(self, step): # -> None:
        """Replace with the previous/next command from the history buffer."""
        ...
    
    def replaceFromHistory(self, step): # -> None:
        """Replace selection with command from the history buffer."""
        ...
    
    def OnHistoryInsert(self, step): # -> None:
        """Insert the previous/next command from the history buffer."""
        ...
    
    def OnHistorySearch(self): # -> None:
        """Search up the history buffer for the text in front of the cursor."""
        ...
    
    def setStatusText(self, text): # -> None:
        """Display status information."""
        ...
    
    def insertLineBreak(self): # -> None:
        """Insert a new line break."""
        ...
    
    def processLine(self): # -> None:
        """Process the line of text at which the user hit Enter or Shift+RETURN."""
        ...
    
    def getMultilineCommand(self, rstrip=...): # -> LiteralString | Literal['']:
        """Extract a multi-line command from the editor.

        The command may not necessarily be valid Python syntax."""
        ...
    
    def getCommand(self, text=..., rstrip=...):
        """Extract a command from text which may include a shell prompt.

        The command may not necessarily be valid Python syntax."""
        ...
    
    def lstripPrompt(self, text):
        """Return text without a leading prompt."""
        ...
    
    def push(self, command, silent=..., useMultiCommand=...): # -> None:
        """Send command to the interpreter for execution."""
        ...
    
    def addHistory(self, command): # -> None:
        """Add command to the command history."""
        ...
    
    def clearGroupingMarkers(self, line_num=...): # -> None:
        ...
    
    def clearIOMarkers(self, line_num=...): # -> None:
        ...
    
    def ensureSingleGroupingMarker(self, line_num=...): # -> Literal[1, 0]:
        ...
    
    def ensureSingleIOMarker(self, line_num=...): # -> Literal[1, 0]:
        ...
    
    def RestoreFirstMarker(self): # -> None:
        ...
    
    def IsAllowedPair(self, m1, m2): # -> bool:
        """This testing function ensures that two adjacent markers are valid"""
        ...
    
    def CleanAllMarkers(self): # -> None:
        ...
    
    def write(self, text, type=..., silent=...):
        """Display text in the slices shell.

        Replace line endings with OS-specific endings."""
        ...
    
    def fixLineEndings(self, text): # -> str:
        """Return text with line endings replaced by OS-specific endings."""
        ...
    
    def prompt(self): # -> None:
        """Display proper prompt for the context: ps1, ps2 or ps3.

        If this is a continuation line, autoindent as necessary."""
        ...
    
    def readline(self): # -> str:
        """Replacement for stdin.readline()."""
        ...
    
    def readlines(self): # -> list[Any]:
        """Replacement for stdin.readlines()."""
        ...
    
    def raw_input(self, prompt=...): # -> str:
        """Return string based on user input."""
        ...
    
    def ask(self, prompt=...): # -> Literal['']:
        """Get response from the user using a dialog box."""
        ...
    
    def pause(self): # -> None:
        """Halt execution pending a response from the user."""
        ...
    
    def clear(self): # -> None:
        """Delete all text from the slices shell."""
        ...
    
    def run(self, command, prompt=..., verbose=...): # -> None:
        """Execute command as if it was typed in directly.
        >>> shell.run('print("this")')
        >>> print("this")
        this
        >>>
        """
        ...
    
    def runfile(self, filename): # -> None:
        """Execute all commands in file as if they were typed into the shell."""
        ...
    
    def autoCompleteShow(self, command, offset=...): # -> None:
        """Display auto-completion popup list."""
        ...
    
    def autoCallTipShow(self, command, insertcalltip=..., forceCallTip=...): # -> None:
        """Display argument spec and docstring in a popup window."""
        ...
    
    def OnCallTipAutoCompleteManually(self, shiftDown): # -> None:
        """AutoComplete and Calltips manually."""
        ...
    
    def writeOut(self, text): # -> None:
        """Replacement for stdout."""
        ...
    
    def writeErr(self, text): # -> None:
        """Replacement for stderr."""
        ...
    
    def redirectStdin(self, redirect=...): # -> None:
        """If redirect is true then sys.stdin will come from the shell."""
        ...
    
    def redirectStdout(self, redirect=...): # -> None:
        """If redirect is true then sys.stdout will go to the shell."""
        ...
    
    def redirectStderr(self, redirect=...): # -> None:
        """If redirect is true then sys.stderr will go to the shell."""
        ...
    
    def UpdateUndoHistoryBefore(self, actionType, s, posStart, posEnd, forceNewAction=...): # -> None:
        ...
    
    def UpdateUndoHistoryAfter(self): # -> None:
        ...
    
    def Undo(self): # -> None:
        ...
    
    def Redo(self): # -> None:
        ...
    
    def EmptyUndoBuffer(self): # -> None:
        ...
    
    def CanCut(self): # -> Literal[False]:
        ...
    
    def CanPaste(self): # -> bool:
        """Return true if a paste should succeed."""
        ...
    
    def CanEdit(self): # -> bool:
        """Return true if editing should succeed."""
        ...
    
    def Cut(self): # -> None:
        """Remove selection and place it on the clipboard."""
        ...
    
    def Copy(self): # -> None:
        """Copy selection and place it on the clipboard."""
        ...
    
    def CopyWithPrompts(self): # -> None:
        """Copy selection, including prompts, and place it on the clipboard."""
        ...
    
    def CopyWithPromptsPrefixed(self): # -> None:
        """Copy selection, including prompts prefixed with four
        spaces, and place it on the clipboard."""
        ...
    
    def Paste(self): # -> None:
        """Replace selection with clipboard contents."""
        ...
    
    def PasteAndRun(self): # -> None:
        """Replace selection with clipboard contents, run commands."""
        ...
    
    def Execute(self, text): # -> None:
        """Replace selection with text and run commands."""
        ...
    
    def wrap(self, wrap=...): # -> Literal['Wrapping is not available in this version.'] | None:
        """Sets whether text is word wrapped."""
        ...
    
    def zoom(self, points=...): # -> None:
        """Set the zoom level.

        This number of points is added to the size of all fonts.  It
        may be positive to magnify or negative to reduce."""
        ...
    
    def LoadSettings(self, config): # -> None:
        ...
    
    def SaveSettings(self, config): # -> None:
        ...
    
    def GetContextMenu(self): # -> Menu:
        """
            Create and return a context menu for the slices shell.
            This is used instead of the scintilla default menu
            in order to correctly respect our immutable buffer.
        """
        ...
    
    def OnContextMenu(self, evt): # -> None:
        ...
    
    def OnUpdateUI(self, evt): # -> None:
        ...
    
    def LoadPySlicesFile(self, fid):
        ...
    
    def SavePySlicesFile(self, fid): # -> None:
        ...
    
    def LoadPyFileAsSlice(self, fid): # -> None:
        ...
    
    def hasChanged(self): # -> bool:
        """Return True if contents have changed."""
        ...
    


