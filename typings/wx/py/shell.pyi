"""
This type stub file was generated by pyright.
"""

from . import editwindow, frame

"""Shell is an interactive text control in which a user types in
commands to be sent to the interpreter.  This particular shell is
based on wxPython's wxStyledTextCtrl.

Sponsored by Orbtech - Your source for Python programming expertise."""
__author__ = ...
USE_MAGIC = ...
PRINT_UPDATE_MAX_TIME = ...
NAVKEYS = ...
class ShellFrame(frame.Frame, frame.ShellFrameMixin):
    """Frame containing the shell component."""
    name = ...
    def __init__(self, parent=..., id=..., title=..., pos=..., size=..., style=..., locals=..., InterpClass=..., config=..., dataDir=..., *args, **kwds) -> None:
        """Create ShellFrame instance."""
        ...
    
    def OnClose(self, event): # -> None:
        """Event handler for closing."""
        ...
    
    def OnAbout(self, event): # -> None:
        """Display an About window."""
        ...
    
    def OnHelp(self, event): # -> None:
        """Show a help dialog."""
        ...
    
    def LoadSettings(self): # -> None:
        ...
    
    def SaveSettings(self, force=...): # -> None:
        ...
    
    def DoSaveSettings(self): # -> None:
        ...
    


HELP_TEXT = ...
class ShellFacade:
    """Simplified interface to all shell-related functionality.

    This is a semi-transparent facade, in that all attributes of other
    are accessible, even though only some are visible to the user."""
    name = ...
    def __init__(self, other) -> None:
        """Create a ShellFacade instance."""
        ...
    
    def help(self): # -> None:
        """Display some useful information about how to use the shell."""
        ...
    
    def __getattr__(self, name): # -> Any:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    


DISPLAY_TEXT = ...
class Shell(editwindow.EditWindow):
    """Shell based on StyledTextCtrl."""
    name = ...
    def __init__(self, parent, id=..., pos=..., size=..., style=..., introText=..., locals=..., InterpClass=..., startupScript=..., execStartupScript=..., useStockId=..., *args, **kwds) -> None:
        """Create Shell instance."""
        ...
    
    def clearHistory(self): # -> None:
        ...
    
    def destroy(self): # -> None:
        ...
    
    def setFocus(self): # -> None:
        """Set focus to the shell."""
        ...
    
    def OnIdle(self, event): # -> None:
        """Free the CPU to do other things."""
        ...
    
    def showIntro(self, text=...): # -> None:
        """Display introductory text in the shell."""
        ...
    
    def setBuiltinKeywords(self): # -> None:
        """Create pseudo keywords as part of builtins.

        This sets "close", "exit" and "quit" to a helpful string.
        """
        ...
    
    def quit(self): # -> None:
        """Quit the application."""
        ...
    
    def setLocalShell(self): # -> None:
        """Add 'shell' to locals as reference to ShellFacade instance."""
        ...
    
    def execStartupScript(self, startupScript): # -> None:
        """Execute the user's PYTHONSTARTUP script if they have one."""
        ...
    
    def about(self): # -> None:
        """Display information about Py."""
        ...
    
    def OnChar(self, event): # -> None:
        """Keypress event handler.

        Only receives an event if OnKeyDown calls event.Skip() for the
        corresponding event."""
        ...
    
    def OnKeyDown(self, event):
        """Key down event handler."""
        ...
    
    def OnShowCompHistory(self): # -> None:
        """Show possible autocompletion Words from already typed words."""
        ...
    
    def clearCommand(self): # -> None:
        """Delete the current, unexecuted command."""
        ...
    
    def OnHistoryReplace(self, step): # -> None:
        """Replace with the previous/next command from the history buffer."""
        ...
    
    def replaceFromHistory(self, step): # -> None:
        """Replace selection with command from the history buffer."""
        ...
    
    def OnHistoryInsert(self, step): # -> None:
        """Insert the previous/next command from the history buffer."""
        ...
    
    def OnHistorySearch(self): # -> None:
        """Search up the history buffer for the text in front of the cursor."""
        ...
    
    def setStatusText(self, text): # -> None:
        """Display status information."""
        ...
    
    def insertLineBreak(self): # -> None:
        """Insert a new line break."""
        ...
    
    def processLine(self): # -> None:
        """Process the line of text at which the user hit Enter."""
        ...
    
    def getMultilineCommand(self, rstrip=...): # -> LiteralString | Literal['']:
        """Extract a multi-line command from the editor.

        The command may not necessarily be valid Python syntax."""
        ...
    
    def getCommand(self, text=..., rstrip=...): # -> LiteralString | Literal['']:
        """Extract a command from text which may include a shell prompt.

        The command may not necessarily be valid Python syntax."""
        ...
    
    def lstripPrompt(self, text):
        """Return text without a leading prompt."""
        ...
    
    def push(self, command, silent=...): # -> None:
        """Send command to the interpreter for execution."""
        ...
    
    def addHistory(self, command): # -> None:
        """Add command to the command history."""
        ...
    
    def write(self, text): # -> None:
        """Display text in the shell.

        Replace line endings with OS-specific endings."""
        ...
    
    def fixLineEndings(self, text): # -> str:
        """Return text with line endings replaced by OS-specific endings."""
        ...
    
    def prompt(self): # -> None:
        """Display proper prompt for the context: ps1, ps2 or ps3.

        If this is a continuation line, autoindent as necessary."""
        ...
    
    def readline(self): # -> str:
        """Replacement for stdin.readline()."""
        ...
    
    def readlines(self): # -> list[Any]:
        """Replacement for stdin.readlines()."""
        ...
    
    def raw_input(self, prompt=...): # -> str:
        """Return string based on user input."""
        ...
    
    def ask(self, prompt=...): # -> Literal['']:
        """Get response from the user using a dialog box."""
        ...
    
    def pause(self): # -> None:
        """Halt execution pending a response from the user."""
        ...
    
    def clear(self): # -> None:
        """Delete all text from the shell."""
        ...
    
    def run(self, command, prompt=..., verbose=...): # -> None:
        """Execute command as if it was typed in directly.
        >>> shell.run('print("this")')
        >>> print("this")
        this
        >>>
        """
        ...
    
    def runfile(self, filename): # -> None:
        """Execute all commands in file as if they were typed into the
        shell."""
        ...
    
    def autoCompleteShow(self, command, offset=...): # -> None:
        """Display auto-completion popup list."""
        ...
    
    def autoCallTipShow(self, command, insertcalltip=..., forceCallTip=...): # -> None:
        """Display argument spec and docstring in a popup window."""
        ...
    
    def OnCallTipAutoCompleteManually(self, shiftDown): # -> None:
        """AutoComplete and Calltips manually."""
        ...
    
    def writeOut(self, text): # -> None:
        """Replacement for stdout."""
        ...
    
    def writeErr(self, text): # -> None:
        """Replacement for stderr."""
        ...
    
    def redirectStdin(self, redirect=...): # -> None:
        """If redirect is true then sys.stdin will come from the shell."""
        ...
    
    def redirectStdout(self, redirect=...): # -> None:
        """If redirect is true then sys.stdout will go to the shell."""
        ...
    
    def redirectStderr(self, redirect=...): # -> None:
        """If redirect is true then sys.stderr will go to the shell."""
        ...
    
    def CanCut(self): # -> bool:
        """Return true if text is selected and can be cut."""
        ...
    
    def CanPaste(self): # -> bool:
        """Return true if a paste should succeed."""
        ...
    
    def CanEdit(self): # -> bool:
        """Return true if editing should succeed."""
        ...
    
    def Cut(self): # -> None:
        """Remove selection and place it on the clipboard."""
        ...
    
    def Copy(self): # -> None:
        """Copy selection and place it on the clipboard."""
        ...
    
    def CopyWithPrompts(self): # -> None:
        """Copy selection, including prompts, and place it on the clipboard."""
        ...
    
    def CopyWithPromptsPrefixed(self): # -> None:
        """Copy selection, including prompts prefixed with four
        spaces, and place it on the clipboard."""
        ...
    
    def Paste(self): # -> None:
        """Replace selection with clipboard contents."""
        ...
    
    def PasteAndRun(self): # -> None:
        """Replace selection with clipboard contents, run commands."""
        ...
    
    def Execute(self, text): # -> None:
        """Replace selection with text and run commands."""
        ...
    
    def wrap(self, wrap=...): # -> None:
        """Sets whether text is word wrapped."""
        ...
    
    def zoom(self, points=...): # -> None:
        """Set the zoom level.

        This number of points is added to the size of all fonts.  It
        may be positive to magnify or negative to reduce."""
        ...
    
    def LoadSettings(self, config): # -> None:
        ...
    
    def SaveSettings(self, config): # -> None:
        ...
    
    def GetContextMenu(self): # -> Menu:
        """
            Create and return a context menu for the shell.
            This is used instead of the scintilla default menu
            in order to correctly respect our immutable buffer.
        """
        ...
    
    def OnContextMenu(self, evt): # -> None:
        ...
    


